{"ast":null,"code":"import _asyncToGenerator from \"/Users/queaujeanpierre/Development/latest/angular-sqlite-app-starter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { r as registerInstance, e as createEvent } from './index-e8b6ffef.js';\nconst global$1 = typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}; // shim for using process in browser\n// based off https://github.com/defunctzombie/node-process/blob/master/browser.js\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\nvar cachedSetTimeout = defaultSetTimout;\nvar cachedClearTimeout = defaultClearTimeout;\n\nif (typeof global$1.setTimeout === 'function') {\n  cachedSetTimeout = setTimeout;\n}\n\nif (typeof global$1.clearTimeout === 'function') {\n  cachedClearTimeout = clearTimeout;\n}\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nfunction nextTick(fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n} // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nvar title = 'browser';\nvar platform = 'browser';\nvar browser = true;\nvar env = {};\nvar argv = [];\nvar version = ''; // empty string to avoid regexp issues\n\nvar versions = {};\nvar release = {};\nvar config = {};\n\nfunction noop() {}\n\nvar on = noop;\nvar addListener = noop;\nvar once = noop;\nvar off = noop;\nvar removeListener = noop;\nvar removeAllListeners = noop;\nvar emit = noop;\n\nfunction binding(name) {\n  throw new Error('process.binding is not supported');\n}\n\nfunction cwd() {\n  return '/';\n}\n\nfunction chdir(dir) {\n  throw new Error('process.chdir is not supported');\n}\n\nfunction umask() {\n  return 0;\n} // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\n\n\nvar performance$1 = global$1.performance || {};\n\nvar performanceNow = performance$1.now || performance$1.mozNow || performance$1.msNow || performance$1.oNow || performance$1.webkitNow || function () {\n  return new Date().getTime();\n}; // generate timestamp or delta\n// see http://nodejs.org/api/process.html#process_process_hrtime\n\n\nfunction hrtime(previousTimestamp) {\n  var clocktime = performanceNow.call(performance$1) * 1e-3;\n  var seconds = Math.floor(clocktime);\n  var nanoseconds = Math.floor(clocktime % 1 * 1e9);\n\n  if (previousTimestamp) {\n    seconds = seconds - previousTimestamp[0];\n    nanoseconds = nanoseconds - previousTimestamp[1];\n\n    if (nanoseconds < 0) {\n      seconds--;\n      nanoseconds += 1e9;\n    }\n  }\n\n  return [seconds, nanoseconds];\n}\n\nvar startTime = new Date();\n\nfunction uptime() {\n  var currentTime = new Date();\n  var dif = currentTime - startTime;\n  return dif / 1000;\n}\n\nvar browser$1 = {\n  nextTick: nextTick,\n  title: title,\n  browser: browser,\n  env: env,\n  argv: argv,\n  version: version,\n  versions: versions,\n  on: on,\n  addListener: addListener,\n  once: once,\n  off: off,\n  removeListener: removeListener,\n  removeAllListeners: removeAllListeners,\n  emit: emit,\n  binding: binding,\n  cwd: cwd,\n  chdir: chdir,\n  umask: umask,\n  hrtime: hrtime,\n  platform: platform,\n  release: release,\n  config: config,\n  uptime: uptime\n};\nconst __dirname = '/Users/queaujeanpierre/Development/latest/jeep-sqlite/node_modules/sql.js/dist';\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar inited = false;\n\nfunction init() {\n  inited = true;\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n  }\n\n  revLookup['-'.charCodeAt(0)] = 62;\n  revLookup['_'.charCodeAt(0)] = 63;\n}\n\nfunction toByteArray(b64) {\n  if (!inited) {\n    init();\n  }\n\n  var i, j, l, tmp, placeHolders, arr;\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');\n  } // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n\n\n  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data\n\n  arr = new Arr(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars\n\n  l = placeHolders > 0 ? len - 4 : len;\n  var L = 0;\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[L++] = tmp >> 16 & 0xFF;\n    arr[L++] = tmp >> 8 & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  if (placeHolders === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[L++] = tmp & 0xFF;\n  } else if (placeHolders === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[L++] = tmp >> 8 & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  return arr;\n}\n\nfunction tripletToBase64(num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\n\nfunction encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n    output.push(tripletToBase64(tmp));\n  }\n\n  return output.join('');\n}\n\nfunction fromByteArray(uint8) {\n  if (!inited) {\n    init();\n  }\n\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n  var output = '';\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n  // go through the array every three bytes, we'll deal with trailing stuff later\n\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    output += lookup[tmp >> 2];\n    output += lookup[tmp << 4 & 0x3F];\n    output += '==';\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    output += lookup[tmp >> 10];\n    output += lookup[tmp >> 4 & 0x3F];\n    output += lookup[tmp << 2 & 0x3F];\n    output += '=';\n  }\n\n  parts.push(output);\n  return parts.join('');\n}\n\nfunction read$1(buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? nBytes - 1 : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n  i += d;\n  e = s & (1 << -nBits) - 1;\n  s >>= -nBits;\n  nBits += eLen;\n\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : (s ? -1 : 1) * Infinity;\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n}\n\nfunction write(buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n  var i = isLE ? 0 : nBytes - 1;\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = e << mLen | m;\n  eLen += mLen;\n\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n}\n\nvar toString = {}.toString;\n\nvar isArray = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n\nvar INSPECT_MAX_BYTES = 50;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\n\nBuffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;\n/*\n * Export kMaxLength after typed array support is determined.\n */\n\nvar _kMaxLength = kMaxLength();\n\nfunction kMaxLength() {\n  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n}\n\nfunction createBuffer(that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length');\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length);\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length);\n    }\n\n    that.length = length;\n  }\n\n  return that;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\n\nfunction Buffer(arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length);\n  } // Common case.\n\n\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error('If encoding is specified then the first argument must be a string');\n    }\n\n    return allocUnsafe(this, arg);\n  }\n\n  return from(this, arg, encodingOrOffset, length);\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n// TODO: Legacy, not needed anymore. Remove in next major version.\n\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype;\n  return arr;\n};\n\nfunction from(that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length);\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset);\n  }\n\n  return fromObject(that, value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\n\n\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length);\n};\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array;\n}\n\nfunction assertSize(size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number');\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative');\n  }\n}\n\nfunction alloc(that, size, fill, encoding) {\n  assertSize(size);\n\n  if (size <= 0) {\n    return createBuffer(that, size);\n  }\n\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n  }\n\n  return createBuffer(that, size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\n\n\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding);\n};\n\nfunction allocUnsafe(that, size) {\n  assertSize(size);\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0;\n    }\n  }\n\n  return that;\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\n\n\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\n\n\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size);\n};\n\nfunction fromString(that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding');\n  }\n\n  var length = byteLength(string, encoding) | 0;\n  that = createBuffer(that, length);\n  var actual = that.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual);\n  }\n\n  return that;\n}\n\nfunction fromArrayLike(that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  that = createBuffer(that, length);\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255;\n  }\n\n  return that;\n}\n\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds');\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds');\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array);\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset);\n  } else {\n    array = new Uint8Array(array, byteOffset, length);\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array;\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array);\n  }\n\n  return that;\n}\n\nfunction fromObject(that, obj) {\n  if (internalIsBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    that = createBuffer(that, len);\n\n    if (that.length === 0) {\n      return that;\n    }\n\n    obj.copy(that, 0, 0, len);\n    return that;\n  }\n\n  if (obj) {\n    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0);\n      }\n\n      return fromArrayLike(that, obj);\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data);\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n}\n\nfunction checked(length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');\n  }\n\n  return length | 0;\n}\n\nfunction SlowBuffer(length) {\n  if (+length != length) {\n    // eslint-disable-line eqeqeq\n    length = 0;\n  }\n\n  return Buffer.alloc(+length);\n}\n\nBuffer.isBuffer = isBuffer;\n\nfunction internalIsBuffer(b) {\n  return !!(b != null && b._isBuffer);\n}\n\nBuffer.compare = function compare(a, b) {\n  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers');\n  }\n\n  if (a === b) return 0;\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true;\n\n    default:\n      return false;\n  }\n};\n\nBuffer.concat = function concat(list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers');\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0);\n  }\n\n  var i;\n\n  if (length === undefined) {\n    length = 0;\n\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n\n    if (!internalIsBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n\n  return buffer;\n};\n\nfunction byteLength(string, encoding) {\n  if (internalIsBuffer(string)) {\n    return string.length;\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength;\n  }\n\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n\n  var len = string.length;\n  if (len === 0) return 0; // Use a for loop to avoid recursion\n\n  var loweredCase = false;\n\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len;\n\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length;\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2;\n\n      case 'hex':\n        return len >>> 1;\n\n      case 'base64':\n        return base64ToBytes(string).length;\n\n      default:\n        if (loweredCase) return utf8ToBytes(string).length; // assume utf8\n\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\nBuffer.byteLength = byteLength;\n\nfunction slowToString(encoding, start, end) {\n  var loweredCase = false; // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\n  if (start === undefined || start < 0) {\n    start = 0;\n  } // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n\n\n  if (start > this.length) {\n    return '';\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return '';\n  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\n\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return '';\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end);\n\n      case 'ascii':\n        return asciiSlice(this, start, end);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end);\n\n      case 'base64':\n        return base64Slice(this, start, end);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\n\n\nBuffer.prototype._isBuffer = true;\n\nfunction swap(b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  var len = this.length;\n\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits');\n  }\n\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n\n  return this;\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  var len = this.length;\n\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits');\n  }\n\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n\n  return this;\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  var len = this.length;\n\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits');\n  }\n\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n\n  return this;\n};\n\nBuffer.prototype.toString = function toString() {\n  var length = this.length | 0;\n  if (length === 0) return '';\n  if (arguments.length === 0) return utf8Slice(this, 0, length);\n  return slowToString.apply(this, arguments);\n};\n\nBuffer.prototype.equals = function equals(b) {\n  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');\n  if (this === b) return true;\n  return Buffer.compare(this, b) === 0;\n};\n\nBuffer.prototype.inspect = function inspect() {\n  var str = '';\n  var max = INSPECT_MAX_BYTES;\n\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max) str += ' ... ';\n  }\n\n  return '<Buffer ' + str + '>';\n};\n\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n  if (!internalIsBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer');\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index');\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0;\n  }\n\n  if (thisStart >= thisEnd) {\n    return -1;\n  }\n\n  if (start >= end) {\n    return 1;\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n  if (this === target) return 0;\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\n\n\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1; // Normalize byteOffset\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n\n  byteOffset = +byteOffset; // Coerce to Number.\n\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : buffer.length - 1;\n  } // Normalize byteOffset: negative offsets start from the end of the buffer\n\n\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1;else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;else return -1;\n  } // Normalize val\n\n\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  } // Finally, search either indexOf (if dir is true) or lastIndexOf\n\n\n  if (internalIsBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1;\n    }\n\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n\n    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n      }\n    }\n\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n  }\n\n  throw new TypeError('val must be string, number or Buffer');\n}\n\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n\n    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1;\n      }\n\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read(buf, i) {\n    if (indexSize === 1) {\n      return buf[i];\n    } else {\n      return buf.readUInt16BE(i * indexSize);\n    }\n  }\n\n  var i;\n\n  if (dir) {\n    var foundIndex = -1;\n\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break;\n        }\n      }\n\n      if (found) return i;\n    }\n  }\n\n  return -1;\n}\n\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\n\nfunction hexWrite(buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n\n    if (length > remaining) {\n      length = remaining;\n    }\n  } // must be an even number of digits\n\n\n  var strLen = string.length;\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(parsed)) return i;\n    buf[offset + i] = parsed;\n  }\n\n  return i;\n}\n\nfunction utf8Write(buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nfunction asciiWrite(buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\n\nfunction latin1Write(buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length);\n}\n\nfunction base64Write(buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\n\nfunction ucs2Write(buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0; // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0; // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n\n    if (isFinite(length)) {\n      length = length | 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    } // legacy write(string, encoding, offset, length) - remove in v0.13\n\n  } else {\n    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds');\n  }\n\n  if (!encoding) encoding = 'utf8';\n  var loweredCase = false;\n\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length);\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length);\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  };\n};\n\nfunction base64Slice(buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return fromByteArray(buf);\n  } else {\n    return fromByteArray(buf.slice(start, end));\n  }\n}\n\nfunction utf8Slice(buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n  var i = start;\n\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n\n          break;\n\n        case 2:\n          secondByte = buf[i + 1];\n\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n          break;\n\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n          break;\n\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res);\n} // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\n\n\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray(codePoints) {\n  var len = codePoints.length;\n\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n  } // Decode in chunks to avoid \"call stack size exceeded\".\n\n\n  var res = '';\n  var i = 0;\n\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n\n  return res;\n}\n\nfunction asciiSlice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n\n  return ret;\n}\n\nfunction latin1Slice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n\n  return ret;\n}\n\nfunction hexSlice(buf, start, end) {\n  var len = buf.length;\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n  var out = '';\n\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i]);\n  }\n\n  return out;\n}\n\nfunction utf16leSlice(buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = '';\n\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n\n  return res;\n}\n\nBuffer.prototype.slice = function slice(start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n  var newBuf;\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    newBuf.__proto__ = Buffer.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n\n  return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\n\n\nfunction checkOffset(offset, ext, length) {\n  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset];\n};\n\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | this[offset + 1] << 8;\n};\n\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] << 8 | this[offset + 1];\n};\n\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\n\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\n\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  mul *= 0x80;\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n  return val;\n};\n\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n\n  mul *= 0x80;\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n  return val;\n};\n\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return this[offset];\n  return (0xff - this[offset] + 1) * -1;\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | this[offset + 1] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | this[offset] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\n\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read$1(this, offset, true, 23, 4);\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read$1(this, offset, false, 23, 4);\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read$1(this, offset, true, 52, 8);\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read$1(this, offset, false, 52, 8);\n};\n\nfunction checkInt(buf, value, offset, ext, max, min) {\n  if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1;\n\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n\n  return offset + 2;\n};\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n\n  return offset + 2;\n};\n\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1;\n\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n\n  return offset + 4;\n};\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n\n  return offset + 4;\n};\n\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n\n  return offset + 4;\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n\n  return offset + 4;\n};\n\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n  if (offset < 0) throw new RangeError('Index out of range');\n}\n\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4);\n  }\n\n  write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4;\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert);\n};\n\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8);\n  }\n\n  write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8;\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert);\n}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n  if (end === start) return 0;\n  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds');\n  }\n\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?\n\n  if (end > this.length) end = this.length;\n\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n  }\n\n  return len;\n}; // Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\n\n\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n\n      if (code < 256) {\n        val = code;\n      }\n    }\n\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string');\n    }\n\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding);\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  } // Invalid ranges are not set to a default, so can range check early.\n\n\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index');\n  }\n\n  if (end <= start) {\n    return this;\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n  if (!val) val = 0;\n  var i;\n\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n    var len = bytes.length;\n\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this;\n}; // HELPER FUNCTIONS\n// ================\n\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\nfunction base64clean(str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''\n\n  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n\n  return str;\n}\n\nfunction stringtrim(str) {\n  if (str.trim) return str.trim();\n  return str.replace(/^\\s+|\\s+$/g, '');\n}\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i); // is surrogate component\n\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } // valid lead\n\n\n        leadSurrogate = codePoint;\n        continue;\n      } // 2 leads in a row\n\n\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue;\n      } // valid surrogate pair\n\n\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null; // encode utf8\n\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break;\n      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break;\n      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break;\n      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n\n  return bytes;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n\n  return byteArray;\n}\n\nfunction utf16leToBytes(str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break;\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return toByteArray(base64clean(str));\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if (i + offset >= dst.length || i >= src.length) break;\n    dst[i + offset] = src[i];\n  }\n\n  return i;\n}\n\nfunction isnan(val) {\n  return val !== val; // eslint-disable-line no-self-compare\n} // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\n\n\nfunction isBuffer(obj) {\n  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));\n}\n\nfunction isFastBuffer(obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);\n} // For Node v0.10 support. Remove this eventually.\n\n\nfunction isSlowBuffer(obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, basedir, module) {\n  return module = {\n    path: basedir,\n    exports: {},\n    require: function (path, base) {\n      return commonjsRequire(path, base === undefined || base === null ? module.path : base);\n    }\n  }, fn(module, module.exports), module.exports;\n}\n\nfunction getDefaultExportFromNamespaceIfPresent(n) {\n  return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;\n}\n\nfunction getDefaultExportFromNamespaceIfNotNamed(n) {\n  return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;\n}\n\nfunction getAugmentedNamespace(n) {\n  if (n.__esModule) return n;\n  var a = Object.defineProperty({}, '__esModule', {\n    value: true\n  });\n  Object.keys(n).forEach(function (k) {\n    var d = Object.getOwnPropertyDescriptor(n, k);\n    Object.defineProperty(a, k, d.get ? d : {\n      enumerable: true,\n      get: function () {\n        return n[k];\n      }\n    });\n  });\n  return a;\n}\n\nfunction commonjsRequire() {\n  throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n} // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\n\n\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  } // if the path is allowed to go above the root, restore leading ..s\n\n\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n} // Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\n\n\nvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n\nvar splitPath = function (filename) {\n  return splitPathRe.exec(filename).slice(1);\n}; // path.resolve([from ...], to)\n// posix version\n\n\nfunction resolve() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = i >= 0 ? arguments[i] : '/'; // Skip empty and invalid entries\n\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  } // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n  // Normalize the path\n\n\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n}\n\n; // path.normalize(path)\n// posix version\n\nfunction normalize(path) {\n  var isPathAbsolute = isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/'; // Normalize the path\n\n  path = normalizeArray(filter(path.split('/'), function (p) {\n    return !!p;\n  }), !isPathAbsolute).join('/');\n\n  if (!path && !isPathAbsolute) {\n    path = '.';\n  }\n\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isPathAbsolute ? '/' : '') + path;\n}\n\n; // posix version\n\nfunction isAbsolute(path) {\n  return path.charAt(0) === '/';\n} // posix version\n\n\nfunction join() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return normalize(filter(paths, function (p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n\n    return p;\n  }).join('/'));\n} // path.relative(from, to)\n// posix version\n\n\nfunction relative(from, to) {\n  from = resolve(from).substr(1);\n  to = resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n  return outputParts.join('/');\n}\n\nvar sep = '/';\nvar delimiter = ':';\n\nfunction dirname(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n}\n\nfunction basename(path, ext) {\n  var f = splitPath(path)[2]; // TODO: make this comparison case-insensitive on windows?\n\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n\n  return f;\n}\n\nfunction extname(path) {\n  return splitPath(path)[3];\n}\n\nconst path = {\n  extname: extname,\n  basename: basename,\n  dirname: dirname,\n  sep: sep,\n  delimiter: delimiter,\n  relative: relative,\n  join: join,\n  isAbsolute: isAbsolute,\n  normalize: normalize,\n  resolve: resolve\n};\n\nfunction filter(xs, f) {\n  if (xs.filter) return xs.filter(f);\n  var res = [];\n\n  for (var i = 0; i < xs.length; i++) {\n    if (f(xs[i], i, xs)) res.push(xs[i]);\n  }\n\n  return res;\n} // String.prototype.substr - negative index don't work in IE8\n\n\nvar substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {\n  return str.substr(start, len);\n} : function (str, start, len) {\n  if (start < 0) start = str.length + start;\n  return str.substr(start, len);\n};\nconst path$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  resolve: resolve,\n  normalize: normalize,\n  isAbsolute: isAbsolute,\n  join: join,\n  relative: relative,\n  sep: sep,\n  delimiter: delimiter,\n  dirname: dirname,\n  basename: basename,\n  extname: extname,\n  'default': path\n});\nconst empty = {};\nconst empty$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  'default': empty\n});\nconst require$$0 = /*@__PURE__*/getAugmentedNamespace(path$1);\nconst require$$2 = /*@__PURE__*/getAugmentedNamespace(empty$1);\nvar sqlWasm = createCommonjsModule(function (module, exports) {\n  // We are modularizing this manually because the current modularize setting in Emscripten has some issues:\n  // https://github.com/kripken/emscripten/issues/5820\n  // In addition, When you use emcc's modularization, it still expects to export a global object called `Module`,\n  // which is able to be used/called before the WASM is loaded.\n  // The modularization below exports a promise that loads and resolves to the actual sql.js module.\n  // That way, this module can't be used before the WASM is finished loading.\n  // We are going to define a function that a user will call to start loading initializing our Sql.js library\n  // However, that function might be called multiple times, and on subsequent calls, we don't actually want it to instantiate a new instance of the Module\n  // Instead, we want to return the previously loaded module\n  // TODO: Make this not declare a global if used in the browser\n  var initSqlJsPromise = undefined;\n\n  var initSqlJs = function (moduleConfig) {\n    if (initSqlJsPromise) {\n      return initSqlJsPromise;\n    } // If we're here, we've never called this function before\n\n\n    initSqlJsPromise = new Promise(function (resolveModule, reject) {\n      // We are modularizing this manually because the current modularize setting in Emscripten has some issues:\n      // https://github.com/kripken/emscripten/issues/5820\n      // The way to affect the loading of emcc compiled modules is to create a variable called `Module` and add\n      // properties to it, like `preRun`, `postRun`, etc\n      // We are using that to get notified when the WASM has finished loading.\n      // Only then will we return our promise\n      // If they passed in a moduleConfig object, use that\n      // Otherwise, initialize Module to the empty object\n      var Module = typeof moduleConfig !== 'undefined' ? moduleConfig : {}; // EMCC only allows for a single onAbort function (not an array of functions)\n      // So if the user defined their own onAbort function, we remember it and call it\n\n      var originalOnAbortFunction = Module['onAbort'];\n\n      Module['onAbort'] = function (errorThatCausedAbort) {\n        reject(new Error(errorThatCausedAbort));\n\n        if (originalOnAbortFunction) {\n          originalOnAbortFunction(errorThatCausedAbort);\n        }\n      };\n\n      Module['postRun'] = Module['postRun'] || [];\n      Module['postRun'].push(function () {\n        // When Emscripted calls postRun, this promise resolves with the built Module\n        resolveModule(Module);\n      }); // There is a section of code in the emcc-generated code below that looks like this:\n      // (Note that this is lowercase `module`)\n      // if (typeof module !== 'undefined') {\n      //     module['exports'] = Module;\n      // }\n      // When that runs, it's going to overwrite our own modularization export efforts in shell-post.js!\n      // The only way to tell emcc not to emit it is to pass the MODULARIZE=1 or MODULARIZE_INSTANCE=1 flags,\n      // but that carries with it additional unnecessary baggage/bugs we don't want either.\n      // So, we have three options:\n      // 1) We undefine `module`\n      // 2) We remember what `module['exports']` was at the beginning of this function and we restore it later\n      // 3) We write a script to remove those lines of code as part of the Make process.\n      //\n      // Since those are the only lines of code that care about module, we will undefine it. It's the most straightforward\n      // of the options, and has the side effect of reducing emcc's efforts to modify the module if its output were to change in the future.\n      // That's a nice side effect since we're handling the modularization efforts ourselves\n\n      module = undefined; // The emcc-generated code and shell-post.js code goes below,\n      // meaning that all of it runs inside of this promise. If anything throws an exception, our promise will abort\n\n      var e;\n      e || (e = typeof Module !== 'undefined' ? Module : {});\n      null;\n\n      e.onRuntimeInitialized = function () {\n        function a(h, l) {\n          this.Ra = h;\n          this.db = l;\n          this.Qa = 1;\n          this.lb = [];\n        }\n\n        function b(h, l) {\n          this.db = l;\n          l = aa(h) + 1;\n          this.eb = ba(l);\n          if (null === this.eb) throw Error(\"Unable to allocate memory for the SQL string\");\n          k(h, m, this.eb, l);\n          this.jb = this.eb;\n          this.$a = this.pb = null;\n        }\n\n        function c(h) {\n          this.filename = \"dbfile_\" + (4294967295 * Math.random() >>> 0);\n\n          if (null != h) {\n            var l = this.filename,\n                p = l ? r(\"//\" + l) : \"/\";\n            l = ca(!0, !0);\n            p = da(p, (void 0 !== l ? l : 438) & 4095 | 32768, 0);\n\n            if (h) {\n              if (\"string\" === typeof h) {\n                for (var q = Array(h.length), B = 0, ha = h.length; B < ha; ++B) q[B] = h.charCodeAt(B);\n\n                h = q;\n              }\n\n              ea(p, l | 146);\n              q = u(p, \"w\");\n              fa(q, h, 0, h.length, 0, void 0);\n              ka(q);\n              ea(p, l);\n            }\n          }\n\n          this.handleError(g(this.filename, d));\n          this.db = x(d, \"i32\");\n          nc(this.db);\n          this.fb = {};\n          this.Xa = {};\n        }\n\n        var d = y(4),\n            f = e.cwrap,\n            g = f(\"sqlite3_open\", \"number\", [\"string\", \"number\"]),\n            n = f(\"sqlite3_close_v2\", \"number\", [\"number\"]),\n            t = f(\"sqlite3_exec\", \"number\", [\"number\", \"string\", \"number\", \"number\", \"number\"]),\n            w = f(\"sqlite3_changes\", \"number\", [\"number\"]),\n            v = f(\"sqlite3_prepare_v2\", \"number\", [\"number\", \"string\", \"number\", \"number\", \"number\"]),\n            C = f(\"sqlite3_sql\", \"string\", [\"number\"]),\n            H = f(\"sqlite3_normalized_sql\", \"string\", [\"number\"]),\n            Y = f(\"sqlite3_prepare_v2\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"]),\n            oc = f(\"sqlite3_bind_text\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"]),\n            pb = f(\"sqlite3_bind_blob\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"]),\n            pc = f(\"sqlite3_bind_double\", \"number\", [\"number\", \"number\", \"number\"]),\n            qc = f(\"sqlite3_bind_int\", \"number\", [\"number\", \"number\", \"number\"]),\n            rc = f(\"sqlite3_bind_parameter_index\", \"number\", [\"number\", \"string\"]),\n            sc = f(\"sqlite3_step\", \"number\", [\"number\"]),\n            tc = f(\"sqlite3_errmsg\", \"string\", [\"number\"]),\n            uc = f(\"sqlite3_column_count\", \"number\", [\"number\"]),\n            vc = f(\"sqlite3_data_count\", \"number\", [\"number\"]),\n            wc = f(\"sqlite3_column_double\", \"number\", [\"number\", \"number\"]),\n            xc = f(\"sqlite3_column_text\", \"string\", [\"number\", \"number\"]),\n            yc = f(\"sqlite3_column_blob\", \"number\", [\"number\", \"number\"]),\n            zc = f(\"sqlite3_column_bytes\", \"number\", [\"number\", \"number\"]),\n            Ac = f(\"sqlite3_column_type\", \"number\", [\"number\", \"number\"]),\n            Bc = f(\"sqlite3_column_name\", \"string\", [\"number\", \"number\"]),\n            Cc = f(\"sqlite3_reset\", \"number\", [\"number\"]),\n            Dc = f(\"sqlite3_clear_bindings\", \"number\", [\"number\"]),\n            Ec = f(\"sqlite3_finalize\", \"number\", [\"number\"]),\n            Fc = f(\"sqlite3_create_function_v2\", \"number\", \"number string number number number number number number number\".split(\" \")),\n            Gc = f(\"sqlite3_value_type\", \"number\", [\"number\"]),\n            Hc = f(\"sqlite3_value_bytes\", \"number\", [\"number\"]),\n            Ic = f(\"sqlite3_value_text\", \"string\", [\"number\"]),\n            Jc = f(\"sqlite3_value_blob\", \"number\", [\"number\"]),\n            Kc = f(\"sqlite3_value_double\", \"number\", [\"number\"]),\n            Lc = f(\"sqlite3_result_double\", \"\", [\"number\", \"number\"]),\n            qb = f(\"sqlite3_result_null\", \"\", [\"number\"]),\n            Mc = f(\"sqlite3_result_text\", \"\", [\"number\", \"string\", \"number\", \"number\"]),\n            Nc = f(\"sqlite3_result_blob\", \"\", [\"number\", \"number\", \"number\", \"number\"]),\n            Oc = f(\"sqlite3_result_int\", \"\", [\"number\", \"number\"]),\n            rb = f(\"sqlite3_result_error\", \"\", [\"number\", \"string\", \"number\"]),\n            nc = f(\"RegisterExtensionFunctions\", \"number\", [\"number\"]);\n\n        a.prototype.bind = function (h) {\n          if (!this.Ra) throw \"Statement closed\";\n          this.reset();\n          return Array.isArray(h) ? this.Bb(h) : null != h && \"object\" === typeof h ? this.Cb(h) : !0;\n        };\n\n        a.prototype.step = function () {\n          if (!this.Ra) throw \"Statement closed\";\n          this.Qa = 1;\n          var h = sc(this.Ra);\n\n          switch (h) {\n            case 100:\n              return !0;\n\n            case 101:\n              return !1;\n\n            default:\n              throw this.db.handleError(h);\n          }\n        };\n\n        a.prototype.Ib = function (h) {\n          null == h && (h = this.Qa, this.Qa += 1);\n          return wc(this.Ra, h);\n        };\n\n        a.prototype.Jb = function (h) {\n          null == h && (h = this.Qa, this.Qa += 1);\n          return xc(this.Ra, h);\n        };\n\n        a.prototype.getBlob = function (h) {\n          null == h && (h = this.Qa, this.Qa += 1);\n          var l = zc(this.Ra, h);\n          h = yc(this.Ra, h);\n\n          for (var p = new Uint8Array(l), q = 0; q < l; q += 1) p[q] = z[h + q];\n\n          return p;\n        };\n\n        a.prototype.get = function (h) {\n          null != h && this.bind(h) && this.step();\n          h = [];\n\n          for (var l = vc(this.Ra), p = 0; p < l; p += 1) switch (Ac(this.Ra, p)) {\n            case 1:\n            case 2:\n              h.push(this.Ib(p));\n              break;\n\n            case 3:\n              h.push(this.Jb(p));\n              break;\n\n            case 4:\n              h.push(this.getBlob(p));\n              break;\n\n            default:\n              h.push(null);\n          }\n\n          return h;\n        };\n\n        a.prototype.getColumnNames = function () {\n          for (var h = [], l = uc(this.Ra), p = 0; p < l; p += 1) h.push(Bc(this.Ra, p));\n\n          return h;\n        };\n\n        a.prototype.getAsObject = function (h) {\n          h = this.get(h);\n\n          for (var l = this.getColumnNames(), p = {}, q = 0; q < l.length; q += 1) p[l[q]] = h[q];\n\n          return p;\n        };\n\n        a.prototype.getSQL = function () {\n          return C(this.Ra);\n        };\n\n        a.prototype.getNormalizedSQL = function () {\n          return H(this.Ra);\n        };\n\n        a.prototype.run = function (h) {\n          null != h && this.bind(h);\n          this.step();\n          return this.reset();\n        };\n\n        a.prototype.Fb = function (h, l) {\n          null == l && (l = this.Qa, this.Qa += 1);\n          h = la(h);\n          var p = ma(h);\n          this.lb.push(p);\n          this.db.handleError(oc(this.Ra, l, p, h.length - 1, 0));\n        };\n\n        a.prototype.Ab = function (h, l) {\n          null == l && (l = this.Qa, this.Qa += 1);\n          var p = ma(h);\n          this.lb.push(p);\n          this.db.handleError(pb(this.Ra, l, p, h.length, 0));\n        };\n\n        a.prototype.Eb = function (h, l) {\n          null == l && (l = this.Qa, this.Qa += 1);\n          this.db.handleError((h === (h | 0) ? qc : pc)(this.Ra, l, h));\n        };\n\n        a.prototype.Db = function (h) {\n          null == h && (h = this.Qa, this.Qa += 1);\n          pb(this.Ra, h, 0, 0, 0);\n        };\n\n        a.prototype.tb = function (h, l) {\n          null == l && (l = this.Qa, this.Qa += 1);\n\n          switch (typeof h) {\n            case \"string\":\n              this.Fb(h, l);\n              return;\n\n            case \"number\":\n            case \"boolean\":\n              this.Eb(h + 0, l);\n              return;\n\n            case \"object\":\n              if (null === h) {\n                this.Db(l);\n                return;\n              }\n\n              if (null != h.length) {\n                this.Ab(h, l);\n                return;\n              }\n\n          }\n\n          throw \"Wrong API use : tried to bind a value of an unknown type (\" + h + \").\";\n        };\n\n        a.prototype.Cb = function (h) {\n          var l = this;\n          Object.keys(h).forEach(function (p) {\n            var q = rc(l.Ra, p);\n            0 !== q && l.tb(h[p], q);\n          });\n          return !0;\n        };\n\n        a.prototype.Bb = function (h) {\n          for (var l = 0; l < h.length; l += 1) this.tb(h[l], l + 1);\n\n          return !0;\n        };\n\n        a.prototype.reset = function () {\n          return 0 === Dc(this.Ra) && 0 === Cc(this.Ra);\n        };\n\n        a.prototype.freemem = function () {\n          for (var h; void 0 !== (h = this.lb.pop());) na(h);\n        };\n\n        a.prototype.free = function () {\n          var h = 0 === Ec(this.Ra);\n          delete this.db.fb[this.Ra];\n          this.Ra = 0;\n          return h;\n        };\n\n        b.prototype.next = function () {\n          if (null === this.eb) return {\n            done: !0\n          };\n          null !== this.$a && (this.$a.free(), this.$a = null);\n          if (!this.db.db) throw this.nb(), Error(\"Database closed\");\n          var h = oa(),\n              l = y(4);\n          pa(d);\n          pa(l);\n\n          try {\n            this.db.handleError(Y(this.db.db, this.jb, -1, d, l));\n            this.jb = x(l, \"i32\");\n            var p = x(d, \"i32\");\n            if (0 === p) return this.nb(), {\n              done: !0\n            };\n            this.$a = new a(p, this.db);\n            this.db.fb[p] = this.$a;\n            return {\n              value: this.$a,\n              done: !1\n            };\n          } catch (q) {\n            throw this.pb = A(this.jb), this.nb(), q;\n          } finally {\n            qa(h);\n          }\n        };\n\n        b.prototype.nb = function () {\n          na(this.eb);\n          this.eb = null;\n        };\n\n        b.prototype.getRemainingSQL = function () {\n          return null !== this.pb ? this.pb : A(this.jb);\n        };\n\n        \"function\" === typeof Symbol && \"symbol\" === typeof Symbol.iterator && (b.prototype[Symbol.iterator] = function () {\n          return this;\n        });\n\n        c.prototype.run = function (h, l) {\n          if (!this.db) throw \"Database closed\";\n\n          if (l) {\n            h = this.prepare(h, l);\n\n            try {\n              h.step();\n            } finally {\n              h.free();\n            }\n          } else this.handleError(t(this.db, h, 0, 0, d));\n\n          return this;\n        };\n\n        c.prototype.exec = function (h, l) {\n          if (!this.db) throw \"Database closed\";\n          var p = oa(),\n              q = null;\n\n          try {\n            var B = aa(h) + 1,\n                ha = y(B);\n            k(h, z, ha, B);\n            var D = ha;\n            var ia = y(4);\n\n            for (h = []; 0 !== x(D, \"i8\");) {\n              pa(d);\n              pa(ia);\n              this.handleError(Y(this.db, D, -1, d, ia));\n              var ja = x(d, \"i32\");\n              D = x(ia, \"i32\");\n\n              if (0 !== ja) {\n                B = null;\n                q = new a(ja, this);\n\n                for (null != l && q.bind(l); q.step();) null === B && (B = {\n                  columns: q.getColumnNames(),\n                  values: []\n                }, h.push(B)), B.values.push(q.get());\n\n                q.free();\n              }\n            }\n\n            return h;\n          } catch (E) {\n            throw q && q.free(), E;\n          } finally {\n            qa(p);\n          }\n        };\n\n        c.prototype.each = function (h, l, p, q) {\n          \"function\" === typeof l && (q = p, p = l, l = void 0);\n          h = this.prepare(h, l);\n\n          try {\n            for (; h.step();) p(h.getAsObject());\n          } finally {\n            h.free();\n          }\n\n          if (\"function\" === typeof q) return q();\n        };\n\n        c.prototype.prepare = function (h, l) {\n          pa(d);\n          this.handleError(v(this.db, h, -1, d, 0));\n          h = x(d, \"i32\");\n          if (0 === h) throw \"Nothing to prepare\";\n          var p = new a(h, this);\n          null != l && p.bind(l);\n          return this.fb[h] = p;\n        };\n\n        c.prototype.iterateStatements = function (h) {\n          return new b(h, this);\n        };\n\n        c.prototype[\"export\"] = function () {\n          Object.values(this.fb).forEach(function (l) {\n            l.free();\n          });\n          Object.values(this.Xa).forEach(ra);\n          this.Xa = {};\n          this.handleError(n(this.db));\n          var h = sa(this.filename);\n          this.handleError(g(this.filename, d));\n          this.db = x(d, \"i32\");\n          return h;\n        };\n\n        c.prototype.close = function () {\n          null !== this.db && (Object.values(this.fb).forEach(function (h) {\n            h.free();\n          }), Object.values(this.Xa).forEach(ra), this.Xa = {}, this.handleError(n(this.db)), ta(\"/\" + this.filename), this.db = null);\n        };\n\n        c.prototype.handleError = function (h) {\n          if (0 === h) return null;\n          h = tc(this.db);\n          throw Error(h);\n        };\n\n        c.prototype.getRowsModified = function () {\n          return w(this.db);\n        };\n\n        c.prototype.create_function = function (h, l) {\n          Object.prototype.hasOwnProperty.call(this.Xa, h) && (ua(this.Xa[h]), delete this.Xa[h]);\n          var p = va(function (q, B, ha) {\n            for (var D, ia = [], ja = 0; ja < B; ja += 1) {\n              var E = x(ha + 4 * ja, \"i32\"),\n                  R = Gc(E);\n              if (1 === R || 2 === R) E = Kc(E);else if (3 === R) E = Ic(E);else if (4 === R) {\n                R = E;\n                E = Hc(R);\n                R = Jc(R);\n\n                for (var wb = new Uint8Array(E), Ea = 0; Ea < E; Ea += 1) wb[Ea] = z[R + Ea];\n\n                E = wb;\n              } else E = null;\n              ia.push(E);\n            }\n\n            try {\n              D = l.apply(null, ia);\n            } catch (Rc) {\n              rb(q, Rc, -1);\n              return;\n            }\n\n            switch (typeof D) {\n              case \"boolean\":\n                Oc(q, D ? 1 : 0);\n                break;\n\n              case \"number\":\n                Lc(q, D);\n                break;\n\n              case \"string\":\n                Mc(q, D, -1, -1);\n                break;\n\n              case \"object\":\n                null === D ? qb(q) : null != D.length ? (B = ma(D), Nc(q, B, D.length, -1), na(B)) : rb(q, \"Wrong API use : tried to return a value of an unknown type (\" + D + \").\", -1);\n                break;\n\n              default:\n                qb(q);\n            }\n          });\n          this.Xa[h] = p;\n          this.handleError(Fc(this.db, h, l.length, 1, 0, p, 0, 0, 0));\n          return this;\n        };\n\n        e.Database = c;\n      };\n\n      var wa = {},\n          F;\n\n      for (F in e) e.hasOwnProperty(F) && (wa[F] = e[F]);\n\n      var xa = \"./this.program\",\n          ya = !1,\n          G = !1,\n          za = !1,\n          Aa = !1;\n      ya = \"object\" === typeof window;\n      G = \"function\" === typeof importScripts;\n      za = \"object\" === typeof browser$1 && \"object\" === typeof browser$1.versions && \"string\" === typeof browser$1.versions.node;\n      Aa = !ya && !za && !G;\n      var I = \"\",\n          Ba,\n          Ca,\n          Da,\n          Fa;\n      if (za) I = G ? require$$0.dirname(I) + \"/\" : __dirname + \"/\", Ba = function (a, b) {\n        Da || (Da = require$$2);\n        Fa || (Fa = require$$0);\n        a = Fa.normalize(a);\n        return Da.readFileSync(a, b ? null : \"utf8\");\n      }, Ca = function (a) {\n        a = Ba(a, !0);\n        a.buffer || (a = new Uint8Array(a));\n        assert(a.buffer);\n        return a;\n      }, 1 < browser$1.argv.length && (xa = browser$1.argv[1].replace(/\\\\/g, \"/\")), browser$1.argv.slice(2), \"undefined\" !== 'object' && (module.exports = e), e.inspect = function () {\n        return \"[Emscripten Module object]\";\n      };else if (Aa) \"undefined\" != typeof read && (Ba = function (a) {\n        return read(a);\n      }), Ca = function (a) {\n        if (\"function\" === typeof readbuffer) return new Uint8Array(readbuffer(a));\n        a = read(a, \"binary\");\n        assert(\"object\" === typeof a);\n        return a;\n      }, \"undefined\" !== typeof print && (\"undefined\" === typeof console && (console = {}), console.log = print, console.warn = console.error = \"undefined\" !== typeof printErr ? printErr : print);else if (ya || G) G ? I = self.location.href : document.currentScript && (I = document.currentScript.src), I = 0 !== I.indexOf(\"blob:\") ? I.substr(0, I.lastIndexOf(\"/\") + 1) : \"\", Ba = function (a) {\n        var b = new XMLHttpRequest();\n        b.open(\"GET\", a, !1);\n        b.send(null);\n        return b.responseText;\n      }, G && (Ca = function (a) {\n        var b = new XMLHttpRequest();\n        b.open(\"GET\", a, !1);\n        b.responseType = \"arraybuffer\";\n        b.send(null);\n        return new Uint8Array(b.response);\n      });\n      var Ga = e.print || console.log.bind(console),\n          J = e.printErr || console.warn.bind(console);\n\n      for (F in wa) wa.hasOwnProperty(F) && (e[F] = wa[F]);\n\n      wa = null;\n      e.thisProgram && (xa = e.thisProgram);\n      var Ha = [],\n          Ia;\n\n      function ua(a) {\n        Ia.delete(Ja.get(a));\n        Ha.push(a);\n      }\n\n      function va(a) {\n        var b = Ja;\n\n        if (!Ia) {\n          Ia = new WeakMap();\n\n          for (var c = 0; c < b.length; c++) {\n            var d = b.get(c);\n            d && Ia.set(d, c);\n          }\n        }\n\n        if (Ia.has(a)) a = Ia.get(a);else {\n          if (Ha.length) c = Ha.pop();else {\n            c = b.length;\n\n            try {\n              b.grow(1);\n            } catch (n) {\n              if (!(n instanceof RangeError)) throw n;\n              throw \"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.\";\n            }\n          }\n\n          try {\n            b.set(c, a);\n          } catch (n) {\n            if (!(n instanceof TypeError)) throw n;\n\n            if (\"function\" === typeof WebAssembly.Function) {\n              var f = {\n                i: \"i32\",\n                j: \"i64\",\n                f: \"f32\",\n                d: \"f64\"\n              },\n                  g = {\n                parameters: [],\n                results: []\n              };\n\n              for (d = 1; 4 > d; ++d) g.parameters.push(f[\"viii\"[d]]);\n\n              d = new WebAssembly.Function(g, a);\n            } else {\n              f = [1, 0, 1, 96];\n              g = {\n                i: 127,\n                j: 126,\n                f: 125,\n                d: 124\n              };\n              f.push(3);\n\n              for (d = 0; 3 > d; ++d) f.push(g[\"iii\"[d]]);\n\n              f.push(0);\n              f[1] = f.length - 2;\n              d = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0].concat(f, [2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0]));\n              d = new WebAssembly.Module(d);\n              d = new WebAssembly.Instance(d, {\n                e: {\n                  f: a\n                }\n              }).exports.f;\n            }\n\n            b.set(c, d);\n          }\n\n          Ia.set(a, c);\n          a = c;\n        }\n        return a;\n      }\n\n      function ra(a) {\n        ua(a);\n      }\n\n      var Ka;\n      e.wasmBinary && (Ka = e.wasmBinary);\n      var noExitRuntime;\n      e.noExitRuntime && (noExitRuntime = e.noExitRuntime);\n      \"object\" !== typeof WebAssembly && K(\"no native wasm support detected\");\n\n      function pa(a) {\n        var b = \"i32\";\n        \"*\" === b.charAt(b.length - 1) && (b = \"i32\");\n\n        switch (b) {\n          case \"i1\":\n            z[a >> 0] = 0;\n            break;\n\n          case \"i8\":\n            z[a >> 0] = 0;\n            break;\n\n          case \"i16\":\n            La[a >> 1] = 0;\n            break;\n\n          case \"i32\":\n            L[a >> 2] = 0;\n            break;\n\n          case \"i64\":\n            M = [0, (N = 0, 1 <= +Math.abs(N) ? 0 < N ? (Math.min(+Math.floor(N / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)];\n            L[a >> 2] = M[0];\n            L[a + 4 >> 2] = M[1];\n            break;\n\n          case \"float\":\n            Ma[a >> 2] = 0;\n            break;\n\n          case \"double\":\n            Na[a >> 3] = 0;\n            break;\n\n          default:\n            K(\"invalid type for setValue: \" + b);\n        }\n      }\n\n      function x(a, b) {\n        b = b || \"i8\";\n        \"*\" === b.charAt(b.length - 1) && (b = \"i32\");\n\n        switch (b) {\n          case \"i1\":\n            return z[a >> 0];\n\n          case \"i8\":\n            return z[a >> 0];\n\n          case \"i16\":\n            return La[a >> 1];\n\n          case \"i32\":\n            return L[a >> 2];\n\n          case \"i64\":\n            return L[a >> 2];\n\n          case \"float\":\n            return Ma[a >> 2];\n\n          case \"double\":\n            return Na[a >> 3];\n\n          default:\n            K(\"invalid type for getValue: \" + b);\n        }\n\n        return null;\n      }\n\n      var Oa,\n          Ja,\n          Pa = !1;\n\n      function assert(a, b) {\n        a || K(\"Assertion failed: \" + b);\n      }\n\n      function Qa(a) {\n        var b = e[\"_\" + a];\n        assert(b, \"Cannot call unknown function \" + a + \", make sure it is exported\");\n        return b;\n      }\n\n      function Ra(a, b, c, d) {\n        var f = {\n          string: function (v) {\n            var C = 0;\n\n            if (null !== v && void 0 !== v && 0 !== v) {\n              var H = (v.length << 2) + 1;\n              C = y(H);\n              k(v, m, C, H);\n            }\n\n            return C;\n          },\n          array: function (v) {\n            var C = y(v.length);\n            z.set(v, C);\n            return C;\n          }\n        },\n            g = Qa(a),\n            n = [];\n        a = 0;\n        if (d) for (var t = 0; t < d.length; t++) {\n          var w = f[c[t]];\n          w ? (0 === a && (a = oa()), n[t] = w(d[t])) : n[t] = d[t];\n        }\n        c = g.apply(null, n);\n\n        c = function (v) {\n          return \"string\" === b ? A(v) : \"boolean\" === b ? !!v : v;\n        }(c);\n\n        0 !== a && qa(a);\n        return c;\n      }\n\n      var Sa = 0,\n          Ta = 1;\n\n      function ma(a) {\n        var b = Sa == Ta ? y(a.length) : ba(a.length);\n        a.subarray || a.slice ? m.set(a, b) : m.set(new Uint8Array(a), b);\n        return b;\n      }\n\n      var Ua = \"undefined\" !== typeof TextDecoder ? new TextDecoder(\"utf8\") : void 0;\n\n      function Va(a, b, c) {\n        var d = b + c;\n\n        for (c = b; a[c] && !(c >= d);) ++c;\n\n        if (16 < c - b && a.subarray && Ua) return Ua.decode(a.subarray(b, c));\n\n        for (d = \"\"; b < c;) {\n          var f = a[b++];\n\n          if (f & 128) {\n            var g = a[b++] & 63;\n            if (192 == (f & 224)) d += String.fromCharCode((f & 31) << 6 | g);else {\n              var n = a[b++] & 63;\n              f = 224 == (f & 240) ? (f & 15) << 12 | g << 6 | n : (f & 7) << 18 | g << 12 | n << 6 | a[b++] & 63;\n              65536 > f ? d += String.fromCharCode(f) : (f -= 65536, d += String.fromCharCode(55296 | f >> 10, 56320 | f & 1023));\n            }\n          } else d += String.fromCharCode(f);\n        }\n\n        return d;\n      }\n\n      function A(a, b) {\n        return a ? Va(m, a, b) : \"\";\n      }\n\n      function k(a, b, c, d) {\n        if (!(0 < d)) return 0;\n        var f = c;\n        d = c + d - 1;\n\n        for (var g = 0; g < a.length; ++g) {\n          var n = a.charCodeAt(g);\n\n          if (55296 <= n && 57343 >= n) {\n            var t = a.charCodeAt(++g);\n            n = 65536 + ((n & 1023) << 10) | t & 1023;\n          }\n\n          if (127 >= n) {\n            if (c >= d) break;\n            b[c++] = n;\n          } else {\n            if (2047 >= n) {\n              if (c + 1 >= d) break;\n              b[c++] = 192 | n >> 6;\n            } else {\n              if (65535 >= n) {\n                if (c + 2 >= d) break;\n                b[c++] = 224 | n >> 12;\n              } else {\n                if (c + 3 >= d) break;\n                b[c++] = 240 | n >> 18;\n                b[c++] = 128 | n >> 12 & 63;\n              }\n\n              b[c++] = 128 | n >> 6 & 63;\n            }\n\n            b[c++] = 128 | n & 63;\n          }\n        }\n\n        b[c] = 0;\n        return c - f;\n      }\n\n      function aa(a) {\n        for (var b = 0, c = 0; c < a.length; ++c) {\n          var d = a.charCodeAt(c);\n          55296 <= d && 57343 >= d && (d = 65536 + ((d & 1023) << 10) | a.charCodeAt(++c) & 1023);\n          127 >= d ? ++b : b = 2047 >= d ? b + 2 : 65535 >= d ? b + 3 : b + 4;\n        }\n\n        return b;\n      }\n\n      function Wa(a) {\n        var b = aa(a) + 1,\n            c = ba(b);\n        c && k(a, z, c, b);\n        return c;\n      }\n\n      var Xa, z, m, La, L, Ma, Na;\n\n      function Ya(a) {\n        Xa = a;\n        e.HEAP8 = z = new Int8Array(a);\n        e.HEAP16 = La = new Int16Array(a);\n        e.HEAP32 = L = new Int32Array(a);\n        e.HEAPU8 = m = new Uint8Array(a);\n        e.HEAPU16 = new Uint16Array(a);\n        e.HEAPU32 = new Uint32Array(a);\n        e.HEAPF32 = Ma = new Float32Array(a);\n        e.HEAPF64 = Na = new Float64Array(a);\n      }\n\n      var Za = e.INITIAL_MEMORY || 16777216;\n      e.wasmMemory ? Oa = e.wasmMemory : Oa = new WebAssembly.Memory({\n        initial: Za / 65536,\n        maximum: 32768\n      });\n      Oa && (Xa = Oa.buffer);\n      Za = Xa.byteLength;\n      Ya(Xa);\n      var $a = [],\n          ab = [],\n          bb = [],\n          cb = [];\n\n      function db() {\n        var a = e.preRun.shift();\n        $a.unshift(a);\n      }\n\n      var eb = 0,\n          fb = null,\n          gb = null;\n      e.preloadedImages = {};\n      e.preloadedAudios = {};\n\n      function K(a) {\n        if (e.onAbort) e.onAbort(a);\n        J(a);\n        Pa = !0;\n        throw new WebAssembly.RuntimeError(\"abort(\" + a + \"). Build with -s ASSERTIONS=1 for more info.\");\n      }\n\n      function hb(a) {\n        var b = ib;\n        return String.prototype.startsWith ? b.startsWith(a) : 0 === b.indexOf(a);\n      }\n\n      function jb() {\n        return hb(\"data:application/octet-stream;base64,\");\n      }\n\n      var ib = \"sql-wasm.wasm\";\n\n      if (!jb()) {\n        var kb = ib;\n        ib = e.locateFile ? e.locateFile(kb, I) : I + kb;\n      }\n\n      function lb() {\n        try {\n          if (Ka) return new Uint8Array(Ka);\n          if (Ca) return Ca(ib);\n          throw \"both async and sync fetching of the wasm failed\";\n        } catch (a) {\n          K(a);\n        }\n      }\n\n      function mb() {\n        return Ka || !ya && !G || \"function\" !== typeof fetch || hb(\"file://\") ? Promise.resolve().then(lb) : fetch(ib, {\n          credentials: \"same-origin\"\n        }).then(function (a) {\n          if (!a.ok) throw \"failed to load wasm binary file at '\" + ib + \"'\";\n          return a.arrayBuffer();\n        }).catch(function () {\n          return lb();\n        });\n      }\n\n      var N, M;\n\n      function nb(a) {\n        for (; 0 < a.length;) {\n          var b = a.shift();\n          if (\"function\" == typeof b) b(e);else {\n            var c = b.Hb;\n            \"number\" === typeof c ? void 0 === b.mb ? Ja.get(c)() : Ja.get(c)(b.mb) : c(void 0 === b.mb ? null : b.mb);\n          }\n        }\n      }\n\n      function ob(a) {\n        return a.replace(/\\b_Z[\\w\\d_]+/g, function (b) {\n          return b === b ? b : b + \" [\" + b + \"]\";\n        });\n      }\n\n      function sb() {\n        function a(g) {\n          return (g = g.toTimeString().match(/\\(([A-Za-z ]+)\\)$/)) ? g[1] : \"GMT\";\n        }\n\n        if (!tb) {\n          tb = !0;\n          L[ub() >> 2] = 60 * new Date().getTimezoneOffset();\n          var b = new Date().getFullYear(),\n              c = new Date(b, 0, 1);\n          b = new Date(b, 6, 1);\n          L[vb() >> 2] = Number(c.getTimezoneOffset() != b.getTimezoneOffset());\n          var d = a(c),\n              f = a(b);\n          d = Wa(d);\n          f = Wa(f);\n          b.getTimezoneOffset() < c.getTimezoneOffset() ? (L[xb() >> 2] = d, L[xb() + 4 >> 2] = f) : (L[xb() >> 2] = f, L[xb() + 4 >> 2] = d);\n        }\n      }\n\n      var tb;\n\n      function yb(a, b) {\n        for (var c = 0, d = a.length - 1; 0 <= d; d--) {\n          var f = a[d];\n          \".\" === f ? a.splice(d, 1) : \"..\" === f ? (a.splice(d, 1), c++) : c && (a.splice(d, 1), c--);\n        }\n\n        if (b) for (; c; c--) a.unshift(\"..\");\n        return a;\n      }\n\n      function r(a) {\n        var b = \"/\" === a.charAt(0),\n            c = \"/\" === a.substr(-1);\n        (a = yb(a.split(\"/\").filter(function (d) {\n          return !!d;\n        }), !b).join(\"/\")) || b || (a = \".\");\n        a && c && (a += \"/\");\n        return (b ? \"/\" : \"\") + a;\n      }\n\n      function zb(a) {\n        var b = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/.exec(a).slice(1);\n        a = b[0];\n        b = b[1];\n        if (!a && !b) return \".\";\n        b && (b = b.substr(0, b.length - 1));\n        return a + b;\n      }\n\n      function Ab(a) {\n        if (\"/\" === a) return \"/\";\n        a = r(a);\n        a = a.replace(/\\/$/, \"\");\n        var b = a.lastIndexOf(\"/\");\n        return -1 === b ? a : a.substr(b + 1);\n      }\n\n      function Bb(a) {\n        L[Cb() >> 2] = a;\n      }\n\n      function Db() {\n        if (\"object\" === typeof crypto && \"function\" === typeof crypto.getRandomValues) {\n          var a = new Uint8Array(1);\n          return function () {\n            crypto.getRandomValues(a);\n            return a[0];\n          };\n        }\n\n        if (za) try {\n          var b = require$$2;\n          return function () {\n            return b.randomBytes(1)[0];\n          };\n        } catch (c) {}\n        return function () {\n          K(\"randomDevice\");\n        };\n      }\n\n      function Eb() {\n        for (var a = \"\", b = !1, c = arguments.length - 1; -1 <= c && !b; c--) {\n          b = 0 <= c ? arguments[c] : \"/\";\n          if (\"string\" !== typeof b) throw new TypeError(\"Arguments to path.resolve must be strings\");\n          if (!b) return \"\";\n          a = b + \"/\" + a;\n          b = \"/\" === b.charAt(0);\n        }\n\n        a = yb(a.split(\"/\").filter(function (d) {\n          return !!d;\n        }), !b).join(\"/\");\n        return (b ? \"/\" : \"\") + a || \".\";\n      }\n\n      var Fb = [];\n\n      function Gb(a, b) {\n        Fb[a] = {\n          input: [],\n          output: [],\n          cb: b\n        };\n        Hb(a, Ib);\n      }\n\n      var Ib = {\n        open: function (a) {\n          var b = Fb[a.node.rdev];\n          if (!b) throw new O(43);\n          a.tty = b;\n          a.seekable = !1;\n        },\n        close: function (a) {\n          a.tty.cb.flush(a.tty);\n        },\n        flush: function (a) {\n          a.tty.cb.flush(a.tty);\n        },\n        read: function (a, b, c, d) {\n          if (!a.tty || !a.tty.cb.xb) throw new O(60);\n\n          for (var f = 0, g = 0; g < d; g++) {\n            try {\n              var n = a.tty.cb.xb(a.tty);\n            } catch (t) {\n              throw new O(29);\n            }\n\n            if (void 0 === n && 0 === f) throw new O(6);\n            if (null === n || void 0 === n) break;\n            f++;\n            b[c + g] = n;\n          }\n\n          f && (a.node.timestamp = Date.now());\n          return f;\n        },\n        write: function (a, b, c, d) {\n          if (!a.tty || !a.tty.cb.qb) throw new O(60);\n\n          try {\n            for (var f = 0; f < d; f++) a.tty.cb.qb(a.tty, b[c + f]);\n          } catch (g) {\n            throw new O(29);\n          }\n\n          d && (a.node.timestamp = Date.now());\n          return f;\n        }\n      },\n          Jb = {\n        xb: function (a) {\n          if (!a.input.length) {\n            var b = null;\n\n            if (za) {\n              var c = Buffer.zb ? Buffer.zb(256) : new Buffer(256),\n                  d = 0;\n\n              try {\n                d = Da.readSync(browser$1.stdin.fd, c, 0, 256, null);\n              } catch (f) {\n                if (-1 != f.toString().indexOf(\"EOF\")) d = 0;else throw f;\n              }\n\n              0 < d ? b = c.slice(0, d).toString(\"utf-8\") : b = null;\n            } else \"undefined\" != typeof window && \"function\" == typeof window.prompt ? (b = window.prompt(\"Input: \"), null !== b && (b += \"\\n\")) : \"function\" == typeof readline && (b = readline(), null !== b && (b += \"\\n\"));\n\n            if (!b) return null;\n            a.input = la(b, !0);\n          }\n\n          return a.input.shift();\n        },\n        qb: function (a, b) {\n          null === b || 10 === b ? (Ga(Va(a.output, 0)), a.output = []) : 0 != b && a.output.push(b);\n        },\n        flush: function (a) {\n          a.output && 0 < a.output.length && (Ga(Va(a.output, 0)), a.output = []);\n        }\n      },\n          Kb = {\n        qb: function (a, b) {\n          null === b || 10 === b ? (J(Va(a.output, 0)), a.output = []) : 0 != b && a.output.push(b);\n        },\n        flush: function (a) {\n          a.output && 0 < a.output.length && (J(Va(a.output, 0)), a.output = []);\n        }\n      },\n          P = {\n        Va: null,\n        Wa: function () {\n          return P.createNode(null, \"/\", 16895, 0);\n        },\n        createNode: function (a, b, c, d) {\n          if (24576 === (c & 61440) || 4096 === (c & 61440)) throw new O(63);\n          P.Va || (P.Va = {\n            dir: {\n              node: {\n                Ua: P.Na.Ua,\n                Ta: P.Na.Ta,\n                lookup: P.Na.lookup,\n                gb: P.Na.gb,\n                rename: P.Na.rename,\n                unlink: P.Na.unlink,\n                rmdir: P.Na.rmdir,\n                readdir: P.Na.readdir,\n                symlink: P.Na.symlink\n              },\n              stream: {\n                Za: P.Oa.Za\n              }\n            },\n            file: {\n              node: {\n                Ua: P.Na.Ua,\n                Ta: P.Na.Ta\n              },\n              stream: {\n                Za: P.Oa.Za,\n                read: P.Oa.read,\n                write: P.Oa.write,\n                sb: P.Oa.sb,\n                hb: P.Oa.hb,\n                ib: P.Oa.ib\n              }\n            },\n            link: {\n              node: {\n                Ua: P.Na.Ua,\n                Ta: P.Na.Ta,\n                readlink: P.Na.readlink\n              },\n              stream: {}\n            },\n            ub: {\n              node: {\n                Ua: P.Na.Ua,\n                Ta: P.Na.Ta\n              },\n              stream: Lb\n            }\n          });\n          c = Mb(a, b, c, d);\n          Q(c.mode) ? (c.Na = P.Va.dir.node, c.Oa = P.Va.dir.stream, c.Ma = {}) : 32768 === (c.mode & 61440) ? (c.Na = P.Va.file.node, c.Oa = P.Va.file.stream, c.Sa = 0, c.Ma = null) : 40960 === (c.mode & 61440) ? (c.Na = P.Va.link.node, c.Oa = P.Va.link.stream) : 8192 === (c.mode & 61440) && (c.Na = P.Va.ub.node, c.Oa = P.Va.ub.stream);\n          c.timestamp = Date.now();\n          a && (a.Ma[b] = c);\n          return c;\n        },\n        Sb: function (a) {\n          if (a.Ma && a.Ma.subarray) {\n            for (var b = [], c = 0; c < a.Sa; ++c) b.push(a.Ma[c]);\n\n            return b;\n          }\n\n          return a.Ma;\n        },\n        Tb: function (a) {\n          return a.Ma ? a.Ma.subarray ? a.Ma.subarray(0, a.Sa) : new Uint8Array(a.Ma) : new Uint8Array(0);\n        },\n        vb: function (a, b) {\n          var c = a.Ma ? a.Ma.length : 0;\n          c >= b || (b = Math.max(b, c * (1048576 > c ? 2 : 1.125) >>> 0), 0 != c && (b = Math.max(b, 256)), c = a.Ma, a.Ma = new Uint8Array(b), 0 < a.Sa && a.Ma.set(c.subarray(0, a.Sa), 0));\n        },\n        Pb: function (a, b) {\n          if (a.Sa != b) if (0 == b) a.Ma = null, a.Sa = 0;else {\n            if (!a.Ma || a.Ma.subarray) {\n              var c = a.Ma;\n              a.Ma = new Uint8Array(b);\n              c && a.Ma.set(c.subarray(0, Math.min(b, a.Sa)));\n            } else if (a.Ma || (a.Ma = []), a.Ma.length > b) a.Ma.length = b;else for (; a.Ma.length < b;) a.Ma.push(0);\n\n            a.Sa = b;\n          }\n        },\n        Na: {\n          Ua: function (a) {\n            var b = {};\n            b.dev = 8192 === (a.mode & 61440) ? a.id : 1;\n            b.ino = a.id;\n            b.mode = a.mode;\n            b.nlink = 1;\n            b.uid = 0;\n            b.gid = 0;\n            b.rdev = a.rdev;\n            Q(a.mode) ? b.size = 4096 : 32768 === (a.mode & 61440) ? b.size = a.Sa : 40960 === (a.mode & 61440) ? b.size = a.link.length : b.size = 0;\n            b.atime = new Date(a.timestamp);\n            b.mtime = new Date(a.timestamp);\n            b.ctime = new Date(a.timestamp);\n            b.Gb = 4096;\n            b.blocks = Math.ceil(b.size / b.Gb);\n            return b;\n          },\n          Ta: function (a, b) {\n            void 0 !== b.mode && (a.mode = b.mode);\n            void 0 !== b.timestamp && (a.timestamp = b.timestamp);\n            void 0 !== b.size && P.Pb(a, b.size);\n          },\n          lookup: function () {\n            throw Nb[44];\n          },\n          gb: function (a, b, c, d) {\n            return P.createNode(a, b, c, d);\n          },\n          rename: function (a, b, c) {\n            if (Q(a.mode)) {\n              try {\n                var d = Ob(b, c);\n              } catch (g) {}\n\n              if (d) for (var f in d.Ma) throw new O(55);\n            }\n\n            delete a.parent.Ma[a.name];\n            a.name = c;\n            b.Ma[c] = a;\n            a.parent = b;\n          },\n          unlink: function (a, b) {\n            delete a.Ma[b];\n          },\n          rmdir: function (a, b) {\n            var c = Ob(a, b),\n                d;\n\n            for (d in c.Ma) throw new O(55);\n\n            delete a.Ma[b];\n          },\n          readdir: function (a) {\n            var b = [\".\", \"..\"],\n                c;\n\n            for (c in a.Ma) a.Ma.hasOwnProperty(c) && b.push(c);\n\n            return b;\n          },\n          symlink: function (a, b, c) {\n            a = P.createNode(a, b, 41471, 0);\n            a.link = c;\n            return a;\n          },\n          readlink: function (a) {\n            if (40960 !== (a.mode & 61440)) throw new O(28);\n            return a.link;\n          }\n        },\n        Oa: {\n          read: function (a, b, c, d, f) {\n            var g = a.node.Ma;\n            if (f >= a.node.Sa) return 0;\n            a = Math.min(a.node.Sa - f, d);\n            if (8 < a && g.subarray) b.set(g.subarray(f, f + a), c);else for (d = 0; d < a; d++) b[c + d] = g[f + d];\n            return a;\n          },\n          write: function (a, b, c, d, f, g) {\n            b.buffer === z.buffer && (g = !1);\n            if (!d) return 0;\n            a = a.node;\n            a.timestamp = Date.now();\n\n            if (b.subarray && (!a.Ma || a.Ma.subarray)) {\n              if (g) return a.Ma = b.subarray(c, c + d), a.Sa = d;\n              if (0 === a.Sa && 0 === f) return a.Ma = b.slice(c, c + d), a.Sa = d;\n              if (f + d <= a.Sa) return a.Ma.set(b.subarray(c, c + d), f), d;\n            }\n\n            P.vb(a, f + d);\n            if (a.Ma.subarray && b.subarray) a.Ma.set(b.subarray(c, c + d), f);else for (g = 0; g < d; g++) a.Ma[f + g] = b[c + g];\n            a.Sa = Math.max(a.Sa, f + d);\n            return d;\n          },\n          Za: function (a, b, c) {\n            1 === c ? b += a.position : 2 === c && 32768 === (a.node.mode & 61440) && (b += a.node.Sa);\n            if (0 > b) throw new O(28);\n            return b;\n          },\n          sb: function (a, b, c) {\n            P.vb(a.node, b + c);\n            a.node.Sa = Math.max(a.node.Sa, b + c);\n          },\n          hb: function (a, b, c, d, f, g) {\n            assert(0 === b);\n            if (32768 !== (a.node.mode & 61440)) throw new O(43);\n            a = a.node.Ma;\n\n            if (g & 2 || a.buffer !== Xa) {\n              if (0 < d || d + c < a.length) a.subarray ? a = a.subarray(d, d + c) : a = Array.prototype.slice.call(a, d, d + c);\n              d = !0;\n              g = 16384 * Math.ceil(c / 16384);\n\n              for (b = ba(g); c < g;) z[b + c++] = 0;\n\n              c = b;\n              if (!c) throw new O(48);\n              z.set(a, c);\n            } else d = !1, c = a.byteOffset;\n\n            return {\n              Ob: c,\n              kb: d\n            };\n          },\n          ib: function (a, b, c, d, f) {\n            if (32768 !== (a.node.mode & 61440)) throw new O(43);\n            if (f & 2) return 0;\n            P.Oa.write(a, b, 0, d, c, !1);\n            return 0;\n          }\n        }\n      },\n          Pb = null,\n          Qb = {},\n          S = [],\n          Rb = 1,\n          T = null,\n          Sb = !0,\n          U = {},\n          O = null,\n          Nb = {};\n\n      function V(a, b) {\n        a = Eb(\"/\", a);\n        b = b || {};\n        if (!a) return {\n          path: \"\",\n          node: null\n        };\n        var c = {\n          wb: !0,\n          rb: 0\n        },\n            d;\n\n        for (d in c) void 0 === b[d] && (b[d] = c[d]);\n\n        if (8 < b.rb) throw new O(32);\n        a = yb(a.split(\"/\").filter(function (n) {\n          return !!n;\n        }), !1);\n        var f = Pb;\n        c = \"/\";\n\n        for (d = 0; d < a.length; d++) {\n          var g = d === a.length - 1;\n          if (g && b.parent) break;\n          f = Ob(f, a[d]);\n          c = r(c + \"/\" + a[d]);\n          f.ab && (!g || g && b.wb) && (f = f.ab.root);\n          if (!g || b.Ya) for (g = 0; 40960 === (f.mode & 61440);) if (f = Tb(c), c = Eb(zb(c), f), f = V(c, {\n            rb: b.rb\n          }).node, 40 < g++) throw new O(32);\n        }\n\n        return {\n          path: c,\n          node: f\n        };\n      }\n\n      function Ub(a) {\n        for (var b;;) {\n          if (a === a.parent) return a = a.Wa.yb, b ? \"/\" !== a[a.length - 1] ? a + \"/\" + b : a + b : a;\n          b = b ? a.name + \"/\" + b : a.name;\n          a = a.parent;\n        }\n      }\n\n      function Vb(a, b) {\n        for (var c = 0, d = 0; d < b.length; d++) c = (c << 5) - c + b.charCodeAt(d) | 0;\n\n        return (a + c >>> 0) % T.length;\n      }\n\n      function Wb(a) {\n        var b = Vb(a.parent.id, a.name);\n        if (T[b] === a) T[b] = a.bb;else for (b = T[b]; b;) {\n          if (b.bb === a) {\n            b.bb = a.bb;\n            break;\n          }\n\n          b = b.bb;\n        }\n      }\n\n      function Ob(a, b) {\n        var c;\n        if (c = (c = Xb(a, \"x\")) ? c : a.Na.lookup ? 0 : 2) throw new O(c, a);\n\n        for (c = T[Vb(a.id, b)]; c; c = c.bb) {\n          var d = c.name;\n          if (c.parent.id === a.id && d === b) return c;\n        }\n\n        return a.Na.lookup(a, b);\n      }\n\n      function Mb(a, b, c, d) {\n        a = new Yb(a, b, c, d);\n        b = Vb(a.parent.id, a.name);\n        a.bb = T[b];\n        return T[b] = a;\n      }\n\n      function Q(a) {\n        return 16384 === (a & 61440);\n      }\n\n      var Zb = {\n        r: 0,\n        rs: 1052672,\n        \"r+\": 2,\n        w: 577,\n        wx: 705,\n        xw: 705,\n        \"w+\": 578,\n        \"wx+\": 706,\n        \"xw+\": 706,\n        a: 1089,\n        ax: 1217,\n        xa: 1217,\n        \"a+\": 1090,\n        \"ax+\": 1218,\n        \"xa+\": 1218\n      };\n\n      function $b(a) {\n        var b = [\"r\", \"w\", \"rw\"][a & 3];\n        a & 512 && (b += \"w\");\n        return b;\n      }\n\n      function Xb(a, b) {\n        if (Sb) return 0;\n\n        if (-1 === b.indexOf(\"r\") || a.mode & 292) {\n          if (-1 !== b.indexOf(\"w\") && !(a.mode & 146) || -1 !== b.indexOf(\"x\") && !(a.mode & 73)) return 2;\n        } else return 2;\n\n        return 0;\n      }\n\n      function ac(a, b) {\n        try {\n          return Ob(a, b), 20;\n        } catch (c) {}\n\n        return Xb(a, \"wx\");\n      }\n\n      function bc(a, b, c) {\n        try {\n          var d = Ob(a, b);\n        } catch (f) {\n          return f.Pa;\n        }\n\n        if (a = Xb(a, \"wx\")) return a;\n\n        if (c) {\n          if (!Q(d.mode)) return 54;\n          if (d === d.parent || \"/\" === Ub(d)) return 10;\n        } else if (Q(d.mode)) return 31;\n\n        return 0;\n      }\n\n      function cc(a) {\n        var b = 4096;\n\n        for (a = a || 0; a <= b; a++) if (!S[a]) return a;\n\n        throw new O(33);\n      }\n\n      function dc(a, b) {\n        ec || (ec = function () {}, ec.prototype = {});\n        var c = new ec(),\n            d;\n\n        for (d in a) c[d] = a[d];\n\n        a = c;\n        b = cc(b);\n        a.fd = b;\n        return S[b] = a;\n      }\n\n      var Lb = {\n        open: function (a) {\n          a.Oa = Qb[a.node.rdev].Oa;\n          a.Oa.open && a.Oa.open(a);\n        },\n        Za: function () {\n          throw new O(70);\n        }\n      };\n\n      function Hb(a, b) {\n        Qb[a] = {\n          Oa: b\n        };\n      }\n\n      function fc(a, b) {\n        var c = \"/\" === b,\n            d = !b;\n        if (c && Pb) throw new O(10);\n\n        if (!c && !d) {\n          var f = V(b, {\n            wb: !1\n          });\n          b = f.path;\n          f = f.node;\n          if (f.ab) throw new O(10);\n          if (!Q(f.mode)) throw new O(54);\n        }\n\n        b = {\n          type: a,\n          Ub: {},\n          yb: b,\n          Mb: []\n        };\n        a = a.Wa(b);\n        a.Wa = b;\n        b.root = a;\n        c ? Pb = a : f && (f.ab = b, f.Wa && f.Wa.Mb.push(b));\n      }\n\n      function da(a, b, c) {\n        var d = V(a, {\n          parent: !0\n        }).node;\n        a = Ab(a);\n        if (!a || \".\" === a || \"..\" === a) throw new O(28);\n        var f = ac(d, a);\n        if (f) throw new O(f);\n        if (!d.Na.gb) throw new O(63);\n        return d.Na.gb(d, a, b, c);\n      }\n\n      function W(a, b) {\n        da(a, (void 0 !== b ? b : 511) & 1023 | 16384, 0);\n      }\n\n      function hc(a, b, c) {\n        \"undefined\" === typeof c && (c = b, b = 438);\n        da(a, b | 8192, c);\n      }\n\n      function ic(a, b) {\n        if (!Eb(a)) throw new O(44);\n        var c = V(b, {\n          parent: !0\n        }).node;\n        if (!c) throw new O(44);\n        b = Ab(b);\n        var d = ac(c, b);\n        if (d) throw new O(d);\n        if (!c.Na.symlink) throw new O(63);\n        c.Na.symlink(c, b, a);\n      }\n\n      function ta(a) {\n        var b = V(a, {\n          parent: !0\n        }).node,\n            c = Ab(a),\n            d = Ob(b, c),\n            f = bc(b, c, !1);\n        if (f) throw new O(f);\n        if (!b.Na.unlink) throw new O(63);\n        if (d.ab) throw new O(10);\n\n        try {\n          U.willDeletePath && U.willDeletePath(a);\n        } catch (g) {\n          J(\"FS.trackingDelegate['willDeletePath']('\" + a + \"') threw an exception: \" + g.message);\n        }\n\n        b.Na.unlink(b, c);\n        Wb(d);\n\n        try {\n          if (U.onDeletePath) U.onDeletePath(a);\n        } catch (g) {\n          J(\"FS.trackingDelegate['onDeletePath']('\" + a + \"') threw an exception: \" + g.message);\n        }\n      }\n\n      function Tb(a) {\n        a = V(a).node;\n        if (!a) throw new O(44);\n        if (!a.Na.readlink) throw new O(28);\n        return Eb(Ub(a.parent), a.Na.readlink(a));\n      }\n\n      function jc(a, b) {\n        a = V(a, {\n          Ya: !b\n        }).node;\n        if (!a) throw new O(44);\n        if (!a.Na.Ua) throw new O(63);\n        return a.Na.Ua(a);\n      }\n\n      function kc(a) {\n        return jc(a, !0);\n      }\n\n      function ea(a, b) {\n        var c;\n        \"string\" === typeof a ? c = V(a, {\n          Ya: !0\n        }).node : c = a;\n        if (!c.Na.Ta) throw new O(63);\n        c.Na.Ta(c, {\n          mode: b & 4095 | c.mode & -4096,\n          timestamp: Date.now()\n        });\n      }\n\n      function lc(a) {\n        var b;\n        \"string\" === typeof a ? b = V(a, {\n          Ya: !0\n        }).node : b = a;\n        if (!b.Na.Ta) throw new O(63);\n        b.Na.Ta(b, {\n          timestamp: Date.now()\n        });\n      }\n\n      function mc(a, b) {\n        if (0 > b) throw new O(28);\n        var c;\n        \"string\" === typeof a ? c = V(a, {\n          Ya: !0\n        }).node : c = a;\n        if (!c.Na.Ta) throw new O(63);\n        if (Q(c.mode)) throw new O(31);\n        if (32768 !== (c.mode & 61440)) throw new O(28);\n        if (a = Xb(c, \"w\")) throw new O(a);\n        c.Na.Ta(c, {\n          size: b,\n          timestamp: Date.now()\n        });\n      }\n\n      function u(a, b, c, d) {\n        if (\"\" === a) throw new O(44);\n\n        if (\"string\" === typeof b) {\n          var f = Zb[b];\n          if (\"undefined\" === typeof f) throw Error(\"Unknown file open mode: \" + b);\n          b = f;\n        }\n\n        c = b & 64 ? (\"undefined\" === typeof c ? 438 : c) & 4095 | 32768 : 0;\n        if (\"object\" === typeof a) var g = a;else {\n          a = r(a);\n\n          try {\n            g = V(a, {\n              Ya: !(b & 131072)\n            }).node;\n          } catch (n) {}\n        }\n        f = !1;\n        if (b & 64) if (g) {\n          if (b & 128) throw new O(20);\n        } else g = da(a, c, 0), f = !0;\n        if (!g) throw new O(44);\n        8192 === (g.mode & 61440) && (b &= -513);\n        if (b & 65536 && !Q(g.mode)) throw new O(54);\n        if (!f && (c = g ? 40960 === (g.mode & 61440) ? 32 : Q(g.mode) && (\"r\" !== $b(b) || b & 512) ? 31 : Xb(g, $b(b)) : 44)) throw new O(c);\n        b & 512 && mc(g, 0);\n        b &= -131713;\n        d = dc({\n          node: g,\n          path: Ub(g),\n          flags: b,\n          seekable: !0,\n          position: 0,\n          Oa: g.Oa,\n          Rb: [],\n          error: !1\n        }, d);\n        d.Oa.open && d.Oa.open(d);\n        !e.logReadFiles || b & 1 || (Pc || (Pc = {}), a in Pc || (Pc[a] = 1, J(\"FS.trackingDelegate error on read file: \" + a)));\n\n        try {\n          U.onOpenFile && (g = 0, 1 !== (b & 2097155) && (g |= 1), 0 !== (b & 2097155) && (g |= 2), U.onOpenFile(a, g));\n        } catch (n) {\n          J(\"FS.trackingDelegate['onOpenFile']('\" + a + \"', flags) threw an exception: \" + n.message);\n        }\n\n        return d;\n      }\n\n      function ka(a) {\n        if (null === a.fd) throw new O(8);\n        a.ob && (a.ob = null);\n\n        try {\n          a.Oa.close && a.Oa.close(a);\n        } catch (b) {\n          throw b;\n        } finally {\n          S[a.fd] = null;\n        }\n\n        a.fd = null;\n      }\n\n      function Qc(a, b, c) {\n        if (null === a.fd) throw new O(8);\n        if (!a.seekable || !a.Oa.Za) throw new O(70);\n        if (0 != c && 1 != c && 2 != c) throw new O(28);\n        a.position = a.Oa.Za(a, b, c);\n        a.Rb = [];\n      }\n\n      function Sc(a, b, c, d, f) {\n        if (0 > d || 0 > f) throw new O(28);\n        if (null === a.fd) throw new O(8);\n        if (1 === (a.flags & 2097155)) throw new O(8);\n        if (Q(a.node.mode)) throw new O(31);\n        if (!a.Oa.read) throw new O(28);\n        var g = \"undefined\" !== typeof f;\n        if (!g) f = a.position;else if (!a.seekable) throw new O(70);\n        b = a.Oa.read(a, b, c, d, f);\n        g || (a.position += b);\n        return b;\n      }\n\n      function fa(a, b, c, d, f, g) {\n        if (0 > d || 0 > f) throw new O(28);\n        if (null === a.fd) throw new O(8);\n        if (0 === (a.flags & 2097155)) throw new O(8);\n        if (Q(a.node.mode)) throw new O(31);\n        if (!a.Oa.write) throw new O(28);\n        a.seekable && a.flags & 1024 && Qc(a, 0, 2);\n        var n = \"undefined\" !== typeof f;\n        if (!n) f = a.position;else if (!a.seekable) throw new O(70);\n        b = a.Oa.write(a, b, c, d, f, g);\n        n || (a.position += b);\n\n        try {\n          if (a.path && U.onWriteToFile) U.onWriteToFile(a.path);\n        } catch (t) {\n          J(\"FS.trackingDelegate['onWriteToFile']('\" + a.path + \"') threw an exception: \" + t.message);\n        }\n\n        return b;\n      }\n\n      function sa(a) {\n        var b = {\n          encoding: \"binary\"\n        };\n        b = b || {};\n        b.flags = b.flags || \"r\";\n        b.encoding = b.encoding || \"binary\";\n        if (\"utf8\" !== b.encoding && \"binary\" !== b.encoding) throw Error('Invalid encoding type \"' + b.encoding + '\"');\n        var c,\n            d = u(a, b.flags);\n        a = jc(a).size;\n        var f = new Uint8Array(a);\n        Sc(d, f, 0, a, 0);\n        \"utf8\" === b.encoding ? c = Va(f, 0) : \"binary\" === b.encoding && (c = f);\n        ka(d);\n        return c;\n      }\n\n      function Tc() {\n        O || (O = function (a, b) {\n          this.node = b;\n\n          this.Qb = function (c) {\n            this.Pa = c;\n          };\n\n          this.Qb(a);\n          this.message = \"FS error\";\n        }, O.prototype = Error(), O.prototype.constructor = O, [44].forEach(function (a) {\n          Nb[a] = new O(a);\n          Nb[a].stack = \"<generic error, no stack>\";\n        }));\n      }\n\n      var Uc;\n\n      function ca(a, b) {\n        var c = 0;\n        a && (c |= 365);\n        b && (c |= 146);\n        return c;\n      }\n\n      function Vc(a, b, c) {\n        a = r(\"/dev/\" + a);\n        var d = ca(!!b, !!c);\n        Wc || (Wc = 64);\n        var f = Wc++ << 8 | 0;\n        Hb(f, {\n          open: function (g) {\n            g.seekable = !1;\n          },\n          close: function () {\n            c && c.buffer && c.buffer.length && c(10);\n          },\n          read: function (g, n, t, w) {\n            for (var v = 0, C = 0; C < w; C++) {\n              try {\n                var H = b();\n              } catch (Y) {\n                throw new O(29);\n              }\n\n              if (void 0 === H && 0 === v) throw new O(6);\n              if (null === H || void 0 === H) break;\n              v++;\n              n[t + C] = H;\n            }\n\n            v && (g.node.timestamp = Date.now());\n            return v;\n          },\n          write: function (g, n, t, w) {\n            for (var v = 0; v < w; v++) try {\n              c(n[t + v]);\n            } catch (C) {\n              throw new O(29);\n            }\n\n            w && (g.node.timestamp = Date.now());\n            return v;\n          }\n        });\n        hc(a, d, f);\n      }\n\n      var Wc,\n          X = {},\n          ec,\n          Pc,\n          Xc = {};\n\n      function Yc(a, b, c) {\n        try {\n          var d = a(b);\n        } catch (f) {\n          if (f && f.node && r(b) !== r(Ub(f.node))) return -54;\n          throw f;\n        }\n\n        L[c >> 2] = d.dev;\n        L[c + 4 >> 2] = 0;\n        L[c + 8 >> 2] = d.ino;\n        L[c + 12 >> 2] = d.mode;\n        L[c + 16 >> 2] = d.nlink;\n        L[c + 20 >> 2] = d.uid;\n        L[c + 24 >> 2] = d.gid;\n        L[c + 28 >> 2] = d.rdev;\n        L[c + 32 >> 2] = 0;\n        M = [d.size >>> 0, (N = d.size, 1 <= +Math.abs(N) ? 0 < N ? (Math.min(+Math.floor(N / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)];\n        L[c + 40 >> 2] = M[0];\n        L[c + 44 >> 2] = M[1];\n        L[c + 48 >> 2] = 4096;\n        L[c + 52 >> 2] = d.blocks;\n        L[c + 56 >> 2] = d.atime.getTime() / 1E3 | 0;\n        L[c + 60 >> 2] = 0;\n        L[c + 64 >> 2] = d.mtime.getTime() / 1E3 | 0;\n        L[c + 68 >> 2] = 0;\n        L[c + 72 >> 2] = d.ctime.getTime() / 1E3 | 0;\n        L[c + 76 >> 2] = 0;\n        M = [d.ino >>> 0, (N = d.ino, 1 <= +Math.abs(N) ? 0 < N ? (Math.min(+Math.floor(N / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)];\n        L[c + 80 >> 2] = M[0];\n        L[c + 84 >> 2] = M[1];\n        return 0;\n      }\n\n      var Zc = void 0;\n\n      function $c() {\n        Zc += 4;\n        return L[Zc - 4 >> 2];\n      }\n\n      function Z(a) {\n        a = S[a];\n        if (!a) throw new O(8);\n        return a;\n      }\n\n      var ad = {};\n\n      function bd() {\n        if (!cd) {\n          var a = {\n            USER: \"web_user\",\n            LOGNAME: \"web_user\",\n            PATH: \"/\",\n            PWD: \"/\",\n            HOME: \"/home/web_user\",\n            LANG: (\"object\" === typeof navigator && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n            _: xa || \"./this.program\"\n          },\n              b;\n\n          for (b in ad) a[b] = ad[b];\n\n          var c = [];\n\n          for (b in a) c.push(b + \"=\" + a[b]);\n\n          cd = c;\n        }\n\n        return cd;\n      }\n\n      var cd, dd;\n      za ? dd = function () {\n        var a = browser$1.hrtime();\n        return 1E3 * a[0] + a[1] / 1E6;\n      } : \"undefined\" !== typeof dateNow ? dd = dateNow : dd = function () {\n        return performance.now();\n      };\n\n      function ed(a) {\n        for (var b = dd(); dd() - b < a / 1E3;);\n      }\n\n      e._usleep = ed;\n\n      function Yb(a, b, c, d) {\n        a || (a = this);\n        this.parent = a;\n        this.Wa = a.Wa;\n        this.ab = null;\n        this.id = Rb++;\n        this.name = b;\n        this.mode = c;\n        this.Na = {};\n        this.Oa = {};\n        this.rdev = d;\n      }\n\n      Object.defineProperties(Yb.prototype, {\n        read: {\n          get: function () {\n            return 365 === (this.mode & 365);\n          },\n          set: function (a) {\n            a ? this.mode |= 365 : this.mode &= -366;\n          }\n        },\n        write: {\n          get: function () {\n            return 146 === (this.mode & 146);\n          },\n          set: function (a) {\n            a ? this.mode |= 146 : this.mode &= -147;\n          }\n        }\n      });\n      Tc();\n      T = Array(4096);\n      fc(P, \"/\");\n      W(\"/tmp\");\n      W(\"/home\");\n      W(\"/home/web_user\");\n\n      (function () {\n        W(\"/dev\");\n        Hb(259, {\n          read: function () {\n            return 0;\n          },\n          write: function (b, c, d, f) {\n            return f;\n          }\n        });\n        hc(\"/dev/null\", 259);\n        Gb(1280, Jb);\n        Gb(1536, Kb);\n        hc(\"/dev/tty\", 1280);\n        hc(\"/dev/tty1\", 1536);\n        var a = Db();\n        Vc(\"random\", a);\n        Vc(\"urandom\", a);\n        W(\"/dev/shm\");\n        W(\"/dev/shm/tmp\");\n      })();\n\n      W(\"/proc\");\n      W(\"/proc/self\");\n      W(\"/proc/self/fd\");\n      fc({\n        Wa: function () {\n          var a = Mb(\"/proc/self\", \"fd\", 16895, 73);\n          a.Na = {\n            lookup: function (b, c) {\n              var d = S[+c];\n              if (!d) throw new O(8);\n              b = {\n                parent: null,\n                Wa: {\n                  yb: \"fake\"\n                },\n                Na: {\n                  readlink: function () {\n                    return d.path;\n                  }\n                }\n              };\n              return b.parent = b;\n            }\n          };\n          return a;\n        }\n      }, \"/proc/self/fd\");\n\n      function la(a, b) {\n        var c = Array(aa(a) + 1);\n        a = k(a, c, 0, c.length);\n        b && (c.length = a);\n        return c;\n      }\n\n      ab.push({\n        Hb: function () {\n          fd();\n        }\n      });\n      var id = {\n        b: function (a, b, c, d) {\n          K(\"Assertion failed: \" + A(a) + \", at: \" + [b ? A(b) : \"unknown filename\", c, d ? A(d) : \"unknown function\"]);\n        },\n        q: function (a, b) {\n          sb();\n          a = new Date(1E3 * L[a >> 2]);\n          L[b >> 2] = a.getSeconds();\n          L[b + 4 >> 2] = a.getMinutes();\n          L[b + 8 >> 2] = a.getHours();\n          L[b + 12 >> 2] = a.getDate();\n          L[b + 16 >> 2] = a.getMonth();\n          L[b + 20 >> 2] = a.getFullYear() - 1900;\n          L[b + 24 >> 2] = a.getDay();\n          var c = new Date(a.getFullYear(), 0, 1);\n          L[b + 28 >> 2] = (a.getTime() - c.getTime()) / 864E5 | 0;\n          L[b + 36 >> 2] = -(60 * a.getTimezoneOffset());\n          var d = new Date(a.getFullYear(), 6, 1).getTimezoneOffset();\n          c = c.getTimezoneOffset();\n          a = (d != c && a.getTimezoneOffset() == Math.min(c, d)) | 0;\n          L[b + 32 >> 2] = a;\n          a = L[xb() + (a ? 4 : 0) >> 2];\n          L[b + 40 >> 2] = a;\n          return b;\n        },\n        z: function (a, b) {\n          try {\n            a = A(a);\n            if (b & -8) var c = -28;else {\n              var d;\n              (d = V(a, {\n                Ya: !0\n              }).node) ? (a = \"\", b & 4 && (a += \"r\"), b & 2 && (a += \"w\"), b & 1 && (a += \"x\"), c = a && Xb(d, a) ? -2 : 0) : c = -44;\n            }\n            return c;\n          } catch (f) {\n            return \"undefined\" !== typeof X && f instanceof O || K(f), -f.Pa;\n          }\n        },\n        i: function (a, b) {\n          try {\n            return a = A(a), ea(a, b), 0;\n          } catch (c) {\n            return \"undefined\" !== typeof X && c instanceof O || K(c), -c.Pa;\n          }\n        },\n        t: function (a) {\n          try {\n            return a = A(a), lc(a), 0;\n          } catch (b) {\n            return \"undefined\" !== typeof X && b instanceof O || K(b), -b.Pa;\n          }\n        },\n        j: function (a, b) {\n          try {\n            var c = S[a];\n            if (!c) throw new O(8);\n            ea(c.node, b);\n            return 0;\n          } catch (d) {\n            return \"undefined\" !== typeof X && d instanceof O || K(d), -d.Pa;\n          }\n        },\n        u: function (a) {\n          try {\n            var b = S[a];\n            if (!b) throw new O(8);\n            lc(b.node);\n            return 0;\n          } catch (c) {\n            return \"undefined\" !== typeof X && c instanceof O || K(c), -c.Pa;\n          }\n        },\n        c: function (a, b, c) {\n          Zc = c;\n\n          try {\n            var d = Z(a);\n\n            switch (b) {\n              case 0:\n                var f = $c();\n                return 0 > f ? -28 : u(d.path, d.flags, 0, f).fd;\n\n              case 1:\n              case 2:\n                return 0;\n\n              case 3:\n                return d.flags;\n\n              case 4:\n                return f = $c(), d.flags |= f, 0;\n\n              case 12:\n                return f = $c(), La[f + 0 >> 1] = 2, 0;\n\n              case 13:\n              case 14:\n                return 0;\n\n              case 16:\n              case 8:\n                return -28;\n\n              case 9:\n                return Bb(28), -1;\n\n              default:\n                return -28;\n            }\n          } catch (g) {\n            return \"undefined\" !== typeof X && g instanceof O || K(g), -g.Pa;\n          }\n        },\n        K: function (a, b) {\n          try {\n            var c = Z(a);\n            return Yc(jc, c.path, b);\n          } catch (d) {\n            return \"undefined\" !== typeof X && d instanceof O || K(d), -d.Pa;\n          }\n        },\n        v: function (a, b, c) {\n          try {\n            var d = S[a];\n            if (!d) throw new O(8);\n            if (0 === (d.flags & 2097155)) throw new O(28);\n            mc(d.node, c);\n            return 0;\n          } catch (f) {\n            return \"undefined\" !== typeof X && f instanceof O || K(f), -f.Pa;\n          }\n        },\n        w: function (a, b) {\n          try {\n            if (0 === b) return -28;\n            if (b < aa(\"/\") + 1) return -68;\n            k(\"/\", m, a, b);\n            return a;\n          } catch (c) {\n            return \"undefined\" !== typeof X && c instanceof O || K(c), -c.Pa;\n          }\n        },\n        s: function () {\n          return 0;\n        },\n        e: function () {\n          return 42;\n        },\n        J: function (a, b) {\n          try {\n            return a = A(a), Yc(kc, a, b);\n          } catch (c) {\n            return \"undefined\" !== typeof X && c instanceof O || K(c), -c.Pa;\n          }\n        },\n        I: function (a, b) {\n          try {\n            return a = A(a), a = r(a), \"/\" === a[a.length - 1] && (a = a.substr(0, a.length - 1)), W(a, b), 0;\n          } catch (c) {\n            return \"undefined\" !== typeof X && c instanceof O || K(c), -c.Pa;\n          }\n        },\n        G: function (a, b, c, d, f, g) {\n          try {\n            a: {\n              g <<= 12;\n              var n = !1;\n              if (0 !== (d & 16) && 0 !== a % 16384) var t = -28;else {\n                if (0 !== (d & 32)) {\n                  var w = gd(16384, b);\n\n                  if (!w) {\n                    t = -48;\n                    break a;\n                  }\n\n                  hd(w, 0, b);\n                  n = !0;\n                } else {\n                  var v = S[f];\n\n                  if (!v) {\n                    t = -8;\n                    break a;\n                  }\n\n                  var C = g;\n                  if (0 !== (c & 2) && 0 === (d & 2) && 2 !== (v.flags & 2097155)) throw new O(2);\n                  if (1 === (v.flags & 2097155)) throw new O(2);\n                  if (!v.Oa.hb) throw new O(43);\n                  var H = v.Oa.hb(v, a, b, C, c, d);\n                  w = H.Ob;\n                  n = H.kb;\n                }\n\n                Xc[w] = {\n                  Lb: w,\n                  Kb: b,\n                  kb: n,\n                  fd: f,\n                  Nb: c,\n                  flags: d,\n                  offset: g\n                };\n                t = w;\n              }\n            }\n\n            return t;\n          } catch (Y) {\n            return \"undefined\" !== typeof X && Y instanceof O || K(Y), -Y.Pa;\n          }\n        },\n        H: function (a, b) {\n          try {\n            if (-1 === (a | 0) || 0 === b) var c = -28;else {\n              var d = Xc[a];\n\n              if (d && b === d.Kb) {\n                var f = S[d.fd];\n\n                if (d.Nb & 2) {\n                  var g = d.flags,\n                      n = d.offset,\n                      t = m.slice(a, a + b);\n                  f && f.Oa.ib && f.Oa.ib(f, t, n, b, g);\n                }\n\n                Xc[a] = null;\n                d.kb && na(d.Lb);\n              }\n\n              c = 0;\n            }\n            return c;\n          } catch (w) {\n            return \"undefined\" !== typeof X && w instanceof O || K(w), -w.Pa;\n          }\n        },\n        k: function (a, b, c) {\n          Zc = c;\n\n          try {\n            var d = A(a),\n                f = $c();\n            return u(d, b, f).fd;\n          } catch (g) {\n            return \"undefined\" !== typeof X && g instanceof O || K(g), -g.Pa;\n          }\n        },\n        D: function (a, b, c) {\n          try {\n            var d = Z(a);\n            return Sc(d, z, b, c);\n          } catch (f) {\n            return \"undefined\" !== typeof X && f instanceof O || K(f), -f.Pa;\n          }\n        },\n        C: function (a, b, c) {\n          try {\n            a = A(a);\n            if (0 >= c) var d = -28;else {\n              var f = Tb(a),\n                  g = Math.min(c, aa(f)),\n                  n = z[b + g];\n              k(f, m, b, c + 1);\n              z[b + g] = n;\n              d = g;\n            }\n            return d;\n          } catch (t) {\n            return \"undefined\" !== typeof X && t instanceof O || K(t), -t.Pa;\n          }\n        },\n        E: function (a) {\n          try {\n            a = A(a);\n            var b = V(a, {\n              parent: !0\n            }).node,\n                c = Ab(a),\n                d = Ob(b, c),\n                f = bc(b, c, !0);\n            if (f) throw new O(f);\n            if (!b.Na.rmdir) throw new O(63);\n            if (d.ab) throw new O(10);\n\n            try {\n              U.willDeletePath && U.willDeletePath(a);\n            } catch (g) {\n              J(\"FS.trackingDelegate['willDeletePath']('\" + a + \"') threw an exception: \" + g.message);\n            }\n\n            b.Na.rmdir(b, c);\n            Wb(d);\n\n            try {\n              if (U.onDeletePath) U.onDeletePath(a);\n            } catch (g) {\n              J(\"FS.trackingDelegate['onDeletePath']('\" + a + \"') threw an exception: \" + g.message);\n            }\n\n            return 0;\n          } catch (g) {\n            return \"undefined\" !== typeof X && g instanceof O || K(g), -g.Pa;\n          }\n        },\n        g: function (a, b) {\n          try {\n            return a = A(a), Yc(jc, a, b);\n          } catch (c) {\n            return \"undefined\" !== typeof X && c instanceof O || K(c), -c.Pa;\n          }\n        },\n        y: function (a) {\n          try {\n            return a = A(a), ta(a), 0;\n          } catch (b) {\n            return \"undefined\" !== typeof X && b instanceof O || K(b), -b.Pa;\n          }\n        },\n        m: function (a, b, c) {\n          m.copyWithin(a, b, b + c);\n        },\n        d: function (a) {\n          a >>>= 0;\n          var b = m.length;\n          if (2147483648 < a) return !1;\n\n          for (var c = 1; 4 >= c; c *= 2) {\n            var d = b * (1 + .2 / c);\n            d = Math.min(d, a + 100663296);\n            d = Math.max(16777216, a, d);\n            0 < d % 65536 && (d += 65536 - d % 65536);\n\n            a: {\n              try {\n                Oa.grow(Math.min(2147483648, d) - Xa.byteLength + 65535 >>> 16);\n                Ya(Oa.buffer);\n                var f = 1;\n                break a;\n              } catch (g) {}\n\n              f = void 0;\n            }\n\n            if (f) return !0;\n          }\n\n          return !1;\n        },\n        o: function (a, b) {\n          var c = 0;\n          bd().forEach(function (d, f) {\n            var g = b + c;\n            f = L[a + 4 * f >> 2] = g;\n\n            for (g = 0; g < d.length; ++g) z[f++ >> 0] = d.charCodeAt(g);\n\n            z[f >> 0] = 0;\n            c += d.length + 1;\n          });\n          return 0;\n        },\n        p: function (a, b) {\n          var c = bd();\n          L[a >> 2] = c.length;\n          var d = 0;\n          c.forEach(function (f) {\n            d += f.length + 1;\n          });\n          L[b >> 2] = d;\n          return 0;\n        },\n        f: function (a) {\n          try {\n            var b = Z(a);\n            ka(b);\n            return 0;\n          } catch (c) {\n            return \"undefined\" !== typeof X && c instanceof O || K(c), c.Pa;\n          }\n        },\n        n: function (a, b) {\n          try {\n            var c = Z(a);\n            z[b >> 0] = c.tty ? 2 : Q(c.mode) ? 3 : 40960 === (c.mode & 61440) ? 7 : 4;\n            return 0;\n          } catch (d) {\n            return \"undefined\" !== typeof X && d instanceof O || K(d), d.Pa;\n          }\n        },\n        l: function (a, b, c, d, f) {\n          try {\n            var g = Z(a);\n            a = 4294967296 * c + (b >>> 0);\n            if (-9007199254740992 >= a || 9007199254740992 <= a) return -61;\n            Qc(g, a, d);\n            M = [g.position >>> 0, (N = g.position, 1 <= +Math.abs(N) ? 0 < N ? (Math.min(+Math.floor(N / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)];\n            L[f >> 2] = M[0];\n            L[f + 4 >> 2] = M[1];\n            g.ob && 0 === a && 0 === d && (g.ob = null);\n            return 0;\n          } catch (n) {\n            return \"undefined\" !== typeof X && n instanceof O || K(n), n.Pa;\n          }\n        },\n        x: function (a) {\n          try {\n            var b = Z(a);\n            return b.Oa && b.Oa.fsync ? -b.Oa.fsync(b) : 0;\n          } catch (c) {\n            return \"undefined\" !== typeof X && c instanceof O || K(c), c.Pa;\n          }\n        },\n        F: function (a, b, c, d) {\n          try {\n            a: {\n              for (var f = Z(a), g = a = 0; g < c; g++) {\n                var n = fa(f, z, L[b + 8 * g >> 2], L[b + (8 * g + 4) >> 2], void 0);\n\n                if (0 > n) {\n                  var t = -1;\n                  break a;\n                }\n\n                a += n;\n              }\n\n              t = a;\n            }\n\n            L[d >> 2] = t;\n            return 0;\n          } catch (w) {\n            return \"undefined\" !== typeof X && w instanceof O || K(w), w.Pa;\n          }\n        },\n        h: function (a) {\n          var b = Date.now();\n          L[a >> 2] = b / 1E3 | 0;\n          L[a + 4 >> 2] = b % 1E3 * 1E3 | 0;\n          return 0;\n        },\n        a: Oa,\n        A: function (a, b) {\n          if (0 === a) return Bb(28), -1;\n          var c = L[a >> 2];\n          a = L[a + 4 >> 2];\n          if (0 > a || 999999999 < a || 0 > c) return Bb(28), -1;\n          0 !== b && (L[b >> 2] = 0, L[b + 4 >> 2] = 0);\n          return ed(1E6 * c + a / 1E3);\n        },\n        B: function (a) {\n          switch (a) {\n            case 30:\n              return 16384;\n\n            case 85:\n              return 131072;\n\n            case 132:\n            case 133:\n            case 12:\n            case 137:\n            case 138:\n            case 15:\n            case 235:\n            case 16:\n            case 17:\n            case 18:\n            case 19:\n            case 20:\n            case 149:\n            case 13:\n            case 10:\n            case 236:\n            case 153:\n            case 9:\n            case 21:\n            case 22:\n            case 159:\n            case 154:\n            case 14:\n            case 77:\n            case 78:\n            case 139:\n            case 80:\n            case 81:\n            case 82:\n            case 68:\n            case 67:\n            case 164:\n            case 11:\n            case 29:\n            case 47:\n            case 48:\n            case 95:\n            case 52:\n            case 51:\n            case 46:\n            case 79:\n              return 200809;\n\n            case 27:\n            case 246:\n            case 127:\n            case 128:\n            case 23:\n            case 24:\n            case 160:\n            case 161:\n            case 181:\n            case 182:\n            case 242:\n            case 183:\n            case 184:\n            case 243:\n            case 244:\n            case 245:\n            case 165:\n            case 178:\n            case 179:\n            case 49:\n            case 50:\n            case 168:\n            case 169:\n            case 175:\n            case 170:\n            case 171:\n            case 172:\n            case 97:\n            case 76:\n            case 32:\n            case 173:\n            case 35:\n              return -1;\n\n            case 176:\n            case 177:\n            case 7:\n            case 155:\n            case 8:\n            case 157:\n            case 125:\n            case 126:\n            case 92:\n            case 93:\n            case 129:\n            case 130:\n            case 131:\n            case 94:\n            case 91:\n              return 1;\n\n            case 74:\n            case 60:\n            case 69:\n            case 70:\n            case 4:\n              return 1024;\n\n            case 31:\n            case 42:\n            case 72:\n              return 32;\n\n            case 87:\n            case 26:\n            case 33:\n              return 2147483647;\n\n            case 34:\n            case 1:\n              return 47839;\n\n            case 38:\n            case 36:\n              return 99;\n\n            case 43:\n            case 37:\n              return 2048;\n\n            case 0:\n              return 2097152;\n\n            case 3:\n              return 65536;\n\n            case 28:\n              return 32768;\n\n            case 44:\n              return 32767;\n\n            case 75:\n              return 16384;\n\n            case 39:\n              return 1E3;\n\n            case 89:\n              return 700;\n\n            case 71:\n              return 256;\n\n            case 40:\n              return 255;\n\n            case 2:\n              return 100;\n\n            case 180:\n              return 64;\n\n            case 25:\n              return 20;\n\n            case 5:\n              return 16;\n\n            case 6:\n              return 6;\n\n            case 73:\n              return 4;\n\n            case 84:\n              return \"object\" === typeof navigator ? navigator.hardwareConcurrency || 1 : 1;\n          }\n\n          Bb(28);\n          return -1;\n        },\n        L: function (a) {\n          var b = Date.now() / 1E3 | 0;\n          a && (L[a >> 2] = b);\n          return b;\n        },\n        r: function (a, b) {\n          if (b) {\n            var c = 1E3 * L[b + 8 >> 2];\n            c += L[b + 12 >> 2] / 1E3;\n          } else c = Date.now();\n\n          a = A(a);\n\n          try {\n            b = c;\n            var d = V(a, {\n              Ya: !0\n            }).node;\n            d.Na.Ta(d, {\n              timestamp: Math.max(b, c)\n            });\n            return 0;\n          } catch (f) {\n            a = f;\n\n            if (!(a instanceof O)) {\n              a += \" : \";\n\n              a: {\n                d = Error();\n\n                if (!d.stack) {\n                  try {\n                    throw Error();\n                  } catch (g) {\n                    d = g;\n                  }\n\n                  if (!d.stack) {\n                    d = \"(no stack trace available)\";\n                    break a;\n                  }\n                }\n\n                d = d.stack.toString();\n              }\n\n              e.extraStackTrace && (d += \"\\n\" + e.extraStackTrace());\n              d = ob(d);\n              throw a + d;\n            }\n\n            Bb(a.Pa);\n            return -1;\n          }\n        }\n      };\n\n      (function () {\n        function a(f) {\n          e.asm = f.exports;\n          Ja = e.asm.M;\n          eb--;\n          e.monitorRunDependencies && e.monitorRunDependencies(eb);\n          0 == eb && (null !== fb && (clearInterval(fb), fb = null), gb && (f = gb, gb = null, f()));\n        }\n\n        function b(f) {\n          a(f.instance);\n        }\n\n        function c(f) {\n          return mb().then(function (g) {\n            return WebAssembly.instantiate(g, d);\n          }).then(f, function (g) {\n            J(\"failed to asynchronously prepare wasm: \" + g);\n            K(g);\n          });\n        }\n\n        var d = {\n          a: id\n        };\n        eb++;\n        e.monitorRunDependencies && e.monitorRunDependencies(eb);\n        if (e.instantiateWasm) try {\n          return e.instantiateWasm(d, a);\n        } catch (f) {\n          return J(\"Module.instantiateWasm callback failed with error: \" + f), !1;\n        }\n\n        (function () {\n          if (Ka || \"function\" !== typeof WebAssembly.instantiateStreaming || jb() || hb(\"file://\") || \"function\" !== typeof fetch) return c(b);\n          fetch(ib, {\n            credentials: \"same-origin\"\n          }).then(function (f) {\n            return WebAssembly.instantiateStreaming(f, d).then(b, function (g) {\n              J(\"wasm streaming compile failed: \" + g);\n              J(\"falling back to ArrayBuffer instantiation\");\n              return c(b);\n            });\n          });\n        })();\n\n        return {};\n      })();\n\n      var fd = e.___wasm_call_ctors = function () {\n        return (fd = e.___wasm_call_ctors = e.asm.N).apply(null, arguments);\n      },\n          hd = e._memset = function () {\n        return (hd = e._memset = e.asm.O).apply(null, arguments);\n      };\n\n      e._sqlite3_free = function () {\n        return (e._sqlite3_free = e.asm.P).apply(null, arguments);\n      };\n\n      var Cb = e.___errno_location = function () {\n        return (Cb = e.___errno_location = e.asm.Q).apply(null, arguments);\n      };\n\n      e._sqlite3_finalize = function () {\n        return (e._sqlite3_finalize = e.asm.R).apply(null, arguments);\n      };\n\n      e._sqlite3_reset = function () {\n        return (e._sqlite3_reset = e.asm.S).apply(null, arguments);\n      };\n\n      e._sqlite3_clear_bindings = function () {\n        return (e._sqlite3_clear_bindings = e.asm.T).apply(null, arguments);\n      };\n\n      e._sqlite3_value_blob = function () {\n        return (e._sqlite3_value_blob = e.asm.U).apply(null, arguments);\n      };\n\n      e._sqlite3_value_text = function () {\n        return (e._sqlite3_value_text = e.asm.V).apply(null, arguments);\n      };\n\n      e._sqlite3_value_bytes = function () {\n        return (e._sqlite3_value_bytes = e.asm.W).apply(null, arguments);\n      };\n\n      e._sqlite3_value_double = function () {\n        return (e._sqlite3_value_double = e.asm.X).apply(null, arguments);\n      };\n\n      e._sqlite3_value_int = function () {\n        return (e._sqlite3_value_int = e.asm.Y).apply(null, arguments);\n      };\n\n      e._sqlite3_value_type = function () {\n        return (e._sqlite3_value_type = e.asm.Z).apply(null, arguments);\n      };\n\n      e._sqlite3_result_blob = function () {\n        return (e._sqlite3_result_blob = e.asm._).apply(null, arguments);\n      };\n\n      e._sqlite3_result_double = function () {\n        return (e._sqlite3_result_double = e.asm.$).apply(null, arguments);\n      };\n\n      e._sqlite3_result_error = function () {\n        return (e._sqlite3_result_error = e.asm.aa).apply(null, arguments);\n      };\n\n      e._sqlite3_result_int = function () {\n        return (e._sqlite3_result_int = e.asm.ba).apply(null, arguments);\n      };\n\n      e._sqlite3_result_int64 = function () {\n        return (e._sqlite3_result_int64 = e.asm.ca).apply(null, arguments);\n      };\n\n      e._sqlite3_result_null = function () {\n        return (e._sqlite3_result_null = e.asm.da).apply(null, arguments);\n      };\n\n      e._sqlite3_result_text = function () {\n        return (e._sqlite3_result_text = e.asm.ea).apply(null, arguments);\n      };\n\n      e._sqlite3_step = function () {\n        return (e._sqlite3_step = e.asm.fa).apply(null, arguments);\n      };\n\n      e._sqlite3_column_count = function () {\n        return (e._sqlite3_column_count = e.asm.ga).apply(null, arguments);\n      };\n\n      e._sqlite3_data_count = function () {\n        return (e._sqlite3_data_count = e.asm.ha).apply(null, arguments);\n      };\n\n      e._sqlite3_column_blob = function () {\n        return (e._sqlite3_column_blob = e.asm.ia).apply(null, arguments);\n      };\n\n      e._sqlite3_column_bytes = function () {\n        return (e._sqlite3_column_bytes = e.asm.ja).apply(null, arguments);\n      };\n\n      e._sqlite3_column_double = function () {\n        return (e._sqlite3_column_double = e.asm.ka).apply(null, arguments);\n      };\n\n      e._sqlite3_column_text = function () {\n        return (e._sqlite3_column_text = e.asm.la).apply(null, arguments);\n      };\n\n      e._sqlite3_column_type = function () {\n        return (e._sqlite3_column_type = e.asm.ma).apply(null, arguments);\n      };\n\n      e._sqlite3_column_name = function () {\n        return (e._sqlite3_column_name = e.asm.na).apply(null, arguments);\n      };\n\n      e._sqlite3_bind_blob = function () {\n        return (e._sqlite3_bind_blob = e.asm.oa).apply(null, arguments);\n      };\n\n      e._sqlite3_bind_double = function () {\n        return (e._sqlite3_bind_double = e.asm.pa).apply(null, arguments);\n      };\n\n      e._sqlite3_bind_int = function () {\n        return (e._sqlite3_bind_int = e.asm.qa).apply(null, arguments);\n      };\n\n      e._sqlite3_bind_text = function () {\n        return (e._sqlite3_bind_text = e.asm.ra).apply(null, arguments);\n      };\n\n      e._sqlite3_bind_parameter_index = function () {\n        return (e._sqlite3_bind_parameter_index = e.asm.sa).apply(null, arguments);\n      };\n\n      e._sqlite3_sql = function () {\n        return (e._sqlite3_sql = e.asm.ta).apply(null, arguments);\n      };\n\n      e._sqlite3_normalized_sql = function () {\n        return (e._sqlite3_normalized_sql = e.asm.ua).apply(null, arguments);\n      };\n\n      e._sqlite3_errmsg = function () {\n        return (e._sqlite3_errmsg = e.asm.va).apply(null, arguments);\n      };\n\n      e._sqlite3_exec = function () {\n        return (e._sqlite3_exec = e.asm.wa).apply(null, arguments);\n      };\n\n      e._sqlite3_prepare_v2 = function () {\n        return (e._sqlite3_prepare_v2 = e.asm.xa).apply(null, arguments);\n      };\n\n      e._sqlite3_changes = function () {\n        return (e._sqlite3_changes = e.asm.ya).apply(null, arguments);\n      };\n\n      e._sqlite3_close_v2 = function () {\n        return (e._sqlite3_close_v2 = e.asm.za).apply(null, arguments);\n      };\n\n      e._sqlite3_create_function_v2 = function () {\n        return (e._sqlite3_create_function_v2 = e.asm.Aa).apply(null, arguments);\n      };\n\n      e._sqlite3_open = function () {\n        return (e._sqlite3_open = e.asm.Ba).apply(null, arguments);\n      };\n\n      var ba = e._malloc = function () {\n        return (ba = e._malloc = e.asm.Ca).apply(null, arguments);\n      },\n          na = e._free = function () {\n        return (na = e._free = e.asm.Da).apply(null, arguments);\n      };\n\n      e._RegisterExtensionFunctions = function () {\n        return (e._RegisterExtensionFunctions = e.asm.Ea).apply(null, arguments);\n      };\n\n      var xb = e.__get_tzname = function () {\n        return (xb = e.__get_tzname = e.asm.Fa).apply(null, arguments);\n      },\n          vb = e.__get_daylight = function () {\n        return (vb = e.__get_daylight = e.asm.Ga).apply(null, arguments);\n      },\n          ub = e.__get_timezone = function () {\n        return (ub = e.__get_timezone = e.asm.Ha).apply(null, arguments);\n      },\n          oa = e.stackSave = function () {\n        return (oa = e.stackSave = e.asm.Ia).apply(null, arguments);\n      },\n          qa = e.stackRestore = function () {\n        return (qa = e.stackRestore = e.asm.Ja).apply(null, arguments);\n      },\n          y = e.stackAlloc = function () {\n        return (y = e.stackAlloc = e.asm.Ka).apply(null, arguments);\n      },\n          gd = e._memalign = function () {\n        return (gd = e._memalign = e.asm.La).apply(null, arguments);\n      };\n\n      e.cwrap = function (a, b, c, d) {\n        c = c || [];\n        var f = c.every(function (g) {\n          return \"number\" === g;\n        });\n        return \"string\" !== b && f && !d ? Qa(a) : function () {\n          return Ra(a, b, c, arguments);\n        };\n      };\n\n      e.UTF8ToString = A;\n      e.stackSave = oa;\n      e.stackRestore = qa;\n      e.stackAlloc = y;\n      var jd;\n\n      gb = function kd() {\n        jd || ld();\n        jd || (gb = kd);\n      };\n\n      function ld() {\n        function a() {\n          if (!jd && (jd = !0, e.calledRun = !0, !Pa)) {\n            e.noFSInit || Uc || (Uc = !0, Tc(), e.stdin = e.stdin, e.stdout = e.stdout, e.stderr = e.stderr, e.stdin ? Vc(\"stdin\", e.stdin) : ic(\"/dev/tty\", \"/dev/stdin\"), e.stdout ? Vc(\"stdout\", null, e.stdout) : ic(\"/dev/tty\", \"/dev/stdout\"), e.stderr ? Vc(\"stderr\", null, e.stderr) : ic(\"/dev/tty1\", \"/dev/stderr\"), u(\"/dev/stdin\", \"r\"), u(\"/dev/stdout\", \"w\"), u(\"/dev/stderr\", \"w\"));\n            nb(ab);\n            Sb = !1;\n            nb(bb);\n            if (e.onRuntimeInitialized) e.onRuntimeInitialized();\n            if (e.postRun) for (\"function\" == typeof e.postRun && (e.postRun = [e.postRun]); e.postRun.length;) {\n              var b = e.postRun.shift();\n              cb.unshift(b);\n            }\n            nb(cb);\n          }\n        }\n\n        if (!(0 < eb)) {\n          if (e.preRun) for (\"function\" == typeof e.preRun && (e.preRun = [e.preRun]); e.preRun.length;) db();\n          nb($a);\n          0 < eb || (e.setStatus ? (e.setStatus(\"Running...\"), setTimeout(function () {\n            setTimeout(function () {\n              e.setStatus(\"\");\n            }, 1);\n            a();\n          }, 1)) : a());\n        }\n      }\n\n      e.run = ld;\n      if (e.preInit) for (\"function\" == typeof e.preInit && (e.preInit = [e.preInit]); 0 < e.preInit.length;) e.preInit.pop()();\n      noExitRuntime = !0;\n      ld(); // The shell-pre.js and emcc-generated code goes above\n\n      return Module;\n    }); // The end of the promise being returned\n\n    return initSqlJsPromise;\n  }; // The end of our initSqlJs function\n  // This bit below is copied almost exactly from what you get when you use the MODULARIZE=1 flag with emcc\n  // However, we don't want to use the emcc modularization. See shell-pre.js\n\n\n  if ('object' === 'object' && 'object' === 'object') {\n    module.exports = initSqlJs; // This will allow the module to be used in ES6 or CommonJS\n\n    module.exports.default = initSqlJs;\n  } else if (typeof undefined === 'function' && undefined['amd']) {\n    undefined([], function () {\n      return initSqlJs;\n    });\n  } else if ('object' === 'object') {\n    exports[\"Module\"] = initSqlJs;\n  }\n});\n\nconst getDBFromStore = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (dbName, store) {\n    try {\n      const retDb = yield store.getItem(dbName);\n      return Promise.resolve(retDb);\n    } catch (err) {\n      return Promise.reject(`GetDBFromStore: ${err.message}`);\n    }\n  });\n\n  return function getDBFromStore(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst setInitialDBToStore = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (dbName, store) {\n    try {\n      // export the database\n      const data = null; // store the database\n\n      yield store.setItem(dbName, data);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(`SetInitialDBToStore: ${err.message}`);\n    }\n  });\n\n  return function setInitialDBToStore(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nconst setDBToStore = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (mDb, dbName, store) {\n    try {\n      // export the database\n      const data = mDb.export(); // store the database\n\n      yield saveDBToStore(dbName, data, store);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(`SetDBToStore: ${err.message}`);\n    }\n  });\n\n  return function setDBToStore(_x5, _x6, _x7) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nconst saveDBToStore = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (dbName, data, store) {\n    try {\n      // store the database\n      yield store.setItem(dbName, data);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(`SaveDBToStore: ${err.message}`);\n    }\n  });\n\n  return function saveDBToStore(_x8, _x9, _x10) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nconst removeDBFromStore = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator(function* (dbName, store) {\n    try {\n      yield store.removeItem(dbName);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(`RemoveDBFromStore: ${err.message}`);\n    }\n  });\n\n  return function removeDBFromStore(_x11, _x12) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nconst isDBInStore = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator(function* (dbName, store) {\n    try {\n      const retDb = yield store.getItem(dbName);\n\n      if (retDb != null && retDb.length > 0) {\n        return Promise.resolve(true);\n      } else {\n        return Promise.resolve(false);\n      }\n    } catch (err) {\n      return Promise.reject(`IsDBInStore: ${err}`);\n    }\n  });\n\n  return function isDBInStore(_x13, _x14) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nconst restoreDBFromStore = /*#__PURE__*/function () {\n  var _ref7 = _asyncToGenerator(function* (dbName, prefix, store) {\n    const mFileName = `${prefix}-${dbName}`;\n\n    try {\n      // check if file exists\n      const isFilePre = yield isDBInStore(mFileName, store);\n\n      if (isFilePre) {\n        const isFile = yield isDBInStore(dbName, store);\n\n        if (isFile) {\n          const retDb = yield getDBFromStore(mFileName, store);\n          yield saveDBToStore(dbName, retDb, store);\n          yield removeDBFromStore(mFileName, store);\n          return Promise.resolve();\n        } else {\n          return Promise.reject(new Error(`RestoreDBFromStore: ${dbName} does not exist`));\n        }\n      } else {\n        return Promise.reject(new Error(`RestoreDBFromStore: ${mFileName} does not exist`));\n      }\n    } catch (err) {\n      return Promise.reject(`RestoreDBFromStore: ${err.message}`);\n    }\n  });\n\n  return function restoreDBFromStore(_x15, _x16, _x17) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\nconst copyDBToStore = /*#__PURE__*/function () {\n  var _ref8 = _asyncToGenerator(function* (dbName, toDb, store) {\n    try {\n      // check if file exists\n      const isFile = yield isDBInStore(dbName, store);\n\n      if (isFile) {\n        const retDb = yield getDBFromStore(dbName, store);\n        yield saveDBToStore(toDb, retDb, store);\n        return Promise.resolve();\n      } else {\n        return Promise.reject(new Error(`CopyDBToStore: ${dbName} does not exist`));\n      }\n    } catch (err) {\n      return Promise.reject(`CopyDBToStore: ${err.message}`);\n    }\n  });\n\n  return function copyDBToStore(_x18, _x19, _x20) {\n    return _ref8.apply(this, arguments);\n  };\n}();\n\nconst getDBListFromStore = /*#__PURE__*/function () {\n  var _ref9 = _asyncToGenerator(function* (store) {\n    try {\n      const retDbList = yield store.keys();\n      return Promise.resolve(retDbList);\n    } catch (err) {\n      return Promise.reject(`GetDBListFromStore: ${err.message}`);\n    }\n  });\n\n  return function getDBListFromStore(_x21) {\n    return _ref9.apply(this, arguments);\n  };\n}();\n\nconst getTablesNames = /*#__PURE__*/function () {\n  var _ref10 = _asyncToGenerator(function* (db) {\n    let sql = 'SELECT name FROM sqlite_master WHERE ';\n    sql += \"type='table' AND name NOT LIKE 'sync_table' \";\n    sql += \"AND name NOT LIKE '_temp_%' \";\n    sql += \"AND name NOT LIKE 'sqlite_%' \";\n    sql += \"ORDER BY rootpage DESC;\";\n    const retArr = [];\n\n    try {\n      const retQuery = yield queryAll(db, sql, []);\n\n      for (const query of retQuery) {\n        retArr.push(query.name);\n      }\n\n      return Promise.resolve(retArr);\n    } catch (err) {\n      return Promise.reject(new Error(`GetTablesNames: ${err.message}`));\n    }\n  });\n\n  return function getTablesNames(_x22) {\n    return _ref10.apply(this, arguments);\n  };\n}();\n\nconst getViewsNames = /*#__PURE__*/function () {\n  var _ref11 = _asyncToGenerator(function* (mDb) {\n    let sql = 'SELECT name FROM sqlite_master WHERE ';\n    sql += \"type='view' AND name NOT LIKE 'sqlite_%' \";\n    sql += 'ORDER BY rootpage DESC;';\n    const retArr = [];\n\n    try {\n      const retQuery = yield queryAll(mDb, sql, []);\n\n      for (const query of retQuery) {\n        retArr.push(query.name);\n      }\n\n      return Promise.resolve(retArr);\n    } catch (err) {\n      return Promise.reject(new Error(`getViewsNames: ${err.message}`));\n    }\n  });\n\n  return function getViewsNames(_x23) {\n    return _ref11.apply(this, arguments);\n  };\n}();\n\nconst dropElements = /*#__PURE__*/function () {\n  var _ref12 = _asyncToGenerator(function* (db, type) {\n    let msg = '';\n\n    switch (type) {\n      case 'index':\n        msg = 'DropIndexes';\n        break;\n\n      case 'trigger':\n        msg = 'DropTriggers';\n        break;\n\n      case 'table':\n        msg = 'DropTables';\n        break;\n\n      case 'view':\n        msg = 'DropViews';\n        break;\n\n      default:\n        return Promise.reject(new Error(`DropElements: ${type} ` + 'not found'));\n    } // get the element's names\n\n\n    let stmt = 'SELECT name FROM sqlite_master WHERE ';\n    stmt += `type = '${type}' AND name NOT LIKE 'sqlite_%';`;\n\n    try {\n      const elements = yield queryAll(db, stmt, []);\n\n      if (elements.length > 0) {\n        const upType = type.toUpperCase();\n        const statements = [];\n\n        for (const elem of elements) {\n          let stmt = `DROP ${upType} IF EXISTS `;\n          stmt += `${elem.name};`;\n          statements.push(stmt);\n        }\n\n        for (const stmt of statements) {\n          const lastId = yield run(db, stmt, []);\n\n          if (lastId < 0) {\n            return Promise.reject(new Error(`DropElements: ${msg}: lastId < 0`));\n          }\n        }\n      }\n\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(new Error(`DropElements: ${msg}: ${err.message}`));\n    }\n  });\n\n  return function dropElements(_x24, _x25) {\n    return _ref12.apply(this, arguments);\n  };\n}();\n\nconst dropAll = /*#__PURE__*/function () {\n  var _ref13 = _asyncToGenerator(function* (db) {\n    try {\n      // drop tables\n      yield dropElements(db, 'table'); // drop indexes\n\n      yield dropElements(db, 'index'); // drop triggers\n\n      yield dropElements(db, 'trigger'); // drop views\n\n      yield dropElements(db, 'view'); // vacuum the database\n\n      yield run(db, 'VACUUM;', []);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(new Error(`DropAll: ${err.message}`));\n    }\n  });\n\n  return function dropAll(_x26) {\n    return _ref13.apply(this, arguments);\n  };\n}();\n\nconst dropTempTables = /*#__PURE__*/function () {\n  var _ref14 = _asyncToGenerator(function* (db, alterTables) {\n    const tempTables = Object.keys(alterTables);\n    const statements = [];\n\n    for (const tTable of tempTables) {\n      let stmt = 'DROP TABLE IF EXISTS ';\n      stmt += `_temp_${tTable};`;\n      statements.push(stmt);\n    }\n\n    try {\n      const changes = yield execute(db, statements.join('\\n'));\n\n      if (changes < 0) {\n        return Promise.reject(new Error('DropTempTables: changes < 0'));\n      }\n\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(new Error(`DropTempTables: ${err.message}`));\n    }\n  });\n\n  return function dropTempTables(_x27, _x28) {\n    return _ref14.apply(this, arguments);\n  };\n}();\n\nconst beginTransaction = /*#__PURE__*/function () {\n  var _ref15 = _asyncToGenerator(function* (db, isOpen) {\n    const msg = 'BeginTransaction: ';\n\n    if (!isOpen) {\n      return Promise.reject(new Error(`${msg}database not opened`));\n    }\n\n    const sql = 'BEGIN TRANSACTION;';\n\n    try {\n      yield db.run(sql);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(new Error(`DbChanges failed: ${err}`));\n    }\n  });\n\n  return function beginTransaction(_x29, _x30) {\n    return _ref15.apply(this, arguments);\n  };\n}();\n\nconst rollbackTransaction = /*#__PURE__*/function () {\n  var _ref16 = _asyncToGenerator(function* (db, isOpen) {\n    const msg = 'RollbackTransaction: ';\n\n    if (!isOpen) {\n      return Promise.reject(new Error(`${msg}database not opened`));\n    }\n\n    const sql = 'ROLLBACK TRANSACTION;';\n\n    try {\n      yield db.run(sql);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(new Error(`${msg}${err.message}`));\n    }\n  });\n\n  return function rollbackTransaction(_x31, _x32) {\n    return _ref16.apply(this, arguments);\n  };\n}();\n\nconst commitTransaction = /*#__PURE__*/function () {\n  var _ref17 = _asyncToGenerator(function* (db, isOpen) {\n    const msg = 'CommitTransaction: ';\n\n    if (!isOpen) {\n      return Promise.reject(new Error(`${msg}database not opened`));\n    }\n\n    const sql = 'COMMIT TRANSACTION;';\n\n    try {\n      yield db.run(sql);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(new Error(`${msg}${err.message}`));\n    }\n  });\n\n  return function commitTransaction(_x33, _x34) {\n    return _ref17.apply(this, arguments);\n  };\n}();\n\nconst dbChanges = /*#__PURE__*/function () {\n  var _ref18 = _asyncToGenerator(function* (db) {\n    const SELECT_CHANGE = 'SELECT total_changes()';\n    let changes = 0;\n\n    try {\n      const res = yield db.exec(SELECT_CHANGE); // process the row here\n\n      changes = res[0].values[0][0];\n      return Promise.resolve(changes);\n    } catch (err) {\n      return Promise.reject(new Error(`DbChanges failed: ${err.message}`));\n    }\n  });\n\n  return function dbChanges(_x35) {\n    return _ref18.apply(this, arguments);\n  };\n}();\n\nconst getLastId = /*#__PURE__*/function () {\n  var _ref19 = _asyncToGenerator(function* (db) {\n    const SELECT_LAST_ID = 'SELECT last_insert_rowid()';\n    let lastId = -1;\n\n    try {\n      const res = yield db.exec(SELECT_LAST_ID); // process the row here\n\n      lastId = res[0].values[0][0];\n      return Promise.resolve(lastId);\n    } catch (err) {\n      return Promise.reject(new Error(`GetLastId failed: ${err.message}`));\n    }\n  });\n\n  return function getLastId(_x36) {\n    return _ref19.apply(this, arguments);\n  };\n}();\n\nconst setForeignKeyConstraintsEnabled = /*#__PURE__*/function () {\n  var _ref20 = _asyncToGenerator(function* (db, toggle) {\n    let key = 'OFF';\n\n    if (toggle) {\n      key = 'ON';\n    }\n\n    try {\n      yield db.exec(`PRAGMA foreign_keys = '${key}'`);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(new Error(`SetForeignKey: ${err.message}`));\n    }\n  });\n\n  return function setForeignKeyConstraintsEnabled(_x37, _x38) {\n    return _ref20.apply(this, arguments);\n  };\n}();\n\nconst getVersion = /*#__PURE__*/function () {\n  var _ref21 = _asyncToGenerator(function* (db) {\n    let version = 0;\n\n    try {\n      const res = yield db.exec('PRAGMA user_version;');\n      version = res[0].values[0][0];\n      return Promise.resolve(version);\n    } catch (err) {\n      return Promise.reject(new Error(`GetVersion: ${err.message}`));\n    }\n  });\n\n  return function getVersion(_x39) {\n    return _ref21.apply(this, arguments);\n  };\n}();\n\nconst setVersion = /*#__PURE__*/function () {\n  var _ref22 = _asyncToGenerator(function* (db, version) {\n    try {\n      yield db.exec(`PRAGMA user_version = ${version}`);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(new Error(`SetVersion: ${err.message}`));\n    }\n  });\n\n  return function setVersion(_x40, _x41) {\n    return _ref22.apply(this, arguments);\n  };\n}();\n\nconst execute = /*#__PURE__*/function () {\n  var _ref23 = _asyncToGenerator(function* (db, sql) {\n    let changes = -1;\n    let initChanges = -1;\n\n    try {\n      initChanges = yield dbChanges(db);\n      yield db.exec(sql);\n      changes = (yield dbChanges(db)) - initChanges;\n      return Promise.resolve(changes);\n    } catch (err) {\n      return Promise.reject(new Error(`Execute: ${err.message}`));\n    }\n  });\n\n  return function execute(_x42, _x43) {\n    return _ref23.apply(this, arguments);\n  };\n}();\n\nconst executeSet = /*#__PURE__*/function () {\n  var _ref24 = _asyncToGenerator(function* (db, set) {\n    let lastId = -1;\n\n    for (let i = 0; i < set.length; i++) {\n      const statement = 'statement' in set[i] ? set[i].statement : null;\n      const values = 'values' in set[i] && set[i].values.length > 0 ? set[i].values : [];\n\n      if (statement == null) {\n        let msg = 'ExecuteSet: Error No statement';\n        msg += ` for index ${i}`;\n        return Promise.reject(new Error(msg));\n      }\n\n      try {\n        if (Array.isArray(values[0])) {\n          for (const val of values) {\n            const mVal = yield replaceUndefinedByNull(val);\n            yield db.exec(statement, mVal);\n          }\n        } else {\n          const mVal = yield replaceUndefinedByNull(values);\n          yield db.exec(statement, mVal);\n        }\n\n        lastId = yield getLastId(db);\n      } catch (err) {\n        return Promise.reject(new Error(`ExecuteSet: ${err.message}`));\n      }\n    }\n\n    return Promise.resolve(lastId);\n  });\n\n  return function executeSet(_x44, _x45) {\n    return _ref24.apply(this, arguments);\n  };\n}();\n\nconst queryAll = /*#__PURE__*/function () {\n  var _ref25 = _asyncToGenerator(function* (db, sql, values) {\n    const result = [];\n\n    try {\n      let retArr = [];\n\n      if (values != null && values.length > 0) {\n        retArr = yield db.exec(sql, values);\n      } else {\n        retArr = yield db.exec(sql);\n      }\n\n      if (retArr.length == 0) return Promise.resolve([]);\n\n      for (const valRow of retArr[0].values) {\n        const row = {};\n\n        for (let i = 0; i < retArr[0].columns.length; i++) {\n          row[retArr[0].columns[i]] = valRow[i];\n        }\n\n        result.push(row);\n      }\n\n      return Promise.resolve(result);\n    } catch (err) {\n      return Promise.reject(new Error(`queryAll: ${err.message}`));\n    }\n  });\n\n  return function queryAll(_x46, _x47, _x48) {\n    return _ref25.apply(this, arguments);\n  };\n}();\n\nconst run = /*#__PURE__*/function () {\n  var _ref26 = _asyncToGenerator(function* (db, statement, values) {\n    let lastId = -1;\n\n    try {\n      if (values != null && values.length > 0) {\n        const mVal = yield replaceUndefinedByNull(values);\n        yield db.exec(statement, mVal);\n      } else {\n        yield db.exec(statement);\n      }\n\n      lastId = yield getLastId(db);\n      return Promise.resolve(lastId);\n    } catch (err) {\n      return Promise.reject(new Error(`run: ${err.message}`));\n    }\n  });\n\n  return function run(_x49, _x50, _x51) {\n    return _ref26.apply(this, arguments);\n  };\n}();\n\nconst isTableExists = /*#__PURE__*/function () {\n  var _ref27 = _asyncToGenerator(function* (db, tableName) {\n    try {\n      let statement = 'SELECT name FROM sqlite_master WHERE ';\n      statement += `type='table' AND name='${tableName}';`;\n      const res = yield queryAll(db, statement, []);\n      const ret = res.length > 0 ? true : false;\n      return Promise.resolve(ret);\n    } catch (err) {\n      return Promise.reject(new Error(`isTableExists: ${err.message}`));\n    }\n  });\n\n  return function isTableExists(_x52, _x53) {\n    return _ref27.apply(this, arguments);\n  };\n}();\n\nconst replaceUndefinedByNull = /*#__PURE__*/function () {\n  var _ref28 = _asyncToGenerator(function* (values) {\n    const retValues = [];\n\n    for (const val of values) {\n      let mVal = val;\n      if (typeof val === 'undefined') mVal = null;\n      retValues.push(mVal);\n    }\n\n    return Promise.resolve(retValues);\n  });\n\n  return function replaceUndefinedByNull(_x54) {\n    return _ref28.apply(this, arguments);\n  };\n}();\n\nconst backupTables = /*#__PURE__*/function () {\n  var _ref29 = _asyncToGenerator(function* (db) {\n    const msg = 'BackupTables: ';\n    let alterTables = {};\n\n    try {\n      const tables = yield getTablesNames(db);\n\n      for (const table of tables) {\n        try {\n          const colNames = yield backupTable(db, table);\n          alterTables[`${table}`] = colNames;\n        } catch (err) {\n          return Promise.reject(new Error(`${msg}table ${table}: ` + `${err.message}`));\n        }\n      }\n\n      return Promise.resolve(alterTables);\n    } catch (err) {\n      return Promise.reject(new Error(`BackupTables: ${err.message}`));\n    }\n  });\n\n  return function backupTables(_x55) {\n    return _ref29.apply(this, arguments);\n  };\n}();\n\nconst backupTable = /*#__PURE__*/function () {\n  var _ref30 = _asyncToGenerator(function* (db, table) {\n    try {\n      // start a transaction\n      yield beginTransaction(db, true); // get the table's column names\n\n      const colNames = yield getTableColumnNames(db, table); // prefix the table with _temp_\n\n      let stmt = `ALTER TABLE ${table} RENAME `;\n      stmt += `TO _temp_${table};`;\n      const lastId = yield run(db, stmt, []);\n\n      if (lastId < 0) {\n        let msg = 'BackupTable: lastId < 0';\n\n        try {\n          yield rollbackTransaction(db, true);\n        } catch (err) {\n          msg += `: ${err.message}`;\n        }\n\n        return Promise.reject(new Error(`${msg}`));\n      } else {\n        try {\n          yield commitTransaction(db, true);\n          return Promise.resolve(colNames);\n        } catch (err) {\n          return Promise.reject(new Error('BackupTable: ' + `${err.message}`));\n        }\n      }\n    } catch (err) {\n      return Promise.reject(new Error(`BackupTable: ${err.message}`));\n    }\n  });\n\n  return function backupTable(_x56, _x57) {\n    return _ref30.apply(this, arguments);\n  };\n}();\n\nconst getTableColumnNames = /*#__PURE__*/function () {\n  var _ref31 = _asyncToGenerator(function* (db, tableName) {\n    let resQuery = [];\n    const retNames = [];\n    const query = `PRAGMA table_info('${tableName}');`;\n\n    try {\n      resQuery = yield queryAll(db, query, []);\n\n      if (resQuery.length > 0) {\n        for (const query of resQuery) {\n          retNames.push(query.name);\n        }\n      }\n\n      return Promise.resolve(retNames);\n    } catch (err) {\n      return Promise.reject(new Error('GetTableColumnNames: ' + `${err.message}`));\n    }\n  });\n\n  return function getTableColumnNames(_x58, _x59) {\n    return _ref31.apply(this, arguments);\n  };\n}();\n\nconst findCommonColumns = /*#__PURE__*/function () {\n  var _ref32 = _asyncToGenerator(function* (db, alterTables) {\n    let commonColumns = {};\n\n    try {\n      // Get new table list\n      const tables = yield getTablesNames(db);\n\n      if (tables.length === 0) {\n        return Promise.reject(new Error('FindCommonColumns: get ' + \"table's names failed\"));\n      }\n\n      for (const table of tables) {\n        // get the column's name\n        const tableNames = yield getTableColumnNames(db, table); // find the common columns\n\n        const keys = Object.keys(alterTables);\n\n        if (keys.includes(table)) {\n          commonColumns[table] = arraysIntersection(alterTables[table], tableNames);\n        }\n      }\n\n      return Promise.resolve(commonColumns);\n    } catch (err) {\n      return Promise.reject(new Error(`FindCommonColumns: ${err.message}`));\n    }\n  });\n\n  return function findCommonColumns(_x60, _x61) {\n    return _ref32.apply(this, arguments);\n  };\n}();\n\nconst arraysIntersection = (a1, a2) => {\n  if (a1 != null && a2 != null) {\n    const first = new Set(a1);\n    const second = new Set(a2);\n    return [...first].filter(item => second.has(item));\n  } else {\n    return [];\n  }\n};\n\nconst updateNewTablesData = /*#__PURE__*/function () {\n  var _ref33 = _asyncToGenerator(function* (db, commonColumns) {\n    try {\n      // start a transaction\n      yield beginTransaction(db, true);\n      const statements = [];\n      const keys = Object.keys(commonColumns);\n      keys.forEach(key => {\n        const columns = commonColumns[key].join(',');\n        let stmt = `INSERT INTO ${key} `;\n        stmt += `(${columns}) `;\n        stmt += `SELECT ${columns} FROM _temp_${key};`;\n        statements.push(stmt);\n      });\n      const changes = yield execute(db, statements.join('\\n'));\n\n      if (changes < 0) {\n        let msg = 'updateNewTablesData: ' + 'changes < 0';\n\n        try {\n          yield rollbackTransaction(db, true);\n        } catch (err) {\n          msg += `: ${err.message}`;\n        }\n\n        return Promise.reject(new Error(`${msg}`));\n      } else {\n        try {\n          yield commitTransaction(db, true);\n          return Promise.resolve();\n        } catch (err) {\n          return Promise.reject(new Error('updateNewTablesData: ' + `${err.message}`));\n        }\n      }\n    } catch (err) {\n      return Promise.reject(new Error('updateNewTablesData: ' + `${err.message}`));\n    }\n  });\n\n  return function updateNewTablesData(_x62, _x63) {\n    return _ref33.apply(this, arguments);\n  };\n}();\n\nconst isJsonSQLite = /*#__PURE__*/function () {\n  var _ref34 = _asyncToGenerator(function* (obj) {\n    const keyFirstLevel = ['database', 'version', 'encrypted', 'mode', 'tables', 'views'];\n    if (obj == null || Object.keys(obj).length === 0 && obj.constructor === Object) return false;\n\n    for (const key of Object.keys(obj)) {\n      if (keyFirstLevel.indexOf(key) === -1) return false;\n      if (key === 'database' && typeof obj[key] != 'string') return false;\n      if (key === 'version' && typeof obj[key] != 'number') return false;\n      if (key === 'encrypted' && typeof obj[key] != 'boolean') return false;\n      if (key === 'mode' && typeof obj[key] != 'string') return false;\n      if (key === 'tables' && typeof obj[key] != 'object') return false;\n\n      if (key === 'tables') {\n        for (const oKey of obj[key]) {\n          const retTable = yield isTable(oKey);\n          if (!retTable) return false;\n        }\n      }\n\n      if (key === 'views' && typeof obj[key] != 'object') return false;\n\n      if (key === 'views') {\n        for (const oKey of obj[key]) {\n          const retView = yield isView(oKey);\n          if (!retView) return false;\n        }\n      }\n    }\n\n    return true;\n  });\n\n  return function isJsonSQLite(_x64) {\n    return _ref34.apply(this, arguments);\n  };\n}();\n\nconst isTable = /*#__PURE__*/function () {\n  var _ref35 = _asyncToGenerator(function* (obj) {\n    const keyTableLevel = ['name', 'schema', 'indexes', 'triggers', 'values'];\n    let nbColumn = 0;\n    if (obj == null || Object.keys(obj).length === 0 && obj.constructor === Object) return false;\n\n    for (const key of Object.keys(obj)) {\n      if (keyTableLevel.indexOf(key) === -1) return false;\n      if (key === 'name' && typeof obj[key] != 'string') return false;\n      if (key === 'schema' && typeof obj[key] != 'object') return false;\n      if (key === 'indexes' && typeof obj[key] != 'object') return false;\n      if (key === 'triggers' && typeof obj[key] != 'object') return false;\n      if (key === 'values' && typeof obj[key] != 'object') return false;\n\n      if (key === 'schema') {\n        obj['schema'].forEach(element => {\n          if (element.column) {\n            nbColumn++;\n          }\n        });\n\n        for (let i = 0; i < nbColumn; i++) {\n          const retSchema = yield isSchema(obj[key][i]);\n          if (!retSchema) return false;\n        }\n      }\n\n      if (key === 'indexes') {\n        for (const oKey of obj[key]) {\n          const retIndexes = yield isIndexes(oKey);\n          if (!retIndexes) return false;\n        }\n      }\n\n      if (key === 'triggers') {\n        for (const oKey of obj[key]) {\n          const retTriggers = yield isTriggers(oKey);\n          if (!retTriggers) return false;\n        }\n      }\n\n      if (key === 'values') {\n        if (nbColumn > 0) {\n          for (const oKey of obj[key]) {\n            if (typeof oKey != 'object' || oKey.length != nbColumn) return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  });\n\n  return function isTable(_x65) {\n    return _ref35.apply(this, arguments);\n  };\n}();\n\nconst isSchema = /*#__PURE__*/function () {\n  var _ref36 = _asyncToGenerator(function* (obj) {\n    const keySchemaLevel = ['column', 'value', 'foreignkey', 'constraint'];\n    if (obj == null || Object.keys(obj).length === 0 && obj.constructor === Object) return false;\n\n    for (const key of Object.keys(obj)) {\n      if (keySchemaLevel.indexOf(key) === -1) return false;\n      if (key === 'column' && typeof obj[key] != 'string') return false;\n      if (key === 'value' && typeof obj[key] != 'string') return false;\n      if (key === 'foreignkey' && typeof obj[key] != 'string') return false;\n      if (key === 'constraint' && typeof obj[key] != 'string') return false;\n    }\n\n    return true;\n  });\n\n  return function isSchema(_x66) {\n    return _ref36.apply(this, arguments);\n  };\n}();\n\nconst isIndexes = /*#__PURE__*/function () {\n  var _ref37 = _asyncToGenerator(function* (obj) {\n    const keyIndexesLevel = ['name', 'value', 'mode'];\n    if (obj == null || Object.keys(obj).length === 0 && obj.constructor === Object) return false;\n\n    for (const key of Object.keys(obj)) {\n      if (keyIndexesLevel.indexOf(key) === -1) return false;\n      if (key === 'name' && typeof obj[key] != 'string') return false;\n      if (key === 'value' && typeof obj[key] != 'string') return false;\n      if (key === 'mode' && (typeof obj[key] != 'string' || obj[key].toUpperCase() != 'UNIQUE')) return false;\n    }\n\n    return true;\n  });\n\n  return function isIndexes(_x67) {\n    return _ref37.apply(this, arguments);\n  };\n}();\n\nconst isTriggers = /*#__PURE__*/function () {\n  var _ref38 = _asyncToGenerator(function* (obj) {\n    const keyTriggersLevel = ['name', 'timeevent', 'condition', 'logic'];\n    if (obj == null || Object.keys(obj).length === 0 && obj.constructor === Object) return false;\n\n    for (const key of Object.keys(obj)) {\n      if (keyTriggersLevel.indexOf(key) === -1) return false;\n      if (key === 'name' && typeof obj[key] != 'string') return false;\n      if (key === 'timeevent' && typeof obj[key] != 'string') return false;\n      if (key === 'condition' && typeof obj[key] != 'string') return false;\n      if (key === 'logic' && typeof obj[key] != 'string') return false;\n    }\n\n    return true;\n  });\n\n  return function isTriggers(_x68) {\n    return _ref38.apply(this, arguments);\n  };\n}();\n\nconst isView = /*#__PURE__*/function () {\n  var _ref39 = _asyncToGenerator(function* (obj) {\n    const keyViewLevel = ['name', 'value'];\n    if (obj == null || Object.keys(obj).length === 0 && obj.constructor === Object) return false;\n\n    for (const key of Object.keys(obj)) {\n      if (keyViewLevel.indexOf(key) === -1) return false;\n      if (key === 'name' && typeof obj[key] != 'string') return false;\n      if (key === 'value' && typeof obj[key] != 'string') return false;\n    }\n\n    return true;\n  });\n\n  return function isView(_x69) {\n    return _ref39.apply(this, arguments);\n  };\n}();\n\nconst checkSchemaValidity = /*#__PURE__*/function () {\n  var _ref40 = _asyncToGenerator(function* (schema) {\n    for (let i = 0; i < schema.length; i++) {\n      const sch = {};\n      const keys = Object.keys(schema[i]);\n\n      if (keys.includes('column')) {\n        sch.column = schema[i].column;\n      }\n\n      if (keys.includes('value')) {\n        sch.value = schema[i].value;\n      }\n\n      if (keys.includes('foreignkey')) {\n        sch.foreignkey = schema[i].foreignkey;\n      }\n\n      if (keys.includes('constraint')) {\n        sch.constraint = schema[i].constraint;\n      }\n\n      const isValid = yield isSchema(sch);\n\n      if (!isValid) {\n        return Promise.reject(new Error(`CheckSchemaValidity: schema[${i}] not valid`));\n      }\n    }\n\n    return Promise.resolve();\n  });\n\n  return function checkSchemaValidity(_x70) {\n    return _ref40.apply(this, arguments);\n  };\n}();\n\nconst checkIndexesValidity = /*#__PURE__*/function () {\n  var _ref41 = _asyncToGenerator(function* (indexes) {\n    for (let i = 0; i < indexes.length; i++) {\n      const index = {};\n      const keys = Object.keys(indexes[i]);\n\n      if (keys.includes('value')) {\n        index.value = indexes[i].value;\n      }\n\n      if (keys.includes('name')) {\n        index.name = indexes[i].name;\n      }\n\n      if (keys.includes('mode')) {\n        index.mode = indexes[i].mode;\n      }\n\n      const isValid = yield isIndexes(index);\n\n      if (!isValid) {\n        return Promise.reject(new Error(`CheckIndexesValidity: indexes[${i}] not valid`));\n      }\n    }\n\n    return Promise.resolve();\n  });\n\n  return function checkIndexesValidity(_x71) {\n    return _ref41.apply(this, arguments);\n  };\n}();\n\nconst checkTriggersValidity = /*#__PURE__*/function () {\n  var _ref42 = _asyncToGenerator(function* (triggers) {\n    for (let i = 0; i < triggers.length; i++) {\n      const trigger = {};\n      const keys = Object.keys(triggers[i]);\n\n      if (keys.includes('logic')) {\n        trigger.logic = triggers[i].logic;\n      }\n\n      if (keys.includes('name')) {\n        trigger.name = triggers[i].name;\n      }\n\n      if (keys.includes('timeevent')) {\n        trigger.timeevent = triggers[i].timeevent;\n      }\n\n      if (keys.includes('condition')) {\n        trigger.condition = triggers[i].condition;\n      }\n\n      const isValid = yield isTriggers(trigger);\n\n      if (!isValid) {\n        return Promise.reject(new Error(`CheckTriggersValidity: triggers[${i}] not valid`));\n      }\n    }\n\n    return Promise.resolve();\n  });\n\n  return function checkTriggersValidity(_x72) {\n    return _ref42.apply(this, arguments);\n  };\n}();\n\nconst checkViewsValidity = /*#__PURE__*/function () {\n  var _ref43 = _asyncToGenerator(function* (views) {\n    for (let i = 0; i < views.length; i++) {\n      const view = {};\n      const keys = Object.keys(views[i]);\n\n      if (keys.includes('value')) {\n        view.value = views[i].value;\n      }\n\n      if (keys.includes('name')) {\n        view.name = views[i].name;\n      }\n\n      const isValid = yield isView(view);\n\n      if (!isValid) {\n        return Promise.reject(new Error(`CheckViewsValidity: views[${i}] not valid`));\n      }\n    }\n\n    return Promise.resolve();\n  });\n\n  return function checkViewsValidity(_x73) {\n    return _ref43.apply(this, arguments);\n  };\n}();\n\nconst getTableColumnNamesTypes = /*#__PURE__*/function () {\n  var _ref44 = _asyncToGenerator(function* (db, tableName) {\n    let resQuery = [];\n    const retNames = [];\n    const retTypes = [];\n    const query = `PRAGMA table_info('${tableName}');`;\n\n    try {\n      resQuery = yield queryAll(db, query, []);\n\n      if (resQuery.length > 0) {\n        for (const query of resQuery) {\n          retNames.push(query.name);\n          retTypes.push(query.type);\n        }\n      }\n\n      return Promise.resolve({\n        names: retNames,\n        types: retTypes\n      });\n    } catch (err) {\n      return Promise.reject(new Error('GetTableColumnNamesTypes: ' + `${err.message}`));\n    }\n  });\n\n  return function getTableColumnNamesTypes(_x74, _x75) {\n    return _ref44.apply(this, arguments);\n  };\n}();\n\nconst createDatabaseSchema = /*#__PURE__*/function () {\n  var _ref45 = _asyncToGenerator(function* (db, jsonData) {\n    let changes = -1;\n    const version = jsonData.version;\n\n    try {\n      // set Foreign Keys On\n      yield setForeignKeyConstraintsEnabled(db, true); // set User Version PRAGMA\n\n      yield setVersion(db, version); // DROP ALL when mode=\"full\"\n\n      if (jsonData.mode === 'full') {\n        yield dropAll(db);\n      } // create database schema\n\n\n      changes = yield createSchema(db, jsonData);\n      return Promise.resolve(changes);\n    } catch (err) {\n      return Promise.reject(new Error('CreateDatabaseSchema: ' + `${err.message}`));\n    }\n  });\n\n  return function createDatabaseSchema(_x76, _x77) {\n    return _ref45.apply(this, arguments);\n  };\n}();\n\nconst createSchema = /*#__PURE__*/function () {\n  var _ref46 = _asyncToGenerator(function* (db, jsonData) {\n    // create the database schema\n    let changes = 0;\n\n    try {\n      // start a transaction\n      yield beginTransaction(db, true);\n    } catch (err) {\n      return Promise.reject(new Error(`CreateSchema: ${err.message}`));\n    }\n\n    const stmts = yield createSchemaStatement(jsonData);\n\n    if (stmts.length > 0) {\n      const schemaStmt = stmts.join('\\n');\n\n      try {\n        changes = yield execute(db, schemaStmt);\n\n        if (changes < 0) {\n          try {\n            yield rollbackTransaction(db, true);\n          } catch (err) {\n            return Promise.reject(new Error('CreateSchema: changes < 0 ' + `${err.message}`));\n          }\n        }\n      } catch (err) {\n        const msg = err.message;\n\n        try {\n          yield rollbackTransaction(db, true);\n          return Promise.reject(new Error(`CreateSchema: ${msg}`));\n        } catch (err) {\n          return Promise.reject(new Error('CreateSchema: changes < 0 ' + `${err.message}: ${msg}`));\n        }\n      }\n    }\n\n    try {\n      yield commitTransaction(db, true);\n      return Promise.resolve(changes);\n    } catch (err) {\n      return Promise.reject(new Error('CreateSchema: commit ' + `${err.message}`));\n    }\n  });\n\n  return function createSchema(_x78, _x79) {\n    return _ref46.apply(this, arguments);\n  };\n}();\n\nconst createSchemaStatement = /*#__PURE__*/function () {\n  var _ref47 = _asyncToGenerator(function* (jsonData) {\n    const statements = []; // Prepare the statement to execute\n\n    try {\n      for (const jTable of jsonData.tables) {\n        if (jTable.schema != null && jTable.schema.length >= 1) {\n          // create table\n          statements.push('CREATE TABLE IF NOT EXISTS ' + `${jTable.name} (`);\n\n          for (let j = 0; j < jTable.schema.length; j++) {\n            if (j === jTable.schema.length - 1) {\n              if (jTable.schema[j].column) {\n                statements.push(`${jTable.schema[j].column} ${jTable.schema[j].value}`);\n              } else if (jTable.schema[j].foreignkey) {\n                statements.push(`FOREIGN KEY (${jTable.schema[j].foreignkey}) ${jTable.schema[j].value}`);\n              } else if (jTable.schema[j].constraint) {\n                statements.push(`CONSTRAINT ${jTable.schema[j].constraint} ${jTable.schema[j].value}`);\n              }\n            } else {\n              if (jTable.schema[j].column) {\n                statements.push(`${jTable.schema[j].column} ${jTable.schema[j].value},`);\n              } else if (jTable.schema[j].foreignkey) {\n                statements.push(`FOREIGN KEY (${jTable.schema[j].foreignkey}) ${jTable.schema[j].value},`);\n              } else if (jTable.schema[j].constraint) {\n                statements.push(`CONSTRAINT ${jTable.schema[j].constraint} ${jTable.schema[j].value},`);\n              }\n            }\n          }\n\n          statements.push(');'); // create trigger last_modified associated with the table\n\n          let trig = 'CREATE TRIGGER IF NOT EXISTS ';\n          trig += `${jTable.name}`;\n          trig += `_trigger_last_modified `;\n          trig += `AFTER UPDATE ON ${jTable.name} `;\n          trig += 'FOR EACH ROW WHEN NEW.last_modified <= ';\n          trig += 'OLD.last_modified BEGIN UPDATE ';\n          trig += `${jTable.name} `;\n          trig += `SET last_modified = `;\n          trig += \"(strftime('%s','now')) WHERE id=OLD.id; END;\";\n          statements.push(trig);\n        }\n\n        if (jTable.indexes != null && jTable.indexes.length >= 1) {\n          for (const jIndex of jTable.indexes) {\n            const tableName = jTable.name;\n            let stmt = `CREATE ${Object.keys(jIndex).includes('mode') ? jIndex.mode + ' ' : ''} INDEX IF NOT EXISTS `;\n            stmt += `${jIndex.name} ON ${tableName} (${jIndex.value});`;\n            statements.push(stmt);\n          }\n        }\n\n        if (jTable.triggers != null && jTable.triggers.length >= 1) {\n          for (const jTrg of jTable.triggers) {\n            const tableName = jTable.name;\n\n            if (jTrg.timeevent.toUpperCase().endsWith(\" ON\")) {\n              jTrg.timeevent = jTrg.timeevent.substring(0, jTrg.timeevent.length - 3);\n            }\n\n            let stmt = `CREATE TRIGGER IF NOT EXISTS `;\n            stmt += `${jTrg.name} ${jTrg.timeevent} ON ${tableName} `;\n            if (jTrg.condition) stmt += `${jTrg.condition} `;\n            stmt += `${jTrg.logic};`;\n            statements.push(stmt);\n          }\n        }\n      }\n\n      return Promise.resolve(statements);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  });\n\n  return function createSchemaStatement(_x80) {\n    return _ref47.apply(this, arguments);\n  };\n}();\n\nconst createTablesData = /*#__PURE__*/function () {\n  var _ref48 = _asyncToGenerator(function* (db, jsonData, importProgress) {\n    let changes = 0;\n    let isValue = false;\n    let lastId = -1;\n    let msg = '';\n    let initChanges = -1;\n\n    try {\n      initChanges = yield dbChanges(db); // start a transaction\n\n      yield beginTransaction(db, true);\n    } catch (err) {\n      return Promise.reject(new Error(`createTablesData: ${err.message}`));\n    }\n\n    for (const jTable of jsonData.tables) {\n      if (jTable.values != null && jTable.values.length >= 1) {\n        // Create the table's data\n        try {\n          lastId = yield createDataTable(db, jTable, jsonData.mode);\n          const msg = `create table data ${jTable.name}`;\n          importProgress.emit({\n            progress: msg\n          });\n          if (lastId < 0) break;\n          isValue = true;\n        } catch (err) {\n          msg = err.message;\n          isValue = false;\n          break;\n        }\n      }\n    }\n\n    if (isValue) {\n      try {\n        yield commitTransaction(db, true);\n        changes = (yield dbChanges(db)) - initChanges;\n        return Promise.resolve(changes);\n      } catch (err) {\n        return Promise.reject(new Error('CreateTablesData: ' + `${err.message}`));\n      }\n    } else {\n      if (msg.length > 0) {\n        try {\n          yield rollbackTransaction(db, true);\n          return Promise.reject(new Error(`CreateTablesData: ${msg}`));\n        } catch (err) {\n          return Promise.reject(new Error('CreateTablesData: ' + `${err.message}: ${msg}`));\n        }\n      } else {\n        // case were no values given\n        return Promise.resolve(0);\n      }\n    }\n  });\n\n  return function createTablesData(_x81, _x82, _x83) {\n    return _ref48.apply(this, arguments);\n  };\n}();\n\nconst createDataTable = /*#__PURE__*/function () {\n  var _ref49 = _asyncToGenerator(function* (db, table, mode) {\n    let lastId = -1;\n\n    try {\n      // Check if the table exists\n      const tableExists = yield isTableExists(db, table.name);\n\n      if (!tableExists) {\n        return Promise.reject(new Error('CreateDataTable: Table ' + `${table.name} does not exist`));\n      } // Get the column names and types\n\n\n      const tableNamesTypes = yield getTableColumnNamesTypes(db, table.name);\n      const tableColumnTypes = tableNamesTypes.types;\n      const tableColumnNames = tableNamesTypes.names;\n\n      if (tableColumnTypes.length === 0) {\n        return Promise.reject(new Error('CreateDataTable: Table ' + `${table.name} info does not exist`));\n      } // Loop on Table Values\n\n\n      for (let j = 0; j < table.values.length; j++) {\n        // Check the row number of columns\n        if (table.values[j].length != tableColumnTypes.length) {\n          return Promise.reject(new Error(`CreateDataTable: Table ${table.name} ` + `values row ${j} not correct length`));\n        } // Check the column's type before proceeding\n        // remove type checking for allowing RDBMS Types\n\n        /*await checkColumnTypes(\n          tableColumnTypes,\n          table.values[j],\n        );\n        */\n\n\n        const retisIdExists = yield isIdExists(db, table.name, tableColumnNames[0], table.values[j][0]);\n        let stmt;\n\n        if (mode === 'full' || mode === 'partial' && !retisIdExists) {\n          // Insert\n          const nameString = tableColumnNames.join();\n          const questionMarkString = yield createQuestionMarkString(tableColumnNames.length);\n          stmt = `INSERT INTO ${table.name} (${nameString}) VALUES (`;\n          stmt += `${questionMarkString});`;\n        } else {\n          // Update\n          const setString = yield setNameForUpdate(tableColumnNames);\n\n          if (setString.length === 0) {\n            return Promise.reject(new Error(`CreateDataTable: Table ${table.name} ` + `values row ${j} not set to String`));\n          }\n\n          stmt = `UPDATE ${table.name} SET ${setString} WHERE `;\n\n          if (typeof table.values[j][0] == \"string\") {\n            stmt += `${tableColumnNames[0]} = '${table.values[j][0]}';`;\n          } else {\n            stmt += `${tableColumnNames[0]} = ${table.values[j][0]};`;\n          }\n        }\n\n        lastId = yield run(db, stmt, table.values[j]);\n\n        if (lastId < 0) {\n          return Promise.reject(new Error('CreateDataTable: lastId < 0'));\n        }\n      }\n\n      return Promise.resolve(lastId);\n    } catch (err) {\n      return Promise.reject(new Error(`CreateDataTable: ${err.message}`));\n    }\n  });\n\n  return function createDataTable(_x84, _x85, _x86) {\n    return _ref49.apply(this, arguments);\n  };\n}();\n\nconst isIdExists = /*#__PURE__*/function () {\n  var _ref50 = _asyncToGenerator(function* (db, dbName, firstColumnName, key) {\n    let ret = false;\n    let query = `SELECT ${firstColumnName} FROM ` + `${dbName} WHERE ${firstColumnName} = `;\n    if (typeof key === 'number') query += `${key};`;\n    if (typeof key === 'string') query += `'${key}';`;\n\n    try {\n      const resQuery = yield queryAll(db, query, []);\n      if (resQuery.length === 1) ret = true;\n      return Promise.resolve(ret);\n    } catch (err) {\n      return Promise.reject(new Error(`IsIdExists: ${err.message}`));\n    }\n  });\n\n  return function isIdExists(_x87, _x88, _x89, _x90) {\n    return _ref50.apply(this, arguments);\n  };\n}();\n\nconst isType = /*#__PURE__*/function () {\n  var _ref51 = _asyncToGenerator(function* (type, value) {\n    let ret = false;\n    if (type === 'NULL' && typeof value === 'object') ret = true;\n    if (type === 'TEXT' && typeof value === 'string') ret = true;\n    if (type === 'INTEGER' && typeof value === 'number') ret = true;\n    if (type === 'REAL' && typeof value === 'number') ret = true;\n    if (type === 'BLOB' && typeof value === 'string') ret = true;\n\n    if (ret) {\n      return Promise.resolve();\n    } else {\n      return Promise.reject(new Error('IsType: not a SQL Type'));\n    }\n  });\n\n  return function isType(_x91, _x92) {\n    return _ref51.apply(this, arguments);\n  };\n}();\n\nconst checkColumnTypes = /*#__PURE__*/function () {\n  var _ref52 = _asyncToGenerator(function* (tableTypes, rowValues) {\n    for (let i = 0; i < rowValues.length; i++) {\n      if (rowValues[i] != null) {\n        try {\n          yield isType(tableTypes[i], rowValues[i]);\n        } catch (err) {\n          return Promise.reject(new Error('CheckColumnTypes: Type not found'));\n        }\n      }\n    }\n\n    return Promise.resolve();\n  });\n\n  return function checkColumnTypes(_x93, _x94) {\n    return _ref52.apply(this, arguments);\n  };\n}();\n\nconst createQuestionMarkString = /*#__PURE__*/function () {\n  var _ref53 = _asyncToGenerator(function* (length) {\n    let retString = '';\n\n    for (let i = 0; i < length; i++) {\n      retString += '?,';\n    }\n\n    if (retString.length > 1) {\n      retString = retString.slice(0, -1);\n      return Promise.resolve(retString);\n    } else {\n      return Promise.reject(new Error('CreateQuestionMarkString: length = 0'));\n    }\n  });\n\n  return function createQuestionMarkString(_x95) {\n    return _ref53.apply(this, arguments);\n  };\n}();\n\nconst setNameForUpdate = /*#__PURE__*/function () {\n  var _ref54 = _asyncToGenerator(function* (names) {\n    let retString = '';\n\n    for (const name of names) {\n      retString += `${name} = ? ,`;\n    }\n\n    if (retString.length > 1) {\n      retString = retString.slice(0, -1);\n      return Promise.resolve(retString);\n    } else {\n      return Promise.reject(new Error('SetNameForUpdate: length = 0'));\n    }\n  });\n\n  return function setNameForUpdate(_x96) {\n    return _ref54.apply(this, arguments);\n  };\n}();\n\nconst createView = /*#__PURE__*/function () {\n  var _ref55 = _asyncToGenerator(function* (mDB, view) {\n    const stmt = `CREATE VIEW IF NOT EXISTS ${view.name} AS ${view.value};`;\n\n    try {\n      const changes = yield execute(mDB, stmt);\n\n      if (changes < 0) {\n        return Promise.reject(new Error(`CreateView: ${view.name} failed`));\n      }\n\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(new Error(`CreateView: ${err.message}`));\n    }\n  });\n\n  return function createView(_x97, _x98) {\n    return _ref55.apply(this, arguments);\n  };\n}();\n\nconst createViews = /*#__PURE__*/function () {\n  var _ref56 = _asyncToGenerator(function* (mDB, jsonData) {\n    let isView = false;\n    let msg = '';\n    let initChanges = -1;\n    let changes = -1;\n\n    try {\n      initChanges = yield dbChanges(mDB); // start a transaction\n\n      yield beginTransaction(mDB, true);\n    } catch (err) {\n      return Promise.reject(new Error(`createViews: ${err.message}`));\n    }\n\n    for (const jView of jsonData.views) {\n      if (jView.value != null) {\n        // Create the view\n        try {\n          yield createView(mDB, jView);\n          isView = true;\n        } catch (err) {\n          msg = err.message;\n          isView = false;\n          break;\n        }\n      }\n    }\n\n    if (isView) {\n      try {\n        yield commitTransaction(mDB, true);\n        changes = (yield dbChanges(mDB)) - initChanges;\n        return Promise.resolve(changes);\n      } catch (err) {\n        return Promise.reject(new Error('createViews: ' + `${err.message}`));\n      }\n    } else {\n      if (msg.length > 0) {\n        try {\n          yield rollbackTransaction(mDB, true);\n          return Promise.reject(new Error(`createViews: ${msg}`));\n        } catch (err) {\n          return Promise.reject(new Error('createViews: ' + `${err.message}: ${msg}`));\n        }\n      } else {\n        // case were no views given\n        return Promise.resolve(0);\n      }\n    }\n  });\n\n  return function createViews(_x99, _x100) {\n    return _ref56.apply(this, arguments);\n  };\n}();\n\nconst createExportObject = /*#__PURE__*/function () {\n  var _ref57 = _asyncToGenerator(function* (db, sqlObj, exportProgress) {\n    const retObj = {};\n    let tables = [];\n    let views = [];\n    let errmsg = '';\n\n    try {\n      // get View's name\n      views = yield getViewsName(db); // get Table's name\n\n      const resTables = yield getTablesNameSQL(db);\n\n      if (resTables.length === 0) {\n        return Promise.reject(new Error(\"createExportObject: table's names failed\"));\n      } else {\n        switch (sqlObj.mode) {\n          case 'partial':\n            {\n              tables = yield getTablesPartial(db, resTables, exportProgress);\n              break;\n            }\n\n          case 'full':\n            {\n              tables = yield getTablesFull(db, resTables, exportProgress);\n              break;\n            }\n\n          default:\n            {\n              errmsg = 'createExportObject: expMode ' + sqlObj.mode + ' not defined';\n              break;\n            }\n        }\n\n        if (errmsg.length > 0) {\n          return Promise.reject(new Error(errmsg));\n        }\n\n        if (tables.length > 0) {\n          retObj.database = sqlObj.database;\n          retObj.version = sqlObj.version;\n          retObj.encrypted = sqlObj.encrypted;\n          retObj.mode = sqlObj.mode;\n          retObj.tables = tables;\n\n          if (views.length > 0) {\n            retObj.views = views;\n          }\n        }\n\n        return Promise.resolve(retObj);\n      }\n    } catch (err) {\n      return Promise.reject(new Error('createExportObject: ' + err.message));\n    }\n  });\n\n  return function createExportObject(_x101, _x102, _x103) {\n    return _ref57.apply(this, arguments);\n  };\n}();\n\nconst getTablesNameSQL = /*#__PURE__*/function () {\n  var _ref58 = _asyncToGenerator(function* (db) {\n    let sql = 'SELECT name,sql FROM sqlite_master WHERE ';\n    sql += \"type='table' AND name NOT LIKE 'sync_table' \";\n    sql += \"AND name NOT LIKE '_temp_%' \";\n    sql += \"AND name NOT LIKE 'sqlite_%';\";\n\n    try {\n      const retQuery = yield queryAll(db, sql, []);\n      return Promise.resolve(retQuery);\n    } catch (err) {\n      return Promise.reject(new Error(`getTablesNames: ${err.message}`));\n    }\n  });\n\n  return function getTablesNameSQL(_x104) {\n    return _ref58.apply(this, arguments);\n  };\n}();\n\nconst getViewsName = /*#__PURE__*/function () {\n  var _ref59 = _asyncToGenerator(function* (mDb) {\n    const views = [];\n    let sql = 'SELECT name,sql FROM sqlite_master WHERE ';\n    sql += \"type='view' AND name NOT LIKE 'sqlite_%';\";\n    let retQuery = [];\n\n    try {\n      retQuery = yield queryAll(mDb, sql, []);\n\n      for (const query of retQuery) {\n        const view = {};\n        view.name = query.name;\n        view.value = query.sql.substring(query.sql.indexOf('AS ') + 3);\n        views.push(view);\n      }\n\n      return Promise.resolve(views);\n    } catch (err) {\n      return Promise.reject(new Error(`getViewsName: ${err.message}`));\n    }\n  });\n\n  return function getViewsName(_x105) {\n    return _ref59.apply(this, arguments);\n  };\n}();\n\nconst getTablesFull = /*#__PURE__*/function () {\n  var _ref60 = _asyncToGenerator(function* (db, resTables, exportProgress) {\n    const tables = [];\n    let errmsg = '';\n\n    try {\n      // Loop through the tables\n      for (const rTable of resTables) {\n        let tableName;\n        let sqlStmt;\n\n        if (rTable.name) {\n          tableName = rTable.name;\n        } else {\n          errmsg = 'GetTablesFull: no name';\n          break;\n        }\n\n        if (rTable.sql) {\n          sqlStmt = rTable.sql;\n        } else {\n          errmsg = 'GetTablesFull: no sql';\n          break;\n        }\n\n        const table = {}; // create Table's Schema\n\n        const schema = yield getSchema(sqlStmt\n        /*, tableName*/\n        );\n\n        if (schema.length === 0) {\n          errmsg = 'GetTablesFull: no Schema returned';\n          break;\n        } // check schema validity\n\n\n        yield checkSchemaValidity(schema); // create Table's indexes if any\n\n        const indexes = yield getIndexes(db, tableName);\n\n        if (indexes.length > 0) {\n          // check indexes validity\n          yield checkIndexesValidity(indexes);\n        } // create Table's triggers if any\n\n\n        const triggers = yield getTriggers(db, tableName);\n\n        if (triggers.length > 0) {\n          // check triggers validity\n          yield checkTriggersValidity(triggers);\n        }\n\n        let msg = `Full: Table ${tableName} schema export completed ...`;\n        exportProgress.emit({\n          progress: msg\n        }); // create Table's Data\n\n        const query = `SELECT * FROM ${tableName};`;\n        const values = yield getValues(db, query, tableName);\n        table.name = tableName;\n\n        if (schema.length > 0) {\n          table.schema = schema;\n        } else {\n          errmsg = `GetTablesFull: must contain schema`;\n          break;\n        }\n\n        if (indexes.length > 0) {\n          table.indexes = indexes;\n        }\n\n        if (triggers.length > 0) {\n          table.triggers = triggers;\n        }\n\n        if (values.length > 0) {\n          table.values = values;\n        }\n\n        if (Object.keys(table).length <= 1) {\n          errmsg = `GetTablesFull: table ${tableName} is not a jsonTable`;\n          break;\n        }\n\n        msg = `Full: Table ${tableName} table data export completed ...`;\n        exportProgress.emit({\n          progress: msg\n        });\n        tables.push(table);\n      }\n\n      if (errmsg.length > 0) {\n        return Promise.reject(new Error(errmsg));\n      }\n\n      return Promise.resolve(tables);\n    } catch (err) {\n      return Promise.reject(new Error(`GetTablesFull: ${err.message}`));\n    }\n  });\n\n  return function getTablesFull(_x106, _x107, _x108) {\n    return _ref60.apply(this, arguments);\n  };\n}();\n\nconst getSchema = /*#__PURE__*/function () {\n  var _ref61 = _asyncToGenerator(function* (sqlStmt\n  /*, tableName: string*/\n  ) {\n    const schema = []; // take the substring between parenthesis\n\n    const openPar = sqlStmt.indexOf('(');\n    const closePar = sqlStmt.lastIndexOf(')');\n    let sstr = sqlStmt.substring(openPar + 1, closePar); // check if there is other parenthesis and replace the ',' by ''\n\n    try {\n      sstr = yield modEmbeddedParentheses(sstr);\n      const sch = sstr.split(\",\"); // for each element of the array split the\n      // first word as key\n\n      for (let j = 0; j < sch.length; j++) {\n        let row = [];\n        const scht = sch[j].trim();\n        row[0] = scht.substring(0, scht.indexOf(\" \"));\n        row[1] = scht.substring(scht.indexOf(\" \") + 1);\n        const jsonRow = {};\n\n        if (row[0].toUpperCase() === \"FOREIGN\") {\n          const oPar = sch[j].indexOf(\"(\");\n          const cPar = sch[j].indexOf(\")\");\n          row[0] = sch[j].substring(oPar + 1, cPar);\n          row[1] = sch[j].substring(cPar + 2);\n          jsonRow['foreignkey'] = row[0];\n        } else if (row[0].toUpperCase() === \"CONSTRAINT\") {\n          let tRow = [];\n          const row1t = row[1].trim();\n          tRow[0] = row1t.substring(0, row1t.indexOf(\" \"));\n          tRow[1] = row1t.substring(row1t.indexOf(\" \") + 1);\n          row[0] = tRow[0];\n          jsonRow['constraint'] = row[0];\n          row[1] = tRow[1];\n        } else {\n          jsonRow['column'] = row[0];\n        }\n\n        jsonRow['value'] = row[1].replace(//g, \",\");\n        schema.push(jsonRow);\n      }\n\n      return Promise.resolve(schema);\n    } catch (err) {\n      return Promise.reject(new Error(err.message));\n    }\n  });\n\n  return function getSchema(_x109) {\n    return _ref61.apply(this, arguments);\n  };\n}();\n\nconst getIndexes = /*#__PURE__*/function () {\n  var _ref62 = _asyncToGenerator(function* (db, tableName) {\n    const indexes = [];\n    let errmsg = '';\n\n    try {\n      let stmt = 'SELECT name,tbl_name,sql FROM sqlite_master WHERE ';\n      stmt += `type = 'index' AND tbl_name = '${tableName}' `;\n      stmt += `AND sql NOTNULL;`;\n      const retIndexes = yield queryAll(db, stmt, []);\n\n      if (retIndexes.length > 0) {\n        for (const rIndex of retIndexes) {\n          const keys = Object.keys(rIndex);\n\n          if (keys.length === 3) {\n            if (rIndex['tbl_name'] === tableName) {\n              const sql = rIndex['sql'];\n              const mode = sql.includes('UNIQUE') ? 'UNIQUE' : '';\n              const oPar = sql.lastIndexOf('(');\n              const cPar = sql.lastIndexOf(')');\n              const index = {};\n              index.name = rIndex['name'];\n              index.value = sql.slice(oPar + 1, cPar);\n              if (mode.length > 0) index.mode = mode;\n              indexes.push(index);\n            } else {\n              errmsg = `GetIndexes: Table ${tableName} doesn't match`;\n              break;\n            }\n          } else {\n            errmsg = `GetIndexes: Table ${tableName} creating indexes`;\n            break;\n          }\n        }\n\n        if (errmsg.length > 0) {\n          return Promise.reject(new Error(errmsg));\n        }\n      }\n\n      return Promise.resolve(indexes);\n    } catch (err) {\n      return Promise.reject(new Error(`GetIndexes: ${err.message}`));\n    }\n  });\n\n  return function getIndexes(_x110, _x111) {\n    return _ref62.apply(this, arguments);\n  };\n}();\n\nconst getTriggers = /*#__PURE__*/function () {\n  var _ref63 = _asyncToGenerator(function* (db, tableName) {\n    const triggers = [];\n\n    try {\n      let stmt = 'SELECT name,tbl_name,sql FROM sqlite_master WHERE ';\n      stmt += `type = 'trigger' AND tbl_name = '${tableName}' `;\n      stmt += `AND sql NOT NULL;`;\n      const retTriggers = yield queryAll(db, stmt, []);\n\n      if (retTriggers.length > 0) {\n        for (const rTrg of retTriggers) {\n          const keys = Object.keys(rTrg);\n\n          if (keys.length === 3) {\n            if (rTrg['tbl_name'] === tableName) {\n              const sql = rTrg['sql'];\n              const name = rTrg['name'];\n              let sqlArr = sql.split(name);\n\n              if (sqlArr.length != 2) {\n                return Promise.reject(new Error(`GetTriggers: sql split name does not return 2 values`));\n              }\n\n              if (!sqlArr[1].includes(tableName)) {\n                return Promise.reject(new Error(`GetTriggers: sql split does not contains ${tableName}`));\n              }\n\n              const timeEvent = sqlArr[1].split(tableName, 1)[0].trim();\n              sqlArr = sqlArr[1].split(timeEvent + ' ' + tableName);\n\n              if (sqlArr.length != 2) {\n                return Promise.reject(new Error(`GetTriggers: sql split tableName does not return 2 values`));\n              }\n\n              let condition = '';\n              let logic = '';\n\n              if (sqlArr[1].trim().substring(0, 5).toUpperCase() !== 'BEGIN') {\n                sqlArr = sqlArr[1].trim().split('BEGIN');\n\n                if (sqlArr.length != 2) {\n                  return Promise.reject(new Error(`GetTriggers: sql split BEGIN does not return 2 values`));\n                }\n\n                condition = sqlArr[0].trim();\n                logic = 'BEGIN' + sqlArr[1];\n              } else {\n                logic = sqlArr[1].trim();\n              }\n\n              const trigger = {};\n              trigger.name = name;\n              trigger.logic = logic;\n              if (condition.length > 0) trigger.condition = condition;\n              trigger.timeevent = timeEvent;\n              triggers.push(trigger);\n            } else {\n              return Promise.reject(new Error(`GetTriggers: Table ${tableName} doesn't match`));\n            }\n          } else {\n            return Promise.reject(new Error(`GetTriggers: Table ${tableName} creating indexes`));\n          }\n        }\n      }\n\n      return Promise.resolve(triggers);\n    } catch (err) {\n      return Promise.reject(new Error(`GetTriggers: ${err.message}`));\n    }\n  });\n\n  return function getTriggers(_x112, _x113) {\n    return _ref63.apply(this, arguments);\n  };\n}();\n\nconst getValues = /*#__PURE__*/function () {\n  var _ref64 = _asyncToGenerator(function* (db, query, tableName) {\n    const values = [];\n\n    try {\n      // get table column names and types\n      const tableNamesTypes = yield getTableColumnNamesTypes(db, tableName);\n      let rowNames = [];\n\n      if (Object.keys(tableNamesTypes).includes('names')) {\n        rowNames = tableNamesTypes.names;\n      } else {\n        return Promise.reject(new Error(`GetValues: Table ${tableName} no names`));\n      }\n\n      const retValues = yield queryAll(db, query, []);\n\n      for (const rValue of retValues) {\n        const row = [];\n\n        for (const rName of rowNames) {\n          if (Object.keys(rValue).includes(rName)) {\n            row.push(rValue[rName]);\n          } else {\n            row.push(null);\n          }\n        }\n\n        values.push(row);\n      }\n\n      return Promise.resolve(values);\n    } catch (err) {\n      return Promise.reject(new Error(`GetValues: ${err.message}`));\n    }\n  });\n\n  return function getValues(_x114, _x115, _x116) {\n    return _ref64.apply(this, arguments);\n  };\n}();\n\nconst getTablesPartial = /*#__PURE__*/function () {\n  var _ref65 = _asyncToGenerator(function* (db, resTables, exportProgress) {\n    const tables = [];\n    let modTables = {};\n    let syncDate = 0;\n    let modTablesKeys = [];\n    let errmsg = '';\n\n    try {\n      // Get the syncDate and the Modified Tables\n      const partialModeData = yield getPartialModeData(db, resTables);\n\n      if (Object.keys(partialModeData).includes('syncDate')) {\n        syncDate = partialModeData.syncDate;\n      }\n\n      if (Object.keys(partialModeData).includes('modTables')) {\n        modTables = partialModeData.modTables;\n        modTablesKeys = Object.keys(modTables);\n      } // Loop trough tables\n\n\n      for (const rTable of resTables) {\n        let tableName = '';\n        let sqlStmt = '';\n\n        if (rTable.name) {\n          tableName = rTable.name;\n        } else {\n          errmsg = 'GetTablesFull: no name';\n          break;\n        }\n\n        if (rTable.sql) {\n          sqlStmt = rTable.sql;\n        } else {\n          errmsg = 'GetTablesFull: no sql';\n          break;\n        }\n\n        if (modTablesKeys.length == 0 || modTablesKeys.indexOf(tableName) === -1 || modTables[tableName] == 'No') {\n          continue;\n        }\n\n        const table = {};\n        let schema = [];\n        let indexes = [];\n        let triggers = [];\n        table.name = rTable;\n\n        if (modTables[table.name] === 'Create') {\n          // create Table's Schema\n          schema = yield getSchema(sqlStmt\n          /*, tableName*/\n          );\n\n          if (schema.length > 0) {\n            // check schema validity\n            yield checkSchemaValidity(schema);\n          } // create Table's indexes if any\n\n\n          indexes = yield getIndexes(db, tableName);\n\n          if (indexes.length > 0) {\n            // check indexes validity\n            yield checkIndexesValidity(indexes);\n          } // create Table's triggers if any\n\n\n          triggers = yield getTriggers(db, tableName);\n\n          if (triggers.length > 0) {\n            // check triggers validity\n            yield checkTriggersValidity(triggers);\n          }\n        }\n\n        let msg = `Partial: Table ${tableName} schema export completed ...`;\n        exportProgress.emit({\n          progress: msg\n        }); // create Table's Data\n\n        let query = '';\n\n        if (modTables[tableName] === 'Create') {\n          query = `SELECT * FROM ${tableName};`;\n        } else {\n          query = `SELECT * FROM ${tableName} ` + `WHERE last_modified > ${syncDate};`;\n        }\n\n        const values = yield getValues(db, query, tableName); // check the table object validity\n\n        table.name = tableName;\n\n        if (schema.length > 0) {\n          table.schema = schema;\n        }\n\n        if (indexes.length > 0) {\n          table.indexes = indexes;\n        }\n\n        if (triggers.length > 0) {\n          table.triggers = triggers;\n        }\n\n        if (values.length > 0) {\n          table.values = values;\n        }\n\n        if (Object.keys(table).length <= 1) {\n          errmsg = `GetTablesPartial: table ${tableName} is not a jsonTable`;\n          break;\n        }\n\n        msg = `Partial: Table ${tableName} table data export completed ...`;\n        exportProgress.emit({\n          progress: msg\n        });\n        tables.push(table);\n      }\n\n      if (errmsg.length > 0) {\n        return Promise.reject(new Error(errmsg));\n      }\n\n      return Promise.resolve(tables);\n    } catch (err) {\n      return Promise.reject(new Error(`GetTablesPartial: ${err.message}`));\n    }\n  });\n\n  return function getTablesPartial(_x117, _x118, _x119) {\n    return _ref65.apply(this, arguments);\n  };\n}();\n\nconst getPartialModeData = /*#__PURE__*/function () {\n  var _ref66 = _asyncToGenerator(function* (db, resTables) {\n    const retData = {};\n\n    try {\n      // get the synchronization date\n      const syncDate = yield getSynchroDate(db);\n\n      if (syncDate <= 0) {\n        return Promise.reject(new Error(`GetPartialModeData: no syncDate`));\n      } // get the tables which have been updated\n      // since last synchronization\n\n\n      const modTables = yield getTablesModified(db, resTables, syncDate);\n\n      if (modTables.length <= 0) {\n        return Promise.reject(new Error(`GetPartialModeData: no modTables`));\n      }\n\n      retData.syncDate = syncDate;\n      retData.modTables = modTables;\n      return Promise.resolve(retData);\n    } catch (err) {\n      return Promise.reject(new Error(`GetPartialModeData: ${err.message}`));\n    }\n  });\n\n  return function getPartialModeData(_x120, _x121) {\n    return _ref66.apply(this, arguments);\n  };\n}();\n\nconst getTablesModified = /*#__PURE__*/function () {\n  var _ref67 = _asyncToGenerator(function* (db, tables, syncDate) {\n    let errmsg = '';\n\n    try {\n      const retModified = {};\n\n      for (const rTable of tables) {\n        let mode; // get total count of the table\n\n        let stmt = 'SELECT count(*) AS tcount  ';\n        stmt += `FROM ${rTable.name};`;\n        let retQuery = yield queryAll(db, stmt, []);\n\n        if (retQuery.length != 1) {\n          errmsg = 'GetTableModified: total ' + 'count not returned';\n          break;\n        }\n\n        const totalCount = retQuery[0]['tcount']; // get total count of modified since last sync\n\n        stmt = 'SELECT count(*) AS mcount FROM ';\n        stmt += `${rTable.name} WHERE last_modified > `;\n        stmt += `${syncDate};`;\n        retQuery = yield queryAll(db, stmt, []);\n        if (retQuery.length != 1) break;\n        const totalModifiedCount = retQuery[0]['mcount'];\n\n        if (totalModifiedCount === 0) {\n          mode = 'No';\n        } else if (totalCount === totalModifiedCount) {\n          mode = 'Create';\n        } else {\n          mode = 'Modified';\n        }\n\n        const key = rTable.name;\n        retModified[key] = mode;\n      }\n\n      if (errmsg.length > 0) {\n        return Promise.reject(new Error(errmsg));\n      }\n\n      return Promise.resolve(retModified);\n    } catch (err) {\n      return Promise.reject(new Error(`GetTableModified: ${err.message}`));\n    }\n  });\n\n  return function getTablesModified(_x122, _x123, _x124) {\n    return _ref67.apply(this, arguments);\n  };\n}();\n\nconst getSynchroDate = /*#__PURE__*/function () {\n  var _ref68 = _asyncToGenerator(function* (db) {\n    try {\n      const stmt = `SELECT sync_date FROM sync_table;`;\n      const res = yield queryAll(db, stmt, []);\n      return Promise.resolve(res[0][\"sync_date\"]);\n    } catch (err) {\n      const msg = `getSyncDate: ${err.message}`;\n      return Promise.reject(new Error(msg));\n    }\n  });\n\n  return function getSynchroDate(_x125) {\n    return _ref68.apply(this, arguments);\n  };\n}();\n\nconst modEmbeddedParentheses = /*#__PURE__*/function () {\n  var _ref69 = _asyncToGenerator(function* (sstr) {\n    const oParArray = indexOfChar(sstr, '(');\n    const cParArray = indexOfChar(sstr, ')');\n\n    if (oParArray.length != cParArray.length) {\n      return Promise.reject(\"ModEmbeddedParentheses: Not same number of '(' & ')'\");\n    }\n\n    if (oParArray.length === 0) {\n      return Promise.resolve(sstr);\n    }\n\n    let resStmt = sstr.substring(0, oParArray[0] - 1);\n\n    for (let i = 0; i < oParArray.length; i++) {\n      let str;\n\n      if (i < oParArray.length - 1) {\n        if (oParArray[i + 1] < cParArray[i]) {\n          str = sstr.substring(oParArray[i] - 1, cParArray[i + 1]);\n          i++;\n        } else {\n          str = sstr.substring(oParArray[i] - 1, cParArray[i]);\n        }\n      } else {\n        str = sstr.substring(oParArray[i] - 1, cParArray[i]);\n      }\n\n      const newS = str.replace(/,/g, \"\");\n      resStmt += newS;\n\n      if (i < oParArray.length - 1) {\n        resStmt += sstr.substring(cParArray[i], oParArray[i + 1] - 1);\n      }\n    }\n\n    resStmt += sstr.substring(cParArray[cParArray.length - 1], sstr.length);\n    return Promise.resolve(resStmt);\n  });\n\n  return function modEmbeddedParentheses(_x126) {\n    return _ref69.apply(this, arguments);\n  };\n}();\n\nconst indexOfChar = (str, char) => {\n  let tmpArr = [...str];\n  char = char.toLowerCase();\n  return tmpArr.reduce((results, elem, idx) => elem.toLowerCase() === char ? [...results, idx] : results, []);\n};\n\nconst onUpgrade = /*#__PURE__*/function () {\n  var _ref70 = _asyncToGenerator(function* (mDb, vUpgDict, dbName, curVersion, targetVersion, store) {\n    let changes = -1;\n    const upgrade = vUpgDict[curVersion];\n\n    if (upgrade != null) {\n      const keys = Object.keys(upgrade);\n\n      if (!keys.includes('toVersion')) {\n        return Promise.reject(new Error('onUpgrade: toVersion not given'));\n      }\n\n      const toVersion = upgrade.toVersion;\n\n      if (!keys.includes('statement')) {\n        return Promise.reject(new Error('onUpgrade: statement not given'));\n      }\n\n      const statement = upgrade.statement;\n      let set = [];\n\n      if (keys.includes('set')) {\n        set = upgrade.set;\n      }\n\n      if (targetVersion < toVersion) {\n        let msg = 'Error: version mistmatch ';\n        msg += 'Upgrade Statement would upgrade to ';\n        msg += `version ${toVersion} , but target version `;\n        msg += `is ${targetVersion} for database ${dbName}`;\n        msg += ` and version ${curVersion}`;\n        return Promise.reject(new Error(`onUpgrade: ${msg}`));\n      }\n\n      try {\n        // set Foreign Keys Off\n        yield setForeignKeyConstraintsEnabled(mDb, false); // copy the db\n\n        yield copyDBToStore(dbName, `backup-${dbName}`, store);\n        const initChanges = yield dbChanges(mDb); // Here we assume that all table schemas are given\n        // in the upgrade statement\n\n        if (statement.length > 0) {\n          yield executeStatementProcess(mDb, statement); // save the database to store\n\n          yield setDBToStore(mDb, dbName, store); // Here we assume that the Set contains only\n          // - the data for new tables\n          //   as INSERT statements\n          // - the data for new columns in existing tables\n          //   as UPDATE statements\n\n          if (set.length > 0) {\n            yield executeSetProcess(mDb, set, toVersion); // save the database to store\n\n            yield setDBToStore(mDb, dbName, store);\n          }\n        } // set Foreign Keys On\n\n\n        yield setForeignKeyConstraintsEnabled(mDb, true);\n        changes = (yield dbChanges(mDb)) - initChanges; // save the database to store\n\n        yield setDBToStore(mDb, dbName, store);\n        return Promise.resolve(changes);\n      } catch (err) {\n        return Promise.reject(new Error(`onUpgrade: ${err.message}`));\n      }\n    } else {\n      return Promise.reject(new Error('onUpgrade: upgrade not found'));\n    }\n  });\n\n  return function onUpgrade(_x127, _x128, _x129, _x130, _x131, _x132) {\n    return _ref70.apply(this, arguments);\n  };\n}();\n\nconst executeStatementProcess = /*#__PURE__*/function () {\n  var _ref71 = _asyncToGenerator(function* (mDb, statement) {\n    try {\n      // -> backup all existing tables  \"tableName\" in\n      //    \"temp_tableName\"\n      const alterTables = yield backupTables(mDb); // -> Drop all Indexes\n\n      yield dropElements(mDb, 'index'); // -> Drop all Triggers\n\n      yield dropElements(mDb, 'trigger'); // -> Create new tables from upgrade.statement\n\n      const changes = yield execute(mDb, statement);\n\n      if (changes < 0) {\n        return Promise.reject(new Error('ExecuteStatementProcess: ' + 'changes < 0'));\n      } // -> Create the list of table's common fields\n\n\n      const commonColumns = yield findCommonColumns(mDb, alterTables); // -> Update the new table's data from old table's data\n\n      if (Object.keys(commonColumns).length > 0) {\n        yield updateNewTablesData(mDb, commonColumns);\n      } // -> Drop _temp_tables\n\n\n      yield dropTempTables(mDb, alterTables);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(new Error(`ExecuteStatementProcess: ${err.message}`));\n    }\n  });\n\n  return function executeStatementProcess(_x133, _x134) {\n    return _ref71.apply(this, arguments);\n  };\n}();\n\nconst executeSetProcess = /*#__PURE__*/function () {\n  var _ref72 = _asyncToGenerator(function* (mDb, set, toVersion) {\n    try {\n      // -> load new data\n      const lastId = yield executeSet(mDb, set);\n\n      if (lastId < 0) {\n        return Promise.reject(new Error('ExecuteSetProcess: lastId ' + '< 0'));\n      } // -> update database version\n\n\n      yield setVersion(mDb, toVersion); // -> update syncDate if any\n\n      const retB = yield isTableExists(mDb, 'sync_table');\n\n      if (retB) {\n        const sDate = Math.round(new Date().getTime() / 1000);\n        let stmt = 'UPDATE sync_table SET ';\n        stmt += `sync_date = ${sDate} WHERE id = 1;`;\n        const changes = yield execute(mDb, stmt);\n\n        if (changes < 0) {\n          return Promise.reject(new Error('ExecuteSetProcess: changes ' + '< 0'));\n        }\n      }\n\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(new Error(`ExecuteSetProcess: ${err.message}`));\n    }\n  });\n\n  return function executeSetProcess(_x135, _x136, _x137) {\n    return _ref72.apply(this, arguments);\n  };\n}();\n\nclass Database {\n  constructor(databaseName, version, upgDict, store) {\n    this.vUpgDict = {};\n    this.dbName = databaseName;\n    this.store = store;\n    this.version = version;\n    this.mDb = null;\n    this.vUpgDict = upgDict;\n    this._isDBOpen = false;\n  }\n\n  open() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const SQL = yield sqlWasm({\n          locateFile: file => `assets/${file}`\n        }); // retrieve the database if stored on localforage\n\n        const retDB = yield getDBFromStore(_this.dbName, _this.store);\n\n        if (retDB != null) {\n          // Open existing database\n          _this.mDb = new SQL.Database(retDB);\n        } else {\n          // Create a new database\n          _this.mDb = new SQL.Database();\n          yield setInitialDBToStore(_this.dbName, _this.store);\n        } // get the current version\n\n\n        let curVersion = yield getVersion(_this.mDb);\n\n        if (curVersion === 0) {\n          yield setVersion(_this.mDb, 1);\n          curVersion = yield getVersion(_this.mDb);\n        }\n\n        _this._isDBOpen = true;\n\n        if (_this.version > curVersion) {\n          const keys = Object.keys(_this.vUpgDict);\n\n          if (keys.length > 0) {\n            try {\n              // execute the upgrade flow process\n              const changes = yield onUpgrade(_this.mDb, _this.vUpgDict, _this.dbName, curVersion, _this.version, _this.store);\n\n              if (changes === -1) {\n                // restore the database from backup\n                try {\n                  yield restoreDBFromStore(_this.dbName, 'backup', _this.store);\n                } catch (err) {\n                  return Promise.reject(new Error(`Open: ${err.message}`));\n                }\n              } // delete the backup database\n\n\n              yield removeDBFromStore(`backup-${_this.dbName}`, _this.store);\n            } catch (err) {\n              // restore the database from backup\n              try {\n                yield restoreDBFromStore(_this.dbName, 'backup', _this.store);\n              } catch (err) {\n                return Promise.reject(new Error(`Open: ${err.message}`));\n              }\n            }\n          } else {\n            try {\n              yield setVersion(_this.mDb, _this.version);\n            } catch (err) {\n              return Promise.reject(new Error(`SetVersion: ${_this.version} ${err.message}`));\n            }\n          }\n        }\n\n        return Promise.resolve();\n      } catch (err) {\n        _this._isDBOpen = false;\n        return Promise.reject(`in open ${err}`);\n      }\n    })();\n  }\n\n  isDBOpen() {\n    return this._isDBOpen;\n  }\n\n  close() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2.mDb != null && _this2._isDBOpen) {\n        try {\n          // save the database to store\n          yield setDBToStore(_this2.mDb, _this2.dbName, _this2.store); // close the database\n\n          _this2.mDb.close();\n\n          _this2._isDBOpen = false;\n        } catch (err) {\n          _this2._isDBOpen = false;\n          return Promise.reject(`in close ${err}`);\n        }\n      }\n\n      return Promise.resolve();\n    })();\n  }\n\n  saveToStore() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this3.mDb != null && _this3._isDBOpen) {\n        try {\n          // save the database to store\n          yield setDBToStore(_this3.mDb, _this3.dbName, _this3.store);\n        } catch (err) {\n          return Promise.reject(`in saveToStore ${err}`);\n        }\n      }\n\n      return Promise.resolve();\n    })();\n  }\n\n  getVersion() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this4.mDb != null && _this4._isDBOpen) {\n        try {\n          // save the database to store\n          const curVersion = yield getVersion(_this4.mDb);\n          return Promise.resolve(curVersion);\n        } catch (err) {\n          _this4._isDBOpen = false;\n          return Promise.reject(`in getVersion ${err}`);\n        }\n      }\n    })();\n  }\n\n  isDBExists(database) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const isExists = yield isDBInStore(database, _this5.store);\n        return Promise.resolve(isExists);\n      } catch (err) {\n        return Promise.reject(`in isDBExists ${err}`);\n      }\n    })();\n  }\n\n  deleteDB(database) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        // test if file exists\n        const isExists = yield _this6.isDBExists(database);\n\n        if (isExists && !_this6._isDBOpen) {\n          // open the database\n          yield _this6.open();\n        } // close the database\n\n\n        yield _this6.close(); // delete the database\n\n        if (isExists) {\n          yield removeDBFromStore(database, _this6.store);\n        }\n\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(new Error(`DeleteDB: ${err.message}`));\n      }\n    })();\n  }\n\n  executeSQL(sql, transaction = true) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this7._isDBOpen) {\n        let msg = `ExecuteSQL: Database ${_this7.dbName} `;\n        msg += `not opened`;\n        return Promise.reject(new Error(msg));\n      }\n\n      try {\n        if (transaction) yield beginTransaction(_this7.mDb, _this7._isDBOpen);\n        const changes = yield execute(_this7.mDb, sql);\n\n        if (changes < 0) {\n          return Promise.reject(new Error('ExecuteSQL: changes < 0'));\n        }\n\n        if (transaction) yield commitTransaction(_this7.mDb, _this7._isDBOpen);\n        return Promise.resolve(changes);\n      } catch (err) {\n        let msg = `ExecuteSQL: ${err.message}`;\n\n        try {\n          if (transaction) yield rollbackTransaction(_this7.mDb, _this7._isDBOpen);\n        } catch (err) {\n          msg += ` : ${err.message}`;\n        }\n\n        return Promise.reject(new Error(`ExecuteSQL: ${msg}`));\n      }\n    })();\n  }\n\n  execSet(set, transaction = true) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this8._isDBOpen) {\n        let msg = `ExecSet: Database ${_this8.dbName} `;\n        msg += `not opened`;\n        return Promise.reject(new Error(msg));\n      }\n\n      const retRes = {\n        changes: -1,\n        lastId: -1\n      };\n      let initChanges = -1;\n\n      try {\n        initChanges = yield dbChanges(_this8.mDb);\n        if (transaction) yield beginTransaction(_this8.mDb, _this8._isDBOpen);\n        const lastId = yield executeSet(_this8.mDb, set);\n\n        if (lastId < 0) {\n          return Promise.reject(new Error('ExecSet: changes < 0'));\n        }\n\n        if (transaction) yield commitTransaction(_this8.mDb, _this8._isDBOpen);\n        const changes = (yield dbChanges(_this8.mDb)) - initChanges;\n        retRes.changes = changes;\n        retRes.lastId = lastId;\n        return Promise.resolve(retRes);\n      } catch (err) {\n        let msg = `ExecSet: ${err.message}`;\n\n        try {\n          if (transaction) yield rollbackTransaction(_this8.mDb, _this8._isDBOpen);\n        } catch (err) {\n          msg += ` : ${err.message}`;\n        }\n\n        return Promise.reject(new Error(`ExecSet: ${msg}`));\n      }\n    })();\n  }\n\n  selectSQL(sql, values) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this9._isDBOpen) {\n        let msg = `SelectSQL: Database ${_this9.dbName} `;\n        msg += `not opened`;\n        return Promise.reject(new Error(msg));\n      }\n\n      try {\n        let retArr = yield queryAll(_this9.mDb, sql, values);\n        return Promise.resolve(retArr);\n      } catch (err) {\n        return Promise.reject(new Error(`SelectSQL: ${err.message}`));\n      }\n    })();\n  }\n\n  runSQL(statement, values, transaction = true) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this10._isDBOpen) {\n        let msg = `RunSQL: Database ${_this10.dbName} `;\n        msg += `not opened`;\n        return Promise.reject(new Error(msg));\n      }\n\n      const retRes = {\n        changes: -1,\n        lastId: -1\n      };\n      let initChanges = -1;\n\n      try {\n        initChanges = yield dbChanges(_this10.mDb);\n        if (transaction) yield beginTransaction(_this10.mDb, _this10._isDBOpen);\n        const lastId = yield run(_this10.mDb, statement, values);\n\n        if (lastId < 0) {\n          return Promise.reject(new Error('RunSQL: lastId < 0'));\n        }\n\n        if (transaction) yield commitTransaction(_this10.mDb, _this10._isDBOpen);\n        const changes = (yield dbChanges(_this10.mDb)) - initChanges;\n        retRes.changes = changes;\n        retRes.lastId = lastId;\n        return Promise.resolve(retRes);\n      } catch (err) {\n        let msg = `RunSQL: ${err.message}`;\n\n        try {\n          if (transaction) yield rollbackTransaction(_this10.mDb, _this10._isDBOpen);\n        } catch (err) {\n          msg += ` : ${err.message}`;\n        }\n\n        return Promise.reject(new Error(`RunSQL: ${msg}`));\n      }\n    })();\n  }\n\n  isTable(tableName) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this11._isDBOpen) {\n        let msg = `isTable: Database ${_this11.dbName} `;\n        msg += `not opened`;\n        return Promise.reject(new Error(msg));\n      }\n\n      try {\n        const retB = yield isTableExists(_this11.mDb, tableName);\n        return Promise.resolve(retB);\n      } catch (err) {\n        const msg = `IsTable: ${err.message}`;\n        return Promise.reject(new Error(msg));\n      }\n    })();\n  }\n\n  createSyncTable() {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this12._isDBOpen) {\n        let msg = `createSyncTable: Database ${_this12.dbName} `;\n        msg += `not opened`;\n        return Promise.reject(new Error(msg));\n      }\n\n      let changes = -1;\n\n      try {\n        const retB = yield isTableExists(_this12.mDb, 'sync_table');\n\n        if (!retB) {\n          const date = Math.round(new Date().getTime() / 1000);\n          let stmts = `\n                        CREATE TABLE IF NOT EXISTS sync_table (\n                            id INTEGER PRIMARY KEY NOT NULL,\n                            sync_date INTEGER\n                            );`;\n          stmts += `INSERT INTO sync_table (sync_date) VALUES (\n                            \"${date}\");`;\n          changes = yield execute(_this12.mDb, stmts);\n          return Promise.resolve(changes);\n        } else {\n          return Promise.resolve(0);\n        }\n      } catch (err) {\n        const msg = `CreateSyncTable: ${err.message}`;\n        return Promise.reject(new Error(msg));\n      }\n    })();\n  }\n\n  getSyncDate() {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this13._isDBOpen) {\n        let msg = `getSyncDate: Database ${_this13.dbName} `;\n        msg += `not opened`;\n        return Promise.reject(new Error(msg));\n      }\n\n      try {\n        const res = yield getSynchroDate(_this13.mDb);\n        return Promise.resolve(res);\n      } catch (err) {\n        const msg = `getSyncDate: ${err.message}`;\n        return Promise.reject(new Error(msg));\n      }\n    })();\n  }\n\n  setSyncDate(syncDate) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this14._isDBOpen) {\n        let msg = `SetSyncDate: Database ${_this14.dbName} `;\n        msg += `not opened`;\n        return {\n          result: false,\n          message: msg\n        };\n      }\n\n      try {\n        const sDate = Math.round(new Date(syncDate).getTime() / 1000);\n        let stmt = `UPDATE sync_table SET sync_date = `;\n        stmt += `${sDate} WHERE id = 1;`;\n        const changes = yield execute(_this14.mDb, stmt);\n\n        if (changes < 0) {\n          return {\n            result: false,\n            message: 'setSyncDate failed'\n          };\n        } else {\n          return {\n            result: true\n          };\n        }\n      } catch (err) {\n        return {\n          result: false,\n          message: `setSyncDate failed: ${err.message}`\n        };\n      }\n    })();\n  }\n\n  importJson(jsonData, importProgress) {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      let changes = 0;\n\n      if (_this15._isDBOpen) {\n        try {\n          if (jsonData.tables && jsonData.tables.length > 0) {\n            // create the database schema\n            changes = yield createDatabaseSchema(_this15.mDb, jsonData);\n            let msg = `Schema creation completed changes: ${changes}`;\n            importProgress.emit({\n              progress: msg\n            });\n\n            if (changes != -1) {\n              // create the tables data\n              changes += yield createTablesData(_this15.mDb, jsonData, importProgress);\n              let msg = `Tables data creation completed changes: ${changes}`;\n              importProgress.emit({\n                progress: msg\n              });\n            }\n          }\n\n          if (jsonData.views && jsonData.views.length > 0) {\n            // create the views\n            changes += yield createViews(_this15.mDb, jsonData);\n          }\n\n          return Promise.resolve(changes);\n        } catch (err) {\n          return Promise.reject(new Error(`ImportJson: ${err.message}`));\n        }\n      } else {\n        return Promise.reject(new Error(`ImportJson: database is closed`));\n      }\n    })();\n  }\n\n  exportJson(mode, exportProgress) {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      const inJson = {};\n      inJson.database = _this16.dbName.slice(0, -9);\n      inJson.version = _this16.version;\n      inJson.encrypted = false;\n      inJson.mode = mode;\n\n      if (_this16._isDBOpen) {\n        try {\n          const retJson = yield createExportObject(_this16.mDb, inJson, exportProgress);\n          const isValid = isJsonSQLite(retJson);\n\n          if (isValid) {\n            return Promise.resolve(retJson);\n          } else {\n            return Promise.reject(new Error(`ExportJson: retJson not valid`));\n          }\n        } catch (err) {\n          return Promise.reject(new Error(`ExportJson: ${err.message}`));\n        }\n      } else {\n        return Promise.reject(new Error(`ExportJson: database is closed`));\n      }\n    })();\n  }\n\n}\n\nvar localforage = createCommonjsModule(function (module, exports) {\n  /*!\n      localForage -- Offline Storage, Improved\n      Version 1.9.0\n      https://localforage.github.io/localForage\n      (c) 2013-2017 Mozilla, Apache License 2.0\n  */\n  (function (f) {\n    if ('object' === \"object\" && 'object' !== \"undefined\") {\n      module.exports = f();\n    } else if (typeof undefined === \"function\" && undefined.amd) {\n      undefined([], f);\n    } else {\n      var g;\n\n      if (typeof window !== \"undefined\") {\n        g = window;\n      } else if (typeof commonjsGlobal !== \"undefined\") {\n        g = commonjsGlobal;\n      } else if (typeof self !== \"undefined\") {\n        g = self;\n      } else {\n        g = this;\n      }\n\n      g.localforage = f();\n    }\n  })(function () {\n    var define, module, exports;\n    return function e(t, n, r) {\n      function s(o, u) {\n        if (!n[o]) {\n          if (!t[o]) {\n            var a = typeof commonjsRequire == \"function\" && commonjsRequire;\n            if (!u && a) return a(o, !0);\n            if (i) return i(o, !0);\n            var f = new Error(\"Cannot find module '\" + o + \"'\");\n            throw f.code = \"MODULE_NOT_FOUND\", f;\n          }\n\n          var l = n[o] = {\n            exports: {}\n          };\n          t[o][0].call(l.exports, function (e) {\n            var n = t[o][1][e];\n            return s(n ? n : e);\n          }, l, l.exports, e, t, n, r);\n        }\n\n        return n[o].exports;\n      }\n\n      var i = typeof commonjsRequire == \"function\" && commonjsRequire;\n\n      for (var o = 0; o < r.length; o++) s(r[o]);\n\n      return s;\n    }({\n      1: [function (_dereq_, module, exports) {\n        (function (global) {\n          'use strict';\n\n          var Mutation = global.MutationObserver || global.WebKitMutationObserver;\n          var scheduleDrain;\n          {\n            if (Mutation) {\n              var called = 0;\n              var observer = new Mutation(nextTick);\n              var element = global.document.createTextNode('');\n              observer.observe(element, {\n                characterData: true\n              });\n\n              scheduleDrain = function () {\n                element.data = called = ++called % 2;\n              };\n            } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n              var channel = new global.MessageChannel();\n              channel.port1.onmessage = nextTick;\n\n              scheduleDrain = function () {\n                channel.port2.postMessage(0);\n              };\n            } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n              scheduleDrain = function () {\n                // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n                // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n                var scriptEl = global.document.createElement('script');\n\n                scriptEl.onreadystatechange = function () {\n                  nextTick();\n                  scriptEl.onreadystatechange = null;\n                  scriptEl.parentNode.removeChild(scriptEl);\n                  scriptEl = null;\n                };\n\n                global.document.documentElement.appendChild(scriptEl);\n              };\n            } else {\n              scheduleDrain = function () {\n                setTimeout(nextTick, 0);\n              };\n            }\n          }\n          var draining;\n          var queue = []; //named nextTick for less confusing stack traces\n\n          function nextTick() {\n            draining = true;\n            var i, oldQueue;\n            var len = queue.length;\n\n            while (len) {\n              oldQueue = queue;\n              queue = [];\n              i = -1;\n\n              while (++i < len) {\n                oldQueue[i]();\n              }\n\n              len = queue.length;\n            }\n\n            draining = false;\n          }\n\n          module.exports = immediate;\n\n          function immediate(task) {\n            if (queue.push(task) === 1 && !draining) {\n              scheduleDrain();\n            }\n          }\n        }).call(this, typeof commonjsGlobal !== \"undefined\" ? commonjsGlobal : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n      }, {}],\n      2: [function (_dereq_, module, exports) {\n        'use strict';\n\n        var immediate = _dereq_(1);\n        /* istanbul ignore next */\n\n\n        function INTERNAL() {}\n\n        var handlers = {};\n        var REJECTED = ['REJECTED'];\n        var FULFILLED = ['FULFILLED'];\n        var PENDING = ['PENDING'];\n        module.exports = Promise;\n\n        function Promise(resolver) {\n          if (typeof resolver !== 'function') {\n            throw new TypeError('resolver must be a function');\n          }\n\n          this.state = PENDING;\n          this.queue = [];\n          this.outcome = void 0;\n\n          if (resolver !== INTERNAL) {\n            safelyResolveThenable(this, resolver);\n          }\n        }\n\n        Promise.prototype[\"catch\"] = function (onRejected) {\n          return this.then(null, onRejected);\n        };\n\n        Promise.prototype.then = function (onFulfilled, onRejected) {\n          if (typeof onFulfilled !== 'function' && this.state === FULFILLED || typeof onRejected !== 'function' && this.state === REJECTED) {\n            return this;\n          }\n\n          var promise = new this.constructor(INTERNAL);\n\n          if (this.state !== PENDING) {\n            var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n            unwrap(promise, resolver, this.outcome);\n          } else {\n            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n          }\n\n          return promise;\n        };\n\n        function QueueItem(promise, onFulfilled, onRejected) {\n          this.promise = promise;\n\n          if (typeof onFulfilled === 'function') {\n            this.onFulfilled = onFulfilled;\n            this.callFulfilled = this.otherCallFulfilled;\n          }\n\n          if (typeof onRejected === 'function') {\n            this.onRejected = onRejected;\n            this.callRejected = this.otherCallRejected;\n          }\n        }\n\n        QueueItem.prototype.callFulfilled = function (value) {\n          handlers.resolve(this.promise, value);\n        };\n\n        QueueItem.prototype.otherCallFulfilled = function (value) {\n          unwrap(this.promise, this.onFulfilled, value);\n        };\n\n        QueueItem.prototype.callRejected = function (value) {\n          handlers.reject(this.promise, value);\n        };\n\n        QueueItem.prototype.otherCallRejected = function (value) {\n          unwrap(this.promise, this.onRejected, value);\n        };\n\n        function unwrap(promise, func, value) {\n          immediate(function () {\n            var returnValue;\n\n            try {\n              returnValue = func(value);\n            } catch (e) {\n              return handlers.reject(promise, e);\n            }\n\n            if (returnValue === promise) {\n              handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n            } else {\n              handlers.resolve(promise, returnValue);\n            }\n          });\n        }\n\n        handlers.resolve = function (self, value) {\n          var result = tryCatch(getThen, value);\n\n          if (result.status === 'error') {\n            return handlers.reject(self, result.value);\n          }\n\n          var thenable = result.value;\n\n          if (thenable) {\n            safelyResolveThenable(self, thenable);\n          } else {\n            self.state = FULFILLED;\n            self.outcome = value;\n            var i = -1;\n            var len = self.queue.length;\n\n            while (++i < len) {\n              self.queue[i].callFulfilled(value);\n            }\n          }\n\n          return self;\n        };\n\n        handlers.reject = function (self, error) {\n          self.state = REJECTED;\n          self.outcome = error;\n          var i = -1;\n          var len = self.queue.length;\n\n          while (++i < len) {\n            self.queue[i].callRejected(error);\n          }\n\n          return self;\n        };\n\n        function getThen(obj) {\n          // Make sure we only access the accessor once as required by the spec\n          var then = obj && obj.then;\n\n          if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n            return function appyThen() {\n              then.apply(obj, arguments);\n            };\n          }\n        }\n\n        function safelyResolveThenable(self, thenable) {\n          // Either fulfill, reject or reject with error\n          var called = false;\n\n          function onError(value) {\n            if (called) {\n              return;\n            }\n\n            called = true;\n            handlers.reject(self, value);\n          }\n\n          function onSuccess(value) {\n            if (called) {\n              return;\n            }\n\n            called = true;\n            handlers.resolve(self, value);\n          }\n\n          function tryToUnwrap() {\n            thenable(onSuccess, onError);\n          }\n\n          var result = tryCatch(tryToUnwrap);\n\n          if (result.status === 'error') {\n            onError(result.value);\n          }\n        }\n\n        function tryCatch(func, value) {\n          var out = {};\n\n          try {\n            out.value = func(value);\n            out.status = 'success';\n          } catch (e) {\n            out.status = 'error';\n            out.value = e;\n          }\n\n          return out;\n        }\n\n        Promise.resolve = resolve;\n\n        function resolve(value) {\n          if (value instanceof this) {\n            return value;\n          }\n\n          return handlers.resolve(new this(INTERNAL), value);\n        }\n\n        Promise.reject = reject;\n\n        function reject(reason) {\n          var promise = new this(INTERNAL);\n          return handlers.reject(promise, reason);\n        }\n\n        Promise.all = all;\n\n        function all(iterable) {\n          var self = this;\n\n          if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n            return this.reject(new TypeError('must be an array'));\n          }\n\n          var len = iterable.length;\n          var called = false;\n\n          if (!len) {\n            return this.resolve([]);\n          }\n\n          var values = new Array(len);\n          var resolved = 0;\n          var i = -1;\n          var promise = new this(INTERNAL);\n\n          while (++i < len) {\n            allResolver(iterable[i], i);\n          }\n\n          return promise;\n\n          function allResolver(value, i) {\n            self.resolve(value).then(resolveFromAll, function (error) {\n              if (!called) {\n                called = true;\n                handlers.reject(promise, error);\n              }\n            });\n\n            function resolveFromAll(outValue) {\n              values[i] = outValue;\n\n              if (++resolved === len && !called) {\n                called = true;\n                handlers.resolve(promise, values);\n              }\n            }\n          }\n        }\n\n        Promise.race = race;\n\n        function race(iterable) {\n          var self = this;\n\n          if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n            return this.reject(new TypeError('must be an array'));\n          }\n\n          var len = iterable.length;\n          var called = false;\n\n          if (!len) {\n            return this.resolve([]);\n          }\n\n          var i = -1;\n          var promise = new this(INTERNAL);\n\n          while (++i < len) {\n            resolver(iterable[i]);\n          }\n\n          return promise;\n\n          function resolver(value) {\n            self.resolve(value).then(function (response) {\n              if (!called) {\n                called = true;\n                handlers.resolve(promise, response);\n              }\n            }, function (error) {\n              if (!called) {\n                called = true;\n                handlers.reject(promise, error);\n              }\n            });\n          }\n        }\n      }, {\n        \"1\": 1\n      }],\n      3: [function (_dereq_, module, exports) {\n        (function (global) {\n          'use strict';\n\n          if (typeof global.Promise !== 'function') {\n            global.Promise = _dereq_(2);\n          }\n        }).call(this, typeof commonjsGlobal !== \"undefined\" ? commonjsGlobal : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n      }, {\n        \"2\": 2\n      }],\n      4: [function (_dereq_, module, exports) {\n        'use strict';\n\n        var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n          return typeof obj;\n        } : function (obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function getIDB() {\n          /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n          try {\n            if (typeof indexedDB !== 'undefined') {\n              return indexedDB;\n            }\n\n            if (typeof webkitIndexedDB !== 'undefined') {\n              return webkitIndexedDB;\n            }\n\n            if (typeof mozIndexedDB !== 'undefined') {\n              return mozIndexedDB;\n            }\n\n            if (typeof OIndexedDB !== 'undefined') {\n              return OIndexedDB;\n            }\n\n            if (typeof msIndexedDB !== 'undefined') {\n              return msIndexedDB;\n            }\n          } catch (e) {\n            return;\n          }\n        }\n\n        var idb = getIDB();\n\n        function isIndexedDBValid() {\n          try {\n            // Initialize IndexedDB; fall back to vendor-prefixed versions\n            // if needed.\n            if (!idb || !idb.open) {\n              return false;\n            } // We mimic PouchDB here;\n            //\n            // We test for openDatabase because IE Mobile identifies itself\n            // as Safari. Oh the lulz...\n\n\n            var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n            var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1; // Safari <10.1 does not meet our requirements for IDB support\n            // (see: https://github.com/pouchdb/pouchdb/issues/5572).\n            // Safari 10.1 shipped with fetch, we can use that to detect it.\n            // Note: this creates issues with `window.fetch` polyfills and\n            // overrides; see:\n            // https://github.com/localForage/localForage/issues/856\n\n            return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' && // some outdated implementations of IDB that appear on Samsung\n            // and HTC Android devices <4.4 are missing IDBKeyRange\n            // See: https://github.com/mozilla/localForage/issues/128\n            // See: https://github.com/mozilla/localForage/issues/272\n            typeof IDBKeyRange !== 'undefined';\n          } catch (e) {\n            return false;\n          }\n        } // Abstracts constructing a Blob object, so it also works in older\n        // browsers that don't support the native Blob constructor. (i.e.\n        // old QtWebKit versions, at least).\n        // Abstracts constructing a Blob object, so it also works in older\n        // browsers that don't support the native Blob constructor. (i.e.\n        // old QtWebKit versions, at least).\n\n\n        function createBlob(parts, properties) {\n          /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n          parts = parts || [];\n          properties = properties || {};\n\n          try {\n            return new Blob(parts, properties);\n          } catch (e) {\n            if (e.name !== 'TypeError') {\n              throw e;\n            }\n\n            var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n            var builder = new Builder();\n\n            for (var i = 0; i < parts.length; i += 1) {\n              builder.append(parts[i]);\n            }\n\n            return builder.getBlob(properties.type);\n          }\n        } // This is CommonJS because lie is an external dependency, so Rollup\n        // can just ignore it.\n\n\n        if (typeof Promise === 'undefined') {\n          // In the \"nopromises\" build this will just throw if you don't have\n          // a global promise object, but it would throw anyway later.\n          _dereq_(3);\n        }\n\n        var Promise$1 = Promise;\n\n        function executeCallback(promise, callback) {\n          if (callback) {\n            promise.then(function (result) {\n              callback(null, result);\n            }, function (error) {\n              callback(error);\n            });\n          }\n        }\n\n        function executeTwoCallbacks(promise, callback, errorCallback) {\n          if (typeof callback === 'function') {\n            promise.then(callback);\n          }\n\n          if (typeof errorCallback === 'function') {\n            promise[\"catch\"](errorCallback);\n          }\n        }\n\n        function normalizeKey(key) {\n          // Cast the key to a string, as that's all we can set as a key.\n          if (typeof key !== 'string') {\n            console.warn(key + ' used as a key, but it is not a string.');\n            key = String(key);\n          }\n\n          return key;\n        }\n\n        function getCallback() {\n          if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {\n            return arguments[arguments.length - 1];\n          }\n        } // Some code originally from async_storage.js in\n        // [Gaia](https://github.com/mozilla-b2g/gaia).\n\n\n        var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\n        var supportsBlobs = void 0;\n        var dbContexts = {};\n        var toString = Object.prototype.toString; // Transaction Modes\n\n        var READ_ONLY = 'readonly';\n        var READ_WRITE = 'readwrite'; // Transform a binary string to an array buffer, because otherwise\n        // weird stuff happens when you try to work with the binary string directly.\n        // It is known.\n        // From http://stackoverflow.com/questions/14967647/ (continues on next line)\n        // encode-decode-image-with-base64-breaks-image (2013-04-21)\n\n        function _binStringToArrayBuffer(bin) {\n          var length = bin.length;\n          var buf = new ArrayBuffer(length);\n          var arr = new Uint8Array(buf);\n\n          for (var i = 0; i < length; i++) {\n            arr[i] = bin.charCodeAt(i);\n          }\n\n          return buf;\n        } //\n        // Blobs are not supported in all versions of IndexedDB, notably\n        // Chrome <37 and Android <5. In those versions, storing a blob will throw.\n        //\n        // Various other blob bugs exist in Chrome v37-42 (inclusive).\n        // Detecting them is expensive and confusing to users, and Chrome 37-42\n        // is at very low usage worldwide, so we do a hacky userAgent check instead.\n        //\n        // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n        // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n        // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n        //\n        // Code borrowed from PouchDB. See:\n        // https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n        //\n\n\n        function _checkBlobSupportWithoutCaching(idb) {\n          return new Promise$1(function (resolve) {\n            var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n            var blob = createBlob(['']);\n            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n            txn.onabort = function (e) {\n              // If the transaction aborts now its due to not being able to\n              // write to the database, likely due to the disk being full\n              e.preventDefault();\n              e.stopPropagation();\n              resolve(false);\n            };\n\n            txn.oncomplete = function () {\n              var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n              var matchedEdge = navigator.userAgent.match(/Edge\\//); // MS Edge pretends to be Chrome 42:\n              // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n\n              resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n            };\n          })[\"catch\"](function () {\n            return false; // error, so assume unsupported\n          });\n        }\n\n        function _checkBlobSupport(idb) {\n          if (typeof supportsBlobs === 'boolean') {\n            return Promise$1.resolve(supportsBlobs);\n          }\n\n          return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n            supportsBlobs = value;\n            return supportsBlobs;\n          });\n        }\n\n        function _deferReadiness(dbInfo) {\n          var dbContext = dbContexts[dbInfo.name]; // Create a deferred object representing the current database operation.\n\n          var deferredOperation = {};\n          deferredOperation.promise = new Promise$1(function (resolve, reject) {\n            deferredOperation.resolve = resolve;\n            deferredOperation.reject = reject;\n          }); // Enqueue the deferred operation.\n\n          dbContext.deferredOperations.push(deferredOperation); // Chain its promise to the database readiness.\n\n          if (!dbContext.dbReady) {\n            dbContext.dbReady = deferredOperation.promise;\n          } else {\n            dbContext.dbReady = dbContext.dbReady.then(function () {\n              return deferredOperation.promise;\n            });\n          }\n        }\n\n        function _advanceReadiness(dbInfo) {\n          var dbContext = dbContexts[dbInfo.name]; // Dequeue a deferred operation.\n\n          var deferredOperation = dbContext.deferredOperations.pop(); // Resolve its promise (which is part of the database readiness\n          // chain of promises).\n\n          if (deferredOperation) {\n            deferredOperation.resolve();\n            return deferredOperation.promise;\n          }\n        }\n\n        function _rejectReadiness(dbInfo, err) {\n          var dbContext = dbContexts[dbInfo.name]; // Dequeue a deferred operation.\n\n          var deferredOperation = dbContext.deferredOperations.pop(); // Reject its promise (which is part of the database readiness\n          // chain of promises).\n\n          if (deferredOperation) {\n            deferredOperation.reject(err);\n            return deferredOperation.promise;\n          }\n        }\n\n        function _getConnection(dbInfo, upgradeNeeded) {\n          return new Promise$1(function (resolve, reject) {\n            dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();\n\n            if (dbInfo.db) {\n              if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n\n                dbInfo.db.close();\n              } else {\n                return resolve(dbInfo.db);\n              }\n            }\n\n            var dbArgs = [dbInfo.name];\n\n            if (upgradeNeeded) {\n              dbArgs.push(dbInfo.version);\n            }\n\n            var openreq = idb.open.apply(idb, dbArgs);\n\n            if (upgradeNeeded) {\n              openreq.onupgradeneeded = function (e) {\n                var db = openreq.result;\n\n                try {\n                  db.createObjectStore(dbInfo.storeName);\n\n                  if (e.oldVersion <= 1) {\n                    // Added when support for blob shims was added\n                    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                  }\n                } catch (ex) {\n                  if (ex.name === 'ConstraintError') {\n                    console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                  } else {\n                    throw ex;\n                  }\n                }\n              };\n            }\n\n            openreq.onerror = function (e) {\n              e.preventDefault();\n              reject(openreq.error);\n            };\n\n            openreq.onsuccess = function () {\n              resolve(openreq.result);\n\n              _advanceReadiness(dbInfo);\n            };\n          });\n        }\n\n        function _getOriginalConnection(dbInfo) {\n          return _getConnection(dbInfo, false);\n        }\n\n        function _getUpgradedConnection(dbInfo) {\n          return _getConnection(dbInfo, true);\n        }\n\n        function _isUpgradeNeeded(dbInfo, defaultVersion) {\n          if (!dbInfo.db) {\n            return true;\n          }\n\n          var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n          var isDowngrade = dbInfo.version < dbInfo.db.version;\n          var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n          if (isDowngrade) {\n            // If the version is not the default one\n            // then warn for impossible downgrade.\n            if (dbInfo.version !== defaultVersion) {\n              console.warn('The database \"' + dbInfo.name + '\"' + \" can't be downgraded from version \" + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n            } // Align the versions to prevent errors.\n\n\n            dbInfo.version = dbInfo.db.version;\n          }\n\n          if (isUpgrade || isNewStore) {\n            // If the store is new then increment the version (if needed).\n            // This will trigger an \"upgradeneeded\" event which is required\n            // for creating a store.\n            if (isNewStore) {\n              var incVersion = dbInfo.db.version + 1;\n\n              if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n              }\n            }\n\n            return true;\n          }\n\n          return false;\n        } // encode a blob for indexeddb engines that don't support blobs\n\n\n        function _encodeBlob(blob) {\n          return new Promise$1(function (resolve, reject) {\n            var reader = new FileReader();\n            reader.onerror = reject;\n\n            reader.onloadend = function (e) {\n              var base64 = btoa(e.target.result || '');\n              resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n              });\n            };\n\n            reader.readAsBinaryString(blob);\n          });\n        } // decode an encoded blob\n\n\n        function _decodeBlob(encodedBlob) {\n          var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n\n          return createBlob([arrayBuff], {\n            type: encodedBlob.type\n          });\n        } // is this one of our fancy encoded blobs?\n\n\n        function _isEncodedBlob(value) {\n          return value && value.__local_forage_encoded_blob;\n        } // Specialize the default `ready()` function by making it dependent\n        // on the current database operations. Thus, the driver will be actually\n        // ready when it's been initialized (default) *and* there are no pending\n        // operations on the database (initiated by some other instances).\n\n\n        function _fullyReady(callback) {\n          var self = this;\n\n          var promise = self._initReady().then(function () {\n            var dbContext = dbContexts[self._dbInfo.name];\n\n            if (dbContext && dbContext.dbReady) {\n              return dbContext.dbReady;\n            }\n          });\n\n          executeTwoCallbacks(promise, callback, callback);\n          return promise;\n        } // Try to establish a new db connection to replace the\n        // current one which is broken (i.e. experiencing\n        // InvalidStateError while creating a transaction).\n\n\n        function _tryReconnect(dbInfo) {\n          _deferReadiness(dbInfo);\n\n          var dbContext = dbContexts[dbInfo.name];\n          var forages = dbContext.forages;\n\n          for (var i = 0; i < forages.length; i++) {\n            var forage = forages[i];\n\n            if (forage._dbInfo.db) {\n              forage._dbInfo.db.close();\n\n              forage._dbInfo.db = null;\n            }\n          }\n\n          dbInfo.db = null;\n          return _getOriginalConnection(dbInfo).then(function (db) {\n            dbInfo.db = db;\n\n            if (_isUpgradeNeeded(dbInfo)) {\n              // Reopen the database for upgrading.\n              return _getUpgradedConnection(dbInfo);\n            }\n\n            return db;\n          }).then(function (db) {\n            // store the latest db reference\n            // in case the db was upgraded\n            dbInfo.db = dbContext.db = db;\n\n            for (var i = 0; i < forages.length; i++) {\n              forages[i]._dbInfo.db = db;\n            }\n          })[\"catch\"](function (err) {\n            _rejectReadiness(dbInfo, err);\n\n            throw err;\n          });\n        } // FF doesn't like Promises (micro-tasks) and IDDB store operations,\n        // so we have to do it with callbacks\n\n\n        function createTransaction(dbInfo, mode, callback, retries) {\n          if (retries === undefined) {\n            retries = 1;\n          }\n\n          try {\n            var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n            callback(null, tx);\n          } catch (err) {\n            if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {\n              return Promise$1.resolve().then(function () {\n                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {\n                  // increase the db version, to create the new ObjectStore\n                  if (dbInfo.db) {\n                    dbInfo.version = dbInfo.db.version + 1;\n                  } // Reopen the database for upgrading.\n\n\n                  return _getUpgradedConnection(dbInfo);\n                }\n              }).then(function () {\n                return _tryReconnect(dbInfo).then(function () {\n                  createTransaction(dbInfo, mode, callback, retries - 1);\n                });\n              })[\"catch\"](callback);\n            }\n\n            callback(err);\n          }\n        }\n\n        function createDbContext() {\n          return {\n            // Running localForages sharing a database.\n            forages: [],\n            // Shared database.\n            db: null,\n            // Database readiness (promise).\n            dbReady: null,\n            // Deferred operations on the database.\n            deferredOperations: []\n          };\n        } // Open the IndexedDB database (automatically creates one if one didn't\n        // previously exist), using any options set in the config.\n\n\n        function _initStorage(options) {\n          var self = this;\n          var dbInfo = {\n            db: null\n          };\n\n          if (options) {\n            for (var i in options) {\n              dbInfo[i] = options[i];\n            }\n          } // Get the current context of the database;\n\n\n          var dbContext = dbContexts[dbInfo.name]; // ...or create a new context.\n\n          if (!dbContext) {\n            dbContext = createDbContext(); // Register the new context in the global container.\n\n            dbContexts[dbInfo.name] = dbContext;\n          } // Register itself as a running localForage in the current context.\n\n\n          dbContext.forages.push(self); // Replace the default `ready()` function with the specialized one.\n\n          if (!self._initReady) {\n            self._initReady = self.ready;\n            self.ready = _fullyReady;\n          } // Create an array of initialization states of the related localForages.\n\n\n          var initPromises = [];\n\n          function ignoreErrors() {\n            // Don't handle errors here,\n            // just makes sure related localForages aren't pending.\n            return Promise$1.resolve();\n          }\n\n          for (var j = 0; j < dbContext.forages.length; j++) {\n            var forage = dbContext.forages[j];\n\n            if (forage !== self) {\n              // Don't wait for itself...\n              initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n            }\n          } // Take a snapshot of the related localForages.\n\n\n          var forages = dbContext.forages.slice(0); // Initialize the connection process only when\n          // all the related localForages aren't pending.\n\n          return Promise$1.all(initPromises).then(function () {\n            dbInfo.db = dbContext.db; // Get the connection or open a new one without upgrade.\n\n            return _getOriginalConnection(dbInfo);\n          }).then(function (db) {\n            dbInfo.db = db;\n\n            if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n              // Reopen the database for upgrading.\n              return _getUpgradedConnection(dbInfo);\n            }\n\n            return db;\n          }).then(function (db) {\n            dbInfo.db = dbContext.db = db;\n            self._dbInfo = dbInfo; // Share the final connection amongst related localForages.\n\n            for (var k = 0; k < forages.length; k++) {\n              var forage = forages[k];\n\n              if (forage !== self) {\n                // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n              }\n            }\n          });\n        }\n\n        function getItem(key, callback) {\n          var self = this;\n          key = normalizeKey(key);\n          var promise = new Promise$1(function (resolve, reject) {\n            self.ready().then(function () {\n              createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                  return reject(err);\n                }\n\n                try {\n                  var store = transaction.objectStore(self._dbInfo.storeName);\n                  var req = store.get(key);\n\n                  req.onsuccess = function () {\n                    var value = req.result;\n\n                    if (value === undefined) {\n                      value = null;\n                    }\n\n                    if (_isEncodedBlob(value)) {\n                      value = _decodeBlob(value);\n                    }\n\n                    resolve(value);\n                  };\n\n                  req.onerror = function () {\n                    reject(req.error);\n                  };\n                } catch (e) {\n                  reject(e);\n                }\n              });\n            })[\"catch\"](reject);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        } // Iterate over all items stored in database.\n\n\n        function iterate(iterator, callback) {\n          var self = this;\n          var promise = new Promise$1(function (resolve, reject) {\n            self.ready().then(function () {\n              createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                  return reject(err);\n                }\n\n                try {\n                  var store = transaction.objectStore(self._dbInfo.storeName);\n                  var req = store.openCursor();\n                  var iterationNumber = 1;\n\n                  req.onsuccess = function () {\n                    var cursor = req.result;\n\n                    if (cursor) {\n                      var value = cursor.value;\n\n                      if (_isEncodedBlob(value)) {\n                        value = _decodeBlob(value);\n                      }\n\n                      var result = iterator(value, cursor.key, iterationNumber++); // when the iterator callback returns any\n                      // (non-`undefined`) value, then we stop\n                      // the iteration immediately\n\n                      if (result !== void 0) {\n                        resolve(result);\n                      } else {\n                        cursor[\"continue\"]();\n                      }\n                    } else {\n                      resolve();\n                    }\n                  };\n\n                  req.onerror = function () {\n                    reject(req.error);\n                  };\n                } catch (e) {\n                  reject(e);\n                }\n              });\n            })[\"catch\"](reject);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        }\n\n        function setItem(key, value, callback) {\n          var self = this;\n          key = normalizeKey(key);\n          var promise = new Promise$1(function (resolve, reject) {\n            var dbInfo;\n            self.ready().then(function () {\n              dbInfo = self._dbInfo;\n\n              if (toString.call(value) === '[object Blob]') {\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                  if (blobSupport) {\n                    return value;\n                  }\n\n                  return _encodeBlob(value);\n                });\n              }\n\n              return value;\n            }).then(function (value) {\n              createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                  return reject(err);\n                }\n\n                try {\n                  var store = transaction.objectStore(self._dbInfo.storeName); // The reason we don't _save_ null is because IE 10 does\n                  // not support saving the `null` type in IndexedDB. How\n                  // ironic, given the bug below!\n                  // See: https://github.com/mozilla/localForage/issues/161\n\n                  if (value === null) {\n                    value = undefined;\n                  }\n\n                  var req = store.put(value, key);\n\n                  transaction.oncomplete = function () {\n                    // Cast to undefined so the value passed to\n                    // callback/promise is the same as what one would get out\n                    // of `getItem()` later. This leads to some weirdness\n                    // (setItem('foo', undefined) will return `null`), but\n                    // it's not my fault localStorage is our baseline and that\n                    // it's weird.\n                    if (value === undefined) {\n                      value = null;\n                    }\n\n                    resolve(value);\n                  };\n\n                  transaction.onabort = transaction.onerror = function () {\n                    var err = req.error ? req.error : req.transaction.error;\n                    reject(err);\n                  };\n                } catch (e) {\n                  reject(e);\n                }\n              });\n            })[\"catch\"](reject);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        }\n\n        function removeItem(key, callback) {\n          var self = this;\n          key = normalizeKey(key);\n          var promise = new Promise$1(function (resolve, reject) {\n            self.ready().then(function () {\n              createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                  return reject(err);\n                }\n\n                try {\n                  var store = transaction.objectStore(self._dbInfo.storeName); // We use a Grunt task to make this safe for IE and some\n                  // versions of Android (including those used by Cordova).\n                  // Normally IE won't like `.delete()` and will insist on\n                  // using `['delete']()`, but we have a build step that\n                  // fixes this for us now.\n\n                  var req = store[\"delete\"](key);\n\n                  transaction.oncomplete = function () {\n                    resolve();\n                  };\n\n                  transaction.onerror = function () {\n                    reject(req.error);\n                  }; // The request will be also be aborted if we've exceeded our storage\n                  // space.\n\n\n                  transaction.onabort = function () {\n                    var err = req.error ? req.error : req.transaction.error;\n                    reject(err);\n                  };\n                } catch (e) {\n                  reject(e);\n                }\n              });\n            })[\"catch\"](reject);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        }\n\n        function clear(callback) {\n          var self = this;\n          var promise = new Promise$1(function (resolve, reject) {\n            self.ready().then(function () {\n              createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                  return reject(err);\n                }\n\n                try {\n                  var store = transaction.objectStore(self._dbInfo.storeName);\n                  var req = store.clear();\n\n                  transaction.oncomplete = function () {\n                    resolve();\n                  };\n\n                  transaction.onabort = transaction.onerror = function () {\n                    var err = req.error ? req.error : req.transaction.error;\n                    reject(err);\n                  };\n                } catch (e) {\n                  reject(e);\n                }\n              });\n            })[\"catch\"](reject);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        }\n\n        function length(callback) {\n          var self = this;\n          var promise = new Promise$1(function (resolve, reject) {\n            self.ready().then(function () {\n              createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                  return reject(err);\n                }\n\n                try {\n                  var store = transaction.objectStore(self._dbInfo.storeName);\n                  var req = store.count();\n\n                  req.onsuccess = function () {\n                    resolve(req.result);\n                  };\n\n                  req.onerror = function () {\n                    reject(req.error);\n                  };\n                } catch (e) {\n                  reject(e);\n                }\n              });\n            })[\"catch\"](reject);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        }\n\n        function key(n, callback) {\n          var self = this;\n          var promise = new Promise$1(function (resolve, reject) {\n            if (n < 0) {\n              resolve(null);\n              return;\n            }\n\n            self.ready().then(function () {\n              createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                  return reject(err);\n                }\n\n                try {\n                  var store = transaction.objectStore(self._dbInfo.storeName);\n                  var advanced = false;\n                  var req = store.openKeyCursor();\n\n                  req.onsuccess = function () {\n                    var cursor = req.result;\n\n                    if (!cursor) {\n                      // this means there weren't enough keys\n                      resolve(null);\n                      return;\n                    }\n\n                    if (n === 0) {\n                      // We have the first key, return it if that's what they\n                      // wanted.\n                      resolve(cursor.key);\n                    } else {\n                      if (!advanced) {\n                        // Otherwise, ask the cursor to skip ahead n\n                        // records.\n                        advanced = true;\n                        cursor.advance(n);\n                      } else {\n                        // When we get here, we've got the nth key.\n                        resolve(cursor.key);\n                      }\n                    }\n                  };\n\n                  req.onerror = function () {\n                    reject(req.error);\n                  };\n                } catch (e) {\n                  reject(e);\n                }\n              });\n            })[\"catch\"](reject);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        }\n\n        function keys(callback) {\n          var self = this;\n          var promise = new Promise$1(function (resolve, reject) {\n            self.ready().then(function () {\n              createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                  return reject(err);\n                }\n\n                try {\n                  var store = transaction.objectStore(self._dbInfo.storeName);\n                  var req = store.openKeyCursor();\n                  var keys = [];\n\n                  req.onsuccess = function () {\n                    var cursor = req.result;\n\n                    if (!cursor) {\n                      resolve(keys);\n                      return;\n                    }\n\n                    keys.push(cursor.key);\n                    cursor[\"continue\"]();\n                  };\n\n                  req.onerror = function () {\n                    reject(req.error);\n                  };\n                } catch (e) {\n                  reject(e);\n                }\n              });\n            })[\"catch\"](reject);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        }\n\n        function dropInstance(options, callback) {\n          callback = getCallback.apply(this, arguments);\n          var currentConfig = this.config();\n          options = typeof options !== 'function' && options || {};\n\n          if (!options.name) {\n            options.name = options.name || currentConfig.name;\n            options.storeName = options.storeName || currentConfig.storeName;\n          }\n\n          var self = this;\n          var promise;\n\n          if (!options.name) {\n            promise = Promise$1.reject('Invalid arguments');\n          } else {\n            var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;\n            var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {\n              var dbContext = dbContexts[options.name];\n              var forages = dbContext.forages;\n              dbContext.db = db;\n\n              for (var i = 0; i < forages.length; i++) {\n                forages[i]._dbInfo.db = db;\n              }\n\n              return db;\n            });\n\n            if (!options.storeName) {\n              promise = dbPromise.then(function (db) {\n                _deferReadiness(options);\n\n                var dbContext = dbContexts[options.name];\n                var forages = dbContext.forages;\n                db.close();\n\n                for (var i = 0; i < forages.length; i++) {\n                  var forage = forages[i];\n                  forage._dbInfo.db = null;\n                }\n\n                var dropDBPromise = new Promise$1(function (resolve, reject) {\n                  var req = idb.deleteDatabase(options.name);\n\n                  req.onerror = req.onblocked = function (err) {\n                    var db = req.result;\n\n                    if (db) {\n                      db.close();\n                    }\n\n                    reject(err);\n                  };\n\n                  req.onsuccess = function () {\n                    var db = req.result;\n\n                    if (db) {\n                      db.close();\n                    }\n\n                    resolve(db);\n                  };\n                });\n                return dropDBPromise.then(function (db) {\n                  dbContext.db = db;\n\n                  for (var i = 0; i < forages.length; i++) {\n                    var _forage = forages[i];\n\n                    _advanceReadiness(_forage._dbInfo);\n                  }\n                })[\"catch\"](function (err) {\n                  (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\n                  throw err;\n                });\n              });\n            } else {\n              promise = dbPromise.then(function (db) {\n                if (!db.objectStoreNames.contains(options.storeName)) {\n                  return;\n                }\n\n                var newVersion = db.version + 1;\n\n                _deferReadiness(options);\n\n                var dbContext = dbContexts[options.name];\n                var forages = dbContext.forages;\n                db.close();\n\n                for (var i = 0; i < forages.length; i++) {\n                  var forage = forages[i];\n                  forage._dbInfo.db = null;\n                  forage._dbInfo.version = newVersion;\n                }\n\n                var dropObjectPromise = new Promise$1(function (resolve, reject) {\n                  var req = idb.open(options.name, newVersion);\n\n                  req.onerror = function (err) {\n                    var db = req.result;\n                    db.close();\n                    reject(err);\n                  };\n\n                  req.onupgradeneeded = function () {\n                    var db = req.result;\n                    db.deleteObjectStore(options.storeName);\n                  };\n\n                  req.onsuccess = function () {\n                    var db = req.result;\n                    db.close();\n                    resolve(db);\n                  };\n                });\n                return dropObjectPromise.then(function (db) {\n                  dbContext.db = db;\n\n                  for (var j = 0; j < forages.length; j++) {\n                    var _forage2 = forages[j];\n                    _forage2._dbInfo.db = db;\n\n                    _advanceReadiness(_forage2._dbInfo);\n                  }\n                })[\"catch\"](function (err) {\n                  (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\n                  throw err;\n                });\n              });\n            }\n          }\n\n          executeCallback(promise, callback);\n          return promise;\n        }\n\n        var asyncStorage = {\n          _driver: 'asyncStorage',\n          _initStorage: _initStorage,\n          _support: isIndexedDBValid(),\n          iterate: iterate,\n          getItem: getItem,\n          setItem: setItem,\n          removeItem: removeItem,\n          clear: clear,\n          length: length,\n          key: key,\n          keys: keys,\n          dropInstance: dropInstance\n        };\n\n        function isWebSQLValid() {\n          return typeof openDatabase === 'function';\n        } // Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n        // it to Base64, so this is how we store it to prevent very strange errors with less\n        // verbose ways of binary <-> string data storage.\n\n\n        var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n        var BLOB_TYPE_PREFIX = '~~local_forage_type~';\n        var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n        var SERIALIZED_MARKER = '__lfsc__:';\n        var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length; // OMG the serializations!\n\n        var TYPE_ARRAYBUFFER = 'arbf';\n        var TYPE_BLOB = 'blob';\n        var TYPE_INT8ARRAY = 'si08';\n        var TYPE_UINT8ARRAY = 'ui08';\n        var TYPE_UINT8CLAMPEDARRAY = 'uic8';\n        var TYPE_INT16ARRAY = 'si16';\n        var TYPE_INT32ARRAY = 'si32';\n        var TYPE_UINT16ARRAY = 'ur16';\n        var TYPE_UINT32ARRAY = 'ui32';\n        var TYPE_FLOAT32ARRAY = 'fl32';\n        var TYPE_FLOAT64ARRAY = 'fl64';\n        var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n        var toString$1 = Object.prototype.toString;\n\n        function stringToBuffer(serializedString) {\n          // Fill the string into a ArrayBuffer.\n          var bufferLength = serializedString.length * 0.75;\n          var len = serializedString.length;\n          var i;\n          var p = 0;\n          var encoded1, encoded2, encoded3, encoded4;\n\n          if (serializedString[serializedString.length - 1] === '=') {\n            bufferLength--;\n\n            if (serializedString[serializedString.length - 2] === '=') {\n              bufferLength--;\n            }\n          }\n\n          var buffer = new ArrayBuffer(bufferLength);\n          var bytes = new Uint8Array(buffer);\n\n          for (i = 0; i < len; i += 4) {\n            encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n            encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n            encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n            encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n            /*jslint bitwise: true */\n\n            bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n          }\n\n          return buffer;\n        } // Converts a buffer to a string to store, serialized, in the backend\n        // storage library.\n\n\n        function bufferToString(buffer) {\n          // base64-arraybuffer\n          var bytes = new Uint8Array(buffer);\n          var base64String = '';\n          var i;\n\n          for (i = 0; i < bytes.length; i += 3) {\n            /*jslint bitwise: true */\n            base64String += BASE_CHARS[bytes[i] >> 2];\n            base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n            base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n            base64String += BASE_CHARS[bytes[i + 2] & 63];\n          }\n\n          if (bytes.length % 3 === 2) {\n            base64String = base64String.substring(0, base64String.length - 1) + '=';\n          } else if (bytes.length % 3 === 1) {\n            base64String = base64String.substring(0, base64String.length - 2) + '==';\n          }\n\n          return base64String;\n        } // Serialize a value, afterwards executing a callback (which usually\n        // instructs the `setItem()` callback/promise to be executed). This is how\n        // we store binary data with localStorage.\n\n\n        function serialize(value, callback) {\n          var valueType = '';\n\n          if (value) {\n            valueType = toString$1.call(value);\n          } // Cannot use `value instanceof ArrayBuffer` or such here, as these\n          // checks fail when running the tests using casper.js...\n          //\n          // TODO: See why those tests fail and use a better solution.\n\n\n          if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n            // Convert binary arrays to a string and prefix the string with\n            // a special marker.\n            var buffer;\n            var marker = SERIALIZED_MARKER;\n\n            if (value instanceof ArrayBuffer) {\n              buffer = value;\n              marker += TYPE_ARRAYBUFFER;\n            } else {\n              buffer = value.buffer;\n\n              if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n              } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n              } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n              } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n              } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n              } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n              } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n              } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n              } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n              } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n              }\n            }\n\n            callback(marker + bufferToString(buffer));\n          } else if (valueType === '[object Blob]') {\n            // Conver the blob to a binaryArray and then to a string.\n            var fileReader = new FileReader();\n\n            fileReader.onload = function () {\n              // Backwards-compatible prefix for the blob type.\n              var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n              callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n            };\n\n            fileReader.readAsArrayBuffer(value);\n          } else {\n            try {\n              callback(JSON.stringify(value));\n            } catch (e) {\n              console.error(\"Couldn't convert value into a JSON string: \", value);\n              callback(null, e);\n            }\n          }\n        } // Deserialize data we've inserted into a value column/field. We place\n        // special markers into our strings to mark them as encoded; this isn't\n        // as nice as a meta field, but it's the only sane thing we can do whilst\n        // keeping localStorage support intact.\n        //\n        // Oftentimes this will just deserialize JSON content, but if we have a\n        // special marker (SERIALIZED_MARKER, defined above), we will extract\n        // some kind of arraybuffer/binary data/typed array out of the string.\n\n\n        function deserialize(value) {\n          // If we haven't marked this string as being specially serialized (i.e.\n          // something other than serialized JSON), we can just return it and be\n          // done with it.\n          if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n            return JSON.parse(value);\n          } // The following code deals with deserializing some kind of Blob or\n          // TypedArray. First we separate out the type of data we're dealing\n          // with from the data itself.\n\n\n          var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n          var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n          var blobType; // Backwards-compatible blob type serialization strategy.\n          // DBs created with older versions of localForage will simply not have the blob type.\n\n          if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n            var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n            blobType = matcher[1];\n            serializedString = serializedString.substring(matcher[0].length);\n          }\n\n          var buffer = stringToBuffer(serializedString); // Return the right type based on the code/type set during\n          // serialization.\n\n          switch (type) {\n            case TYPE_ARRAYBUFFER:\n              return buffer;\n\n            case TYPE_BLOB:\n              return createBlob([buffer], {\n                type: blobType\n              });\n\n            case TYPE_INT8ARRAY:\n              return new Int8Array(buffer);\n\n            case TYPE_UINT8ARRAY:\n              return new Uint8Array(buffer);\n\n            case TYPE_UINT8CLAMPEDARRAY:\n              return new Uint8ClampedArray(buffer);\n\n            case TYPE_INT16ARRAY:\n              return new Int16Array(buffer);\n\n            case TYPE_UINT16ARRAY:\n              return new Uint16Array(buffer);\n\n            case TYPE_INT32ARRAY:\n              return new Int32Array(buffer);\n\n            case TYPE_UINT32ARRAY:\n              return new Uint32Array(buffer);\n\n            case TYPE_FLOAT32ARRAY:\n              return new Float32Array(buffer);\n\n            case TYPE_FLOAT64ARRAY:\n              return new Float64Array(buffer);\n\n            default:\n              throw new Error('Unkown type: ' + type);\n          }\n        }\n\n        var localforageSerializer = {\n          serialize: serialize,\n          deserialize: deserialize,\n          stringToBuffer: stringToBuffer,\n          bufferToString: bufferToString\n        };\n        /*\n         * Includes code from:\n         *\n         * base64-arraybuffer\n         * https://github.com/niklasvh/base64-arraybuffer\n         *\n         * Copyright (c) 2012 Niklas von Hertzen\n         * Licensed under the MIT license.\n         */\n\n        function createDbTable(t, dbInfo, callback, errorCallback) {\n          t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);\n        } // Open the WebSQL database (automatically creates one if one didn't\n        // previously exist), using any options set in the config.\n\n\n        function _initStorage$1(options) {\n          var self = this;\n          var dbInfo = {\n            db: null\n          };\n\n          if (options) {\n            for (var i in options) {\n              dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n            }\n          }\n\n          var dbInfoPromise = new Promise$1(function (resolve, reject) {\n            // Open the database; the openDatabase API will automatically\n            // create it for us if it doesn't exist.\n            try {\n              dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n            } catch (e) {\n              return reject(e);\n            } // Create our key/value table if it doesn't exist.\n\n\n            dbInfo.db.transaction(function (t) {\n              createDbTable(t, dbInfo, function () {\n                self._dbInfo = dbInfo;\n                resolve();\n              }, function (t, error) {\n                reject(error);\n              });\n            }, reject);\n          });\n          dbInfo.serializer = localforageSerializer;\n          return dbInfoPromise;\n        }\n\n        function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {\n          t.executeSql(sqlStatement, args, callback, function (t, error) {\n            if (error.code === error.SYNTAX_ERR) {\n              t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name = ?\", [dbInfo.storeName], function (t, results) {\n                if (!results.rows.length) {\n                  // if the table is missing (was deleted)\n                  // re-create it table and retry\n                  createDbTable(t, dbInfo, function () {\n                    t.executeSql(sqlStatement, args, callback, errorCallback);\n                  }, errorCallback);\n                } else {\n                  errorCallback(t, error);\n                }\n              }, errorCallback);\n            } else {\n              errorCallback(t, error);\n            }\n          }, errorCallback);\n        }\n\n        function getItem$1(key, callback) {\n          var self = this;\n          key = normalizeKey(key);\n          var promise = new Promise$1(function (resolve, reject) {\n            self.ready().then(function () {\n              var dbInfo = self._dbInfo;\n              dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                  var result = results.rows.length ? results.rows.item(0).value : null; // Check to see if this is serialized content we need to\n                  // unpack.\n\n                  if (result) {\n                    result = dbInfo.serializer.deserialize(result);\n                  }\n\n                  resolve(result);\n                }, function (t, error) {\n                  reject(error);\n                });\n              });\n            })[\"catch\"](reject);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        }\n\n        function iterate$1(iterator, callback) {\n          var self = this;\n          var promise = new Promise$1(function (resolve, reject) {\n            self.ready().then(function () {\n              var dbInfo = self._dbInfo;\n              dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                  var rows = results.rows;\n                  var length = rows.length;\n\n                  for (var i = 0; i < length; i++) {\n                    var item = rows.item(i);\n                    var result = item.value; // Check to see if this is serialized content\n                    // we need to unpack.\n\n                    if (result) {\n                      result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    result = iterator(result, item.key, i + 1); // void(0) prevents problems with redefinition\n                    // of `undefined`.\n\n                    if (result !== void 0) {\n                      resolve(result);\n                      return;\n                    }\n                  }\n\n                  resolve();\n                }, function (t, error) {\n                  reject(error);\n                });\n              });\n            })[\"catch\"](reject);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        }\n\n        function _setItem(key, value, callback, retriesLeft) {\n          var self = this;\n          key = normalizeKey(key);\n          var promise = new Promise$1(function (resolve, reject) {\n            self.ready().then(function () {\n              // The localStorage API doesn't return undefined values in an\n              // \"expected\" way, so undefined is always cast to null in all\n              // drivers. See: https://github.com/mozilla/localForage/pull/42\n              if (value === undefined) {\n                value = null;\n              } // Save the original value to pass to the callback.\n\n\n              var originalValue = value;\n              var dbInfo = self._dbInfo;\n              dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                  reject(error);\n                } else {\n                  dbInfo.db.transaction(function (t) {\n                    tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {\n                      resolve(originalValue);\n                    }, function (t, error) {\n                      reject(error);\n                    });\n                  }, function (sqlError) {\n                    // The transaction failed; check\n                    // to see if it's a quota error.\n                    if (sqlError.code === sqlError.QUOTA_ERR) {\n                      // We reject the callback outright for now, but\n                      // it's worth trying to re-run the transaction.\n                      // Even if the user accepts the prompt to use\n                      // more storage on Safari, this error will\n                      // be called.\n                      //\n                      // Try to re-run the transaction.\n                      if (retriesLeft > 0) {\n                        resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                        return;\n                      }\n\n                      reject(sqlError);\n                    }\n                  });\n                }\n              });\n            })[\"catch\"](reject);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        }\n\n        function setItem$1(key, value, callback) {\n          return _setItem.apply(this, [key, value, callback, 1]);\n        }\n\n        function removeItem$1(key, callback) {\n          var self = this;\n          key = normalizeKey(key);\n          var promise = new Promise$1(function (resolve, reject) {\n            self.ready().then(function () {\n              var dbInfo = self._dbInfo;\n              dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                  resolve();\n                }, function (t, error) {\n                  reject(error);\n                });\n              });\n            })[\"catch\"](reject);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        } // Deletes every item in the table.\n        // TODO: Find out if this resets the AUTO_INCREMENT number.\n\n\n        function clear$1(callback) {\n          var self = this;\n          var promise = new Promise$1(function (resolve, reject) {\n            self.ready().then(function () {\n              var dbInfo = self._dbInfo;\n              dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {\n                  resolve();\n                }, function (t, error) {\n                  reject(error);\n                });\n              });\n            })[\"catch\"](reject);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        } // Does a simple `COUNT(key)` to get the number of items stored in\n        // localForage.\n\n\n        function length$1(callback) {\n          var self = this;\n          var promise = new Promise$1(function (resolve, reject) {\n            self.ready().then(function () {\n              var dbInfo = self._dbInfo;\n              dbInfo.db.transaction(function (t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                  var result = results.rows.item(0).c;\n                  resolve(result);\n                }, function (t, error) {\n                  reject(error);\n                });\n              });\n            })[\"catch\"](reject);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        } // Return the key located at key index X; essentially gets the key from a\n        // `WHERE id = ?`. This is the most efficient way I can think to implement\n        // this rarely-used (in my experience) part of the API, but it can seem\n        // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n        // the ID of each key will change every time it's updated. Perhaps a stored\n        // procedure for the `setItem()` SQL would solve this problem?\n        // TODO: Don't change ID on `setItem()`.\n\n\n        function key$1(n, callback) {\n          var self = this;\n          var promise = new Promise$1(function (resolve, reject) {\n            self.ready().then(function () {\n              var dbInfo = self._dbInfo;\n              dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                  var result = results.rows.length ? results.rows.item(0).key : null;\n                  resolve(result);\n                }, function (t, error) {\n                  reject(error);\n                });\n              });\n            })[\"catch\"](reject);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        }\n\n        function keys$1(callback) {\n          var self = this;\n          var promise = new Promise$1(function (resolve, reject) {\n            self.ready().then(function () {\n              var dbInfo = self._dbInfo;\n              dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                  var keys = [];\n\n                  for (var i = 0; i < results.rows.length; i++) {\n                    keys.push(results.rows.item(i).key);\n                  }\n\n                  resolve(keys);\n                }, function (t, error) {\n                  reject(error);\n                });\n              });\n            })[\"catch\"](reject);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        } // https://www.w3.org/TR/webdatabase/#databases\n        // > There is no way to enumerate or delete the databases available for an origin from this API.\n\n\n        function getAllStoreNames(db) {\n          return new Promise$1(function (resolve, reject) {\n            db.transaction(function (t) {\n              t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\", [], function (t, results) {\n                var storeNames = [];\n\n                for (var i = 0; i < results.rows.length; i++) {\n                  storeNames.push(results.rows.item(i).name);\n                }\n\n                resolve({\n                  db: db,\n                  storeNames: storeNames\n                });\n              }, function (t, error) {\n                reject(error);\n              });\n            }, function (sqlError) {\n              reject(sqlError);\n            });\n          });\n        }\n\n        function dropInstance$1(options, callback) {\n          callback = getCallback.apply(this, arguments);\n          var currentConfig = this.config();\n          options = typeof options !== 'function' && options || {};\n\n          if (!options.name) {\n            options.name = options.name || currentConfig.name;\n            options.storeName = options.storeName || currentConfig.storeName;\n          }\n\n          var self = this;\n          var promise;\n\n          if (!options.name) {\n            promise = Promise$1.reject('Invalid arguments');\n          } else {\n            promise = new Promise$1(function (resolve) {\n              var db;\n\n              if (options.name === currentConfig.name) {\n                // use the db reference of the current instance\n                db = self._dbInfo.db;\n              } else {\n                db = openDatabase(options.name, '', '', 0);\n              }\n\n              if (!options.storeName) {\n                // drop all database tables\n                resolve(getAllStoreNames(db));\n              } else {\n                resolve({\n                  db: db,\n                  storeNames: [options.storeName]\n                });\n              }\n            }).then(function (operationInfo) {\n              return new Promise$1(function (resolve, reject) {\n                operationInfo.db.transaction(function (t) {\n                  function dropTable(storeName) {\n                    return new Promise$1(function (resolve, reject) {\n                      t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {\n                        resolve();\n                      }, function (t, error) {\n                        reject(error);\n                      });\n                    });\n                  }\n\n                  var operations = [];\n\n                  for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {\n                    operations.push(dropTable(operationInfo.storeNames[i]));\n                  }\n\n                  Promise$1.all(operations).then(function () {\n                    resolve();\n                  })[\"catch\"](function (e) {\n                    reject(e);\n                  });\n                }, function (sqlError) {\n                  reject(sqlError);\n                });\n              });\n            });\n          }\n\n          executeCallback(promise, callback);\n          return promise;\n        }\n\n        var webSQLStorage = {\n          _driver: 'webSQLStorage',\n          _initStorage: _initStorage$1,\n          _support: isWebSQLValid(),\n          iterate: iterate$1,\n          getItem: getItem$1,\n          setItem: setItem$1,\n          removeItem: removeItem$1,\n          clear: clear$1,\n          length: length$1,\n          key: key$1,\n          keys: keys$1,\n          dropInstance: dropInstance$1\n        };\n\n        function isLocalStorageValid() {\n          try {\n            return typeof localStorage !== 'undefined' && 'setItem' in localStorage && // in IE8 typeof localStorage.setItem === 'object'\n            !!localStorage.setItem;\n          } catch (e) {\n            return false;\n          }\n        }\n\n        function _getKeyPrefix(options, defaultConfig) {\n          var keyPrefix = options.name + '/';\n\n          if (options.storeName !== defaultConfig.storeName) {\n            keyPrefix += options.storeName + '/';\n          }\n\n          return keyPrefix;\n        } // Check if localStorage throws when saving an item\n\n\n        function checkIfLocalStorageThrows() {\n          var localStorageTestKey = '_localforage_support_test';\n\n          try {\n            localStorage.setItem(localStorageTestKey, true);\n            localStorage.removeItem(localStorageTestKey);\n            return false;\n          } catch (e) {\n            return true;\n          }\n        } // Check if localStorage is usable and allows to save an item\n        // This method checks if localStorage is usable in Safari Private Browsing\n        // mode, or in any other case where the available quota for localStorage\n        // is 0 and there wasn't any saved items yet.\n\n\n        function _isLocalStorageUsable() {\n          return !checkIfLocalStorageThrows() || localStorage.length > 0;\n        } // Config the localStorage backend, using options set in the config.\n\n\n        function _initStorage$2(options) {\n          var self = this;\n          var dbInfo = {};\n\n          if (options) {\n            for (var i in options) {\n              dbInfo[i] = options[i];\n            }\n          }\n\n          dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);\n\n          if (!_isLocalStorageUsable()) {\n            return Promise$1.reject();\n          }\n\n          self._dbInfo = dbInfo;\n          dbInfo.serializer = localforageSerializer;\n          return Promise$1.resolve();\n        } // Remove all keys from the datastore, effectively destroying all data in\n        // the app's key/value store!\n\n\n        function clear$2(callback) {\n          var self = this;\n          var promise = self.ready().then(function () {\n            var keyPrefix = self._dbInfo.keyPrefix;\n\n            for (var i = localStorage.length - 1; i >= 0; i--) {\n              var key = localStorage.key(i);\n\n              if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n              }\n            }\n          });\n          executeCallback(promise, callback);\n          return promise;\n        } // Retrieve an item from the store. Unlike the original async_storage\n        // library in Gaia, we don't modify return values at all. If a key's value\n        // is `undefined`, we pass that value to the callback function.\n\n\n        function getItem$2(key, callback) {\n          var self = this;\n          key = normalizeKey(key);\n          var promise = self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var result = localStorage.getItem(dbInfo.keyPrefix + key); // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the key\n            // is likely undefined and we'll pass it straight to the\n            // callback.\n\n            if (result) {\n              result = dbInfo.serializer.deserialize(result);\n            }\n\n            return result;\n          });\n          executeCallback(promise, callback);\n          return promise;\n        } // Iterate over all items in the store.\n\n\n        function iterate$2(iterator, callback) {\n          var self = this;\n          var promise = self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var keyPrefix = dbInfo.keyPrefix;\n            var keyPrefixLength = keyPrefix.length;\n            var length = localStorage.length; // We use a dedicated iterator instead of the `i` variable below\n            // so other keys we fetch in localStorage aren't counted in\n            // the `iterationNumber` argument passed to the `iterate()`\n            // callback.\n            //\n            // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n\n            var iterationNumber = 1;\n\n            for (var i = 0; i < length; i++) {\n              var key = localStorage.key(i);\n\n              if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n              }\n\n              var value = localStorage.getItem(key); // If a result was found, parse it from the serialized\n              // string into a JS object. If result isn't truthy, the\n              // key is likely undefined and we'll pass it straight\n              // to the iterator.\n\n              if (value) {\n                value = dbInfo.serializer.deserialize(value);\n              }\n\n              value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\n              if (value !== void 0) {\n                return value;\n              }\n            }\n          });\n          executeCallback(promise, callback);\n          return promise;\n        } // Same as localStorage's key() method, except takes a callback.\n\n\n        function key$2(n, callback) {\n          var self = this;\n          var promise = self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var result;\n\n            try {\n              result = localStorage.key(n);\n            } catch (error) {\n              result = null;\n            } // Remove the prefix from the key, if a key is found.\n\n\n            if (result) {\n              result = result.substring(dbInfo.keyPrefix.length);\n            }\n\n            return result;\n          });\n          executeCallback(promise, callback);\n          return promise;\n        }\n\n        function keys$2(callback) {\n          var self = this;\n          var promise = self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var length = localStorage.length;\n            var keys = [];\n\n            for (var i = 0; i < length; i++) {\n              var itemKey = localStorage.key(i);\n\n              if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n              }\n            }\n\n            return keys;\n          });\n          executeCallback(promise, callback);\n          return promise;\n        } // Supply the number of keys in the datastore to the callback function.\n\n\n        function length$2(callback) {\n          var self = this;\n          var promise = self.keys().then(function (keys) {\n            return keys.length;\n          });\n          executeCallback(promise, callback);\n          return promise;\n        } // Remove an item from the store, nice and simple.\n\n\n        function removeItem$2(key, callback) {\n          var self = this;\n          key = normalizeKey(key);\n          var promise = self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            localStorage.removeItem(dbInfo.keyPrefix + key);\n          });\n          executeCallback(promise, callback);\n          return promise;\n        } // Set a key's value and run an optional callback once the value is set.\n        // Unlike Gaia's implementation, the callback function is passed the value,\n        // in case you want to operate on that value only after you're sure it\n        // saved, or something like that.\n\n\n        function setItem$2(key, value, callback) {\n          var self = this;\n          key = normalizeKey(key);\n          var promise = self.ready().then(function () {\n            // Convert undefined values to null.\n            // https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n              value = null;\n            } // Save the original value to pass to the callback.\n\n\n            var originalValue = value;\n            return new Promise$1(function (resolve, reject) {\n              var dbInfo = self._dbInfo;\n              dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                  reject(error);\n                } else {\n                  try {\n                    localStorage.setItem(dbInfo.keyPrefix + key, value);\n                    resolve(originalValue);\n                  } catch (e) {\n                    // localStorage capacity exceeded.\n                    // TODO: Make this a specific error/event.\n                    if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                      reject(e);\n                    }\n\n                    reject(e);\n                  }\n                }\n              });\n            });\n          });\n          executeCallback(promise, callback);\n          return promise;\n        }\n\n        function dropInstance$2(options, callback) {\n          callback = getCallback.apply(this, arguments);\n          options = typeof options !== 'function' && options || {};\n\n          if (!options.name) {\n            var currentConfig = this.config();\n            options.name = options.name || currentConfig.name;\n            options.storeName = options.storeName || currentConfig.storeName;\n          }\n\n          var self = this;\n          var promise;\n\n          if (!options.name) {\n            promise = Promise$1.reject('Invalid arguments');\n          } else {\n            promise = new Promise$1(function (resolve) {\n              if (!options.storeName) {\n                resolve(options.name + '/');\n              } else {\n                resolve(_getKeyPrefix(options, self._defaultConfig));\n              }\n            }).then(function (keyPrefix) {\n              for (var i = localStorage.length - 1; i >= 0; i--) {\n                var key = localStorage.key(i);\n\n                if (key.indexOf(keyPrefix) === 0) {\n                  localStorage.removeItem(key);\n                }\n              }\n            });\n          }\n\n          executeCallback(promise, callback);\n          return promise;\n        }\n\n        var localStorageWrapper = {\n          _driver: 'localStorageWrapper',\n          _initStorage: _initStorage$2,\n          _support: isLocalStorageValid(),\n          iterate: iterate$2,\n          getItem: getItem$2,\n          setItem: setItem$2,\n          removeItem: removeItem$2,\n          clear: clear$2,\n          length: length$2,\n          key: key$2,\n          keys: keys$2,\n          dropInstance: dropInstance$2\n        };\n\n        var sameValue = function sameValue(x, y) {\n          return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);\n        };\n\n        var includes = function includes(array, searchElement) {\n          var len = array.length;\n          var i = 0;\n\n          while (i < len) {\n            if (sameValue(array[i], searchElement)) {\n              return true;\n            }\n\n            i++;\n          }\n\n          return false;\n        };\n\n        var isArray = Array.isArray || function (arg) {\n          return Object.prototype.toString.call(arg) === '[object Array]';\n        }; // Drivers are stored here when `defineDriver()` is called.\n        // They are shared across all instances of localForage.\n\n\n        var DefinedDrivers = {};\n        var DriverSupport = {};\n        var DefaultDrivers = {\n          INDEXEDDB: asyncStorage,\n          WEBSQL: webSQLStorage,\n          LOCALSTORAGE: localStorageWrapper\n        };\n        var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];\n        var OptionalDriverMethods = ['dropInstance'];\n        var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);\n        var DefaultConfig = {\n          description: '',\n          driver: DefaultDriverOrder.slice(),\n          name: 'localforage',\n          // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n          // we can use without a prompt.\n          size: 4980736,\n          storeName: 'keyvaluepairs',\n          version: 1.0\n        };\n\n        function callWhenReady(localForageInstance, libraryMethod) {\n          localForageInstance[libraryMethod] = function () {\n            var _args = arguments;\n            return localForageInstance.ready().then(function () {\n              return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n            });\n          };\n        }\n\n        function extend() {\n          for (var i = 1; i < arguments.length; i++) {\n            var arg = arguments[i];\n\n            if (arg) {\n              for (var _key in arg) {\n                if (arg.hasOwnProperty(_key)) {\n                  if (isArray(arg[_key])) {\n                    arguments[0][_key] = arg[_key].slice();\n                  } else {\n                    arguments[0][_key] = arg[_key];\n                  }\n                }\n              }\n            }\n          }\n\n          return arguments[0];\n        }\n\n        var LocalForage = function () {\n          function LocalForage(options) {\n            _classCallCheck(this, LocalForage);\n\n            for (var driverTypeKey in DefaultDrivers) {\n              if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                var driver = DefaultDrivers[driverTypeKey];\n                var driverName = driver._driver;\n                this[driverTypeKey] = driverName;\n\n                if (!DefinedDrivers[driverName]) {\n                  // we don't need to wait for the promise,\n                  // since the default drivers can be defined\n                  // in a blocking manner\n                  this.defineDriver(driver);\n                }\n              }\n            }\n\n            this._defaultConfig = extend({}, DefaultConfig);\n            this._config = extend({}, this._defaultConfig, options);\n            this._driverSet = null;\n            this._initDriver = null;\n            this._ready = false;\n            this._dbInfo = null;\n\n            this._wrapLibraryMethodsWithReady();\n\n            this.setDriver(this._config.driver)[\"catch\"](function () {});\n          } // Set any config values for localForage; can be called anytime before\n          // the first API call (e.g. `getItem`, `setItem`).\n          // We loop through options so we don't overwrite existing config\n          // values.\n\n\n          LocalForage.prototype.config = function config(options) {\n            // If the options argument is an object, we use it to set values.\n            // Otherwise, we return either a specified config value or all\n            // config values.\n            if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n              // If localforage is ready and fully initialized, we can't set\n              // any new configuration values. Instead, we return an error.\n              if (this._ready) {\n                return new Error(\"Can't call config() after localforage \" + 'has been used.');\n              }\n\n              for (var i in options) {\n                if (i === 'storeName') {\n                  options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                  return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n              } // after all config options are set and\n              // the driver option is used, try setting it\n\n\n              if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n              }\n\n              return true;\n            } else if (typeof options === 'string') {\n              return this._config[options];\n            } else {\n              return this._config;\n            }\n          }; // Used to define a custom driver, shared across all instances of\n          // localForage.\n\n\n          LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n            var promise = new Promise$1(function (resolve, reject) {\n              try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver'); // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n\n                if (!driverObject._driver) {\n                  reject(complianceError);\n                  return;\n                }\n\n                var driverMethods = LibraryMethods.concat('_initStorage');\n\n                for (var i = 0, len = driverMethods.length; i < len; i++) {\n                  var driverMethodName = driverMethods[i]; // when the property is there,\n                  // it should be a method even when optional\n\n                  var isRequired = !includes(OptionalDriverMethods, driverMethodName);\n\n                  if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {\n                    reject(complianceError);\n                    return;\n                  }\n                }\n\n                var configureMissingMethods = function configureMissingMethods() {\n                  var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {\n                    return function () {\n                      var error = new Error('Method ' + methodName + ' is not implemented by the current driver');\n                      var promise = Promise$1.reject(error);\n                      executeCallback(promise, arguments[arguments.length - 1]);\n                      return promise;\n                    };\n                  };\n\n                  for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {\n                    var optionalDriverMethod = OptionalDriverMethods[_i];\n\n                    if (!driverObject[optionalDriverMethod]) {\n                      driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);\n                    }\n                  }\n                };\n\n                configureMissingMethods();\n\n                var setDriverSupport = function setDriverSupport(support) {\n                  if (DefinedDrivers[driverName]) {\n                    console.info('Redefining LocalForage driver: ' + driverName);\n                  }\n\n                  DefinedDrivers[driverName] = driverObject;\n                  DriverSupport[driverName] = support; // don't use a then, so that we can define\n                  // drivers that have simple _support methods\n                  // in a blocking manner\n\n                  resolve();\n                };\n\n                if ('_support' in driverObject) {\n                  if (driverObject._support && typeof driverObject._support === 'function') {\n                    driverObject._support().then(setDriverSupport, reject);\n                  } else {\n                    setDriverSupport(!!driverObject._support);\n                  }\n                } else {\n                  setDriverSupport(true);\n                }\n              } catch (e) {\n                reject(e);\n              }\n            });\n            executeTwoCallbacks(promise, callback, errorCallback);\n            return promise;\n          };\n\n          LocalForage.prototype.driver = function driver() {\n            return this._driver || null;\n          };\n\n          LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n            var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));\n            executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n            return getDriverPromise;\n          };\n\n          LocalForage.prototype.getSerializer = function getSerializer(callback) {\n            var serializerPromise = Promise$1.resolve(localforageSerializer);\n            executeTwoCallbacks(serializerPromise, callback);\n            return serializerPromise;\n          };\n\n          LocalForage.prototype.ready = function ready(callback) {\n            var self = this;\n\n            var promise = self._driverSet.then(function () {\n              if (self._ready === null) {\n                self._ready = self._initDriver();\n              }\n\n              return self._ready;\n            });\n\n            executeTwoCallbacks(promise, callback, callback);\n            return promise;\n          };\n\n          LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n            var self = this;\n\n            if (!isArray(drivers)) {\n              drivers = [drivers];\n            }\n\n            var supportedDrivers = this._getSupportedDrivers(drivers);\n\n            function setDriverToConfig() {\n              self._config.driver = self.driver();\n            }\n\n            function extendSelfWithDriver(driver) {\n              self._extend(driver);\n\n              setDriverToConfig();\n              self._ready = self._initStorage(self._config);\n              return self._ready;\n            }\n\n            function initDriver(supportedDrivers) {\n              return function () {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                  while (currentDriverIndex < supportedDrivers.length) {\n                    var driverName = supportedDrivers[currentDriverIndex];\n                    currentDriverIndex++;\n                    self._dbInfo = null;\n                    self._ready = null;\n                    return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                  }\n\n                  setDriverToConfig();\n                  var error = new Error('No available storage method found.');\n                  self._driverSet = Promise$1.reject(error);\n                  return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n              };\n            } // There might be a driver initialization in progress\n            // so wait for it to finish in order to avoid a possible\n            // race condition to set _dbInfo\n\n\n            var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n              return Promise$1.resolve();\n            }) : Promise$1.resolve();\n            this._driverSet = oldDriverSetDone.then(function () {\n              var driverName = supportedDrivers[0];\n              self._dbInfo = null;\n              self._ready = null;\n              return self.getDriver(driverName).then(function (driver) {\n                self._driver = driver._driver;\n                setDriverToConfig();\n\n                self._wrapLibraryMethodsWithReady();\n\n                self._initDriver = initDriver(supportedDrivers);\n              });\n            })[\"catch\"](function () {\n              setDriverToConfig();\n              var error = new Error('No available storage method found.');\n              self._driverSet = Promise$1.reject(error);\n              return self._driverSet;\n            });\n            executeTwoCallbacks(this._driverSet, callback, errorCallback);\n            return this._driverSet;\n          };\n\n          LocalForage.prototype.supports = function supports(driverName) {\n            return !!DriverSupport[driverName];\n          };\n\n          LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n            extend(this, libraryMethodsAndProperties);\n          };\n\n          LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n            var supportedDrivers = [];\n\n            for (var i = 0, len = drivers.length; i < len; i++) {\n              var driverName = drivers[i];\n\n              if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n              }\n            }\n\n            return supportedDrivers;\n          };\n\n          LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n            // Add a stub for each driver API method that delays the call to the\n            // corresponding driver method until localForage is ready. These stubs\n            // will be replaced by the driver methods as soon as the driver is\n            // loaded, so there is no performance impact.\n            for (var i = 0, len = LibraryMethods.length; i < len; i++) {\n              callWhenReady(this, LibraryMethods[i]);\n            }\n          };\n\n          LocalForage.prototype.createInstance = function createInstance(options) {\n            return new LocalForage(options);\n          };\n\n          return LocalForage;\n        }(); // The actual localForage object that we expose as a module or via a\n        // global. It's extended by pulling in one of our other libraries.\n\n\n        var localforage_js = new LocalForage();\n        module.exports = localforage_js;\n      }, {\n        \"3\": 3\n      }]\n    }, {}, [4])(4);\n  });\n});\nvar jszip_min = createCommonjsModule(function (module, exports) {\n  /*!\n  \n  JSZip v3.7.1 - A JavaScript class for generating and reading zip files\n  <http://stuartk.com/jszip>\n  \n  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>\n  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.\n  \n  JSZip uses the library pako released under the MIT license :\n  https://github.com/nodeca/pako/blob/master/LICENSE\n  */\n  !function (t) {\n    if (\"object\" == 'object' && \"undefined\" != 'object') module.exports = t();else if (\"function\" == typeof undefined && undefined.amd) undefined([], t);else {\n      (\"undefined\" != typeof window ? window : \"undefined\" != typeof commonjsGlobal ? commonjsGlobal : \"undefined\" != typeof self ? self : this).JSZip = t();\n    }\n  }(function () {\n    return function s(a, o, h) {\n      function u(r, t) {\n        if (!o[r]) {\n          if (!a[r]) {\n            var e = \"function\" == typeof commonjsRequire && commonjsRequire;\n            if (!t && e) return e(r, !0);\n            if (l) return l(r, !0);\n            var i = new Error(\"Cannot find module '\" + r + \"'\");\n            throw i.code = \"MODULE_NOT_FOUND\", i;\n          }\n\n          var n = o[r] = {\n            exports: {}\n          };\n          a[r][0].call(n.exports, function (t) {\n            var e = a[r][1][t];\n            return u(e || t);\n          }, n, n.exports, s, a, o, h);\n        }\n\n        return o[r].exports;\n      }\n\n      for (var l = \"function\" == typeof commonjsRequire && commonjsRequire, t = 0; t < h.length; t++) u(h[t]);\n\n      return u;\n    }({\n      1: [function (t, e, r) {\n        \"use strict\";\n\n        var c = t(\"./utils\"),\n            d = t(\"./support\"),\n            p = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n        r.encode = function (t) {\n          for (var e, r, i, n, s, a, o, h = [], u = 0, l = t.length, f = l, d = \"string\" !== c.getTypeOf(t); u < t.length;) f = l - u, i = d ? (e = t[u++], r = u < l ? t[u++] : 0, u < l ? t[u++] : 0) : (e = t.charCodeAt(u++), r = u < l ? t.charCodeAt(u++) : 0, u < l ? t.charCodeAt(u++) : 0), n = e >> 2, s = (3 & e) << 4 | r >> 4, a = 1 < f ? (15 & r) << 2 | i >> 6 : 64, o = 2 < f ? 63 & i : 64, h.push(p.charAt(n) + p.charAt(s) + p.charAt(a) + p.charAt(o));\n\n          return h.join(\"\");\n        }, r.decode = function (t) {\n          var e,\n              r,\n              i,\n              n,\n              s,\n              a,\n              o = 0,\n              h = 0,\n              u = \"data:\";\n          if (t.substr(0, u.length) === u) throw new Error(\"Invalid base64 input, it looks like a data url.\");\n          var l,\n              f = 3 * (t = t.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\")).length / 4;\n          if (t.charAt(t.length - 1) === p.charAt(64) && f--, t.charAt(t.length - 2) === p.charAt(64) && f--, f % 1 != 0) throw new Error(\"Invalid base64 input, bad content length.\");\n\n          for (l = d.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < t.length;) e = p.indexOf(t.charAt(o++)) << 2 | (n = p.indexOf(t.charAt(o++))) >> 4, r = (15 & n) << 4 | (s = p.indexOf(t.charAt(o++))) >> 2, i = (3 & s) << 6 | (a = p.indexOf(t.charAt(o++))), l[h++] = e, 64 !== s && (l[h++] = r), 64 !== a && (l[h++] = i);\n\n          return l;\n        };\n      }, {\n        \"./support\": 30,\n        \"./utils\": 32\n      }],\n      2: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"./external\"),\n            n = t(\"./stream/DataWorker\"),\n            s = t(\"./stream/Crc32Probe\"),\n            a = t(\"./stream/DataLengthProbe\");\n\n        function o(t, e, r, i, n) {\n          this.compressedSize = t, this.uncompressedSize = e, this.crc32 = r, this.compression = i, this.compressedContent = n;\n        }\n\n        o.prototype = {\n          getContentWorker: function () {\n            var t = new n(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a(\"data_length\")),\n                e = this;\n            return t.on(\"end\", function () {\n              if (this.streamInfo.data_length !== e.uncompressedSize) throw new Error(\"Bug : uncompressed data size mismatch\");\n            }), t;\n          },\n          getCompressedWorker: function () {\n            return new n(i.Promise.resolve(this.compressedContent)).withStreamInfo(\"compressedSize\", this.compressedSize).withStreamInfo(\"uncompressedSize\", this.uncompressedSize).withStreamInfo(\"crc32\", this.crc32).withStreamInfo(\"compression\", this.compression);\n          }\n        }, o.createWorkerFrom = function (t, e, r) {\n          return t.pipe(new s()).pipe(new a(\"uncompressedSize\")).pipe(e.compressWorker(r)).pipe(new a(\"compressedSize\")).withStreamInfo(\"compression\", e);\n        }, e.exports = o;\n      }, {\n        \"./external\": 6,\n        \"./stream/Crc32Probe\": 25,\n        \"./stream/DataLengthProbe\": 26,\n        \"./stream/DataWorker\": 27\n      }],\n      3: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"./stream/GenericWorker\");\n        r.STORE = {\n          magic: \"\\0\\0\",\n          compressWorker: function (t) {\n            return new i(\"STORE compression\");\n          },\n          uncompressWorker: function () {\n            return new i(\"STORE decompression\");\n          }\n        }, r.DEFLATE = t(\"./flate\");\n      }, {\n        \"./flate\": 7,\n        \"./stream/GenericWorker\": 28\n      }],\n      4: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"./utils\");\n\n        var o = function () {\n          for (var t, e = [], r = 0; r < 256; r++) {\n            t = r;\n\n            for (var i = 0; i < 8; i++) t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;\n\n            e[r] = t;\n          }\n\n          return e;\n        }();\n\n        e.exports = function (t, e) {\n          return void 0 !== t && t.length ? \"string\" !== i.getTypeOf(t) ? function (t, e, r, i) {\n            var n = o,\n                s = i + r;\n            t ^= -1;\n\n            for (var a = i; a < s; a++) t = t >>> 8 ^ n[255 & (t ^ e[a])];\n\n            return -1 ^ t;\n          }(0 | e, t, t.length, 0) : function (t, e, r, i) {\n            var n = o,\n                s = i + r;\n            t ^= -1;\n\n            for (var a = i; a < s; a++) t = t >>> 8 ^ n[255 & (t ^ e.charCodeAt(a))];\n\n            return -1 ^ t;\n          }(0 | e, t, t.length, 0) : 0;\n        };\n      }, {\n        \"./utils\": 32\n      }],\n      5: [function (t, e, r) {\n        \"use strict\";\n\n        r.base64 = !1, r.binary = !1, r.dir = !1, r.createFolders = !0, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;\n      }, {}],\n      6: [function (t, e, r) {\n        \"use strict\";\n\n        var i = null;\n        i = \"undefined\" != typeof Promise ? Promise : t(\"lie\"), e.exports = {\n          Promise: i\n        };\n      }, {\n        lie: 37\n      }],\n      7: [function (t, e, r) {\n        \"use strict\";\n\n        var i = \"undefined\" != typeof Uint8Array && \"undefined\" != typeof Uint16Array && \"undefined\" != typeof Uint32Array,\n            n = t(\"pako\"),\n            s = t(\"./utils\"),\n            a = t(\"./stream/GenericWorker\"),\n            o = i ? \"uint8array\" : \"array\";\n\n        function h(t, e) {\n          a.call(this, \"FlateWorker/\" + t), this._pako = null, this._pakoAction = t, this._pakoOptions = e, this.meta = {};\n        }\n\n        r.magic = \"\\b\\0\", s.inherits(h, a), h.prototype.processChunk = function (t) {\n          this.meta = t.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, t.data), !1);\n        }, h.prototype.flush = function () {\n          a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], !0);\n        }, h.prototype.cleanUp = function () {\n          a.prototype.cleanUp.call(this), this._pako = null;\n        }, h.prototype._createPako = function () {\n          this._pako = new n[this._pakoAction]({\n            raw: !0,\n            level: this._pakoOptions.level || -1\n          });\n          var e = this;\n\n          this._pako.onData = function (t) {\n            e.push({\n              data: t,\n              meta: e.meta\n            });\n          };\n        }, r.compressWorker = function (t) {\n          return new h(\"Deflate\", t);\n        }, r.uncompressWorker = function () {\n          return new h(\"Inflate\", {});\n        };\n      }, {\n        \"./stream/GenericWorker\": 28,\n        \"./utils\": 32,\n        pako: 38\n      }],\n      8: [function (t, e, r) {\n        \"use strict\";\n\n        function A(t, e) {\n          var r,\n              i = \"\";\n\n          for (r = 0; r < e; r++) i += String.fromCharCode(255 & t), t >>>= 8;\n\n          return i;\n        }\n\n        function i(t, e, r, i, n, s) {\n          var a,\n              o,\n              h = t.file,\n              u = t.compression,\n              l = s !== O.utf8encode,\n              f = I.transformTo(\"string\", s(h.name)),\n              d = I.transformTo(\"string\", O.utf8encode(h.name)),\n              c = h.comment,\n              p = I.transformTo(\"string\", s(c)),\n              m = I.transformTo(\"string\", O.utf8encode(c)),\n              _ = d.length !== h.name.length,\n              g = m.length !== c.length,\n              b = \"\",\n              v = \"\",\n              y = \"\",\n              w = h.dir,\n              k = h.date,\n              x = {\n            crc32: 0,\n            compressedSize: 0,\n            uncompressedSize: 0\n          };\n\n          e && !r || (x.crc32 = t.crc32, x.compressedSize = t.compressedSize, x.uncompressedSize = t.uncompressedSize);\n          var S = 0;\n          e && (S |= 8), l || !_ && !g || (S |= 2048);\n          var z = 0,\n              C = 0;\n          w && (z |= 16), \"UNIX\" === n ? (C = 798, z |= function (t, e) {\n            var r = t;\n            return t || (r = e ? 16893 : 33204), (65535 & r) << 16;\n          }(h.unixPermissions, w)) : (C = 20, z |= function (t) {\n            return 63 & (t || 0);\n          }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + d, b += \"up\" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += \"uc\" + A(y.length, 2) + y);\n          var E = \"\";\n          return E += \"\\n\\0\", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), {\n            fileRecord: R.LOCAL_FILE_HEADER + E + f + b,\n            dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + \"\\0\\0\\0\\0\" + A(z, 4) + A(i, 4) + f + b + p\n          };\n        }\n\n        var I = t(\"../utils\"),\n            n = t(\"../stream/GenericWorker\"),\n            O = t(\"../utf8\"),\n            B = t(\"../crc32\"),\n            R = t(\"../signature\");\n\n        function s(t, e, r, i) {\n          n.call(this, \"ZipFileWorker\"), this.bytesWritten = 0, this.zipComment = e, this.zipPlatform = r, this.encodeFileName = i, this.streamFiles = t, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];\n        }\n\n        I.inherits(s, n), s.prototype.push = function (t) {\n          var e = t.meta.percent || 0,\n              r = this.entriesCount,\n              i = this._sources.length;\n          this.accumulate ? this.contentBuffer.push(t) : (this.bytesWritten += t.data.length, n.prototype.push.call(this, {\n            data: t.data,\n            meta: {\n              currentFile: this.currentFile,\n              percent: r ? (e + 100 * (r - i - 1)) / r : 100\n            }\n          }));\n        }, s.prototype.openedSource = function (t) {\n          this.currentSourceOffset = this.bytesWritten, this.currentFile = t.file.name;\n          var e = this.streamFiles && !t.file.dir;\n\n          if (e) {\n            var r = i(t, e, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n            this.push({\n              data: r.fileRecord,\n              meta: {\n                percent: 0\n              }\n            });\n          } else this.accumulate = !0;\n        }, s.prototype.closedSource = function (t) {\n          this.accumulate = !1;\n          var e = this.streamFiles && !t.file.dir,\n              r = i(t, e, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n          if (this.dirRecords.push(r.dirRecord), e) this.push({\n            data: function (t) {\n              return R.DATA_DESCRIPTOR + A(t.crc32, 4) + A(t.compressedSize, 4) + A(t.uncompressedSize, 4);\n            }(t),\n            meta: {\n              percent: 100\n            }\n          });else for (this.push({\n            data: r.fileRecord,\n            meta: {\n              percent: 0\n            }\n          }); this.contentBuffer.length;) this.push(this.contentBuffer.shift());\n          this.currentFile = null;\n        }, s.prototype.flush = function () {\n          for (var t = this.bytesWritten, e = 0; e < this.dirRecords.length; e++) this.push({\n            data: this.dirRecords[e],\n            meta: {\n              percent: 100\n            }\n          });\n\n          var r = this.bytesWritten - t,\n              i = function (t, e, r, i, n) {\n            var s = I.transformTo(\"string\", n(i));\n            return R.CENTRAL_DIRECTORY_END + \"\\0\\0\\0\\0\" + A(t, 2) + A(t, 2) + A(e, 4) + A(r, 4) + A(s.length, 2) + s;\n          }(this.dirRecords.length, r, t, this.zipComment, this.encodeFileName);\n\n          this.push({\n            data: i,\n            meta: {\n              percent: 100\n            }\n          });\n        }, s.prototype.prepareNextSource = function () {\n          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();\n        }, s.prototype.registerPrevious = function (t) {\n          this._sources.push(t);\n\n          var e = this;\n          return t.on(\"data\", function (t) {\n            e.processChunk(t);\n          }), t.on(\"end\", function () {\n            e.closedSource(e.previous.streamInfo), e._sources.length ? e.prepareNextSource() : e.end();\n          }), t.on(\"error\", function (t) {\n            e.error(t);\n          }), this;\n        }, s.prototype.resume = function () {\n          return !!n.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));\n        }, s.prototype.error = function (t) {\n          var e = this._sources;\n          if (!n.prototype.error.call(this, t)) return !1;\n\n          for (var r = 0; r < e.length; r++) try {\n            e[r].error(t);\n          } catch (t) {}\n\n          return !0;\n        }, s.prototype.lock = function () {\n          n.prototype.lock.call(this);\n\n          for (var t = this._sources, e = 0; e < t.length; e++) t[e].lock();\n        }, e.exports = s;\n      }, {\n        \"../crc32\": 4,\n        \"../signature\": 23,\n        \"../stream/GenericWorker\": 28,\n        \"../utf8\": 31,\n        \"../utils\": 32\n      }],\n      9: [function (t, e, r) {\n        \"use strict\";\n\n        var u = t(\"../compressions\"),\n            i = t(\"./ZipFileWorker\");\n\n        r.generateWorker = function (t, a, e) {\n          var o = new i(a.streamFiles, e, a.platform, a.encodeFileName),\n              h = 0;\n\n          try {\n            t.forEach(function (t, e) {\n              h++;\n\n              var r = function (t, e) {\n                var r = t || e,\n                    i = u[r];\n                if (!i) throw new Error(r + \" is not a valid compression method !\");\n                return i;\n              }(e.options.compression, a.compression),\n                  i = e.options.compressionOptions || a.compressionOptions || {},\n                  n = e.dir,\n                  s = e.date;\n\n              e._compressWorker(r, i).withStreamInfo(\"file\", {\n                name: t,\n                dir: n,\n                date: s,\n                comment: e.comment || \"\",\n                unixPermissions: e.unixPermissions,\n                dosPermissions: e.dosPermissions\n              }).pipe(o);\n            }), o.entriesCount = h;\n          } catch (t) {\n            o.error(t);\n          }\n\n          return o;\n        };\n      }, {\n        \"../compressions\": 3,\n        \"./ZipFileWorker\": 8\n      }],\n      10: [function (t, e, r) {\n        \"use strict\";\n\n        function i() {\n          if (!(this instanceof i)) return new i();\n          if (arguments.length) throw new Error(\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\");\n          this.files = Object.create(null), this.comment = null, this.root = \"\", this.clone = function () {\n            var t = new i();\n\n            for (var e in this) \"function\" != typeof this[e] && (t[e] = this[e]);\n\n            return t;\n          };\n        }\n\n        (i.prototype = t(\"./object\")).loadAsync = t(\"./load\"), i.support = t(\"./support\"), i.defaults = t(\"./defaults\"), i.version = \"3.7.1\", i.loadAsync = function (t, e) {\n          return new i().loadAsync(t, e);\n        }, i.external = t(\"./external\"), e.exports = i;\n      }, {\n        \"./defaults\": 5,\n        \"./external\": 6,\n        \"./load\": 11,\n        \"./object\": 15,\n        \"./support\": 30\n      }],\n      11: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"./utils\"),\n            n = t(\"./external\"),\n            o = t(\"./utf8\"),\n            h = t(\"./zipEntries\"),\n            s = t(\"./stream/Crc32Probe\"),\n            u = t(\"./nodejsUtils\");\n\n        function l(i) {\n          return new n.Promise(function (t, e) {\n            var r = i.decompressed.getContentWorker().pipe(new s());\n            r.on(\"error\", function (t) {\n              e(t);\n            }).on(\"end\", function () {\n              r.streamInfo.crc32 !== i.decompressed.crc32 ? e(new Error(\"Corrupted zip : CRC32 mismatch\")) : t();\n            }).resume();\n          });\n        }\n\n        e.exports = function (t, s) {\n          var a = this;\n          return s = i.extend(s || {}, {\n            base64: !1,\n            checkCRC32: !1,\n            optimizedBinaryString: !1,\n            createFolders: !1,\n            decodeFileName: o.utf8decode\n          }), u.isNode && u.isStream(t) ? n.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\")) : i.prepareContent(\"the loaded zip file\", t, !0, s.optimizedBinaryString, s.base64).then(function (t) {\n            var e = new h(s);\n            return e.load(t), e;\n          }).then(function (t) {\n            var e = [n.Promise.resolve(t)],\n                r = t.files;\n            if (s.checkCRC32) for (var i = 0; i < r.length; i++) e.push(l(r[i]));\n            return n.Promise.all(e);\n          }).then(function (t) {\n            for (var e = t.shift(), r = e.files, i = 0; i < r.length; i++) {\n              var n = r[i];\n              a.file(n.fileNameStr, n.decompressed, {\n                binary: !0,\n                optimizedBinaryString: !0,\n                date: n.date,\n                dir: n.dir,\n                comment: n.fileCommentStr.length ? n.fileCommentStr : null,\n                unixPermissions: n.unixPermissions,\n                dosPermissions: n.dosPermissions,\n                createFolders: s.createFolders\n              });\n            }\n\n            return e.zipComment.length && (a.comment = e.zipComment), a;\n          });\n        };\n      }, {\n        \"./external\": 6,\n        \"./nodejsUtils\": 14,\n        \"./stream/Crc32Probe\": 25,\n        \"./utf8\": 31,\n        \"./utils\": 32,\n        \"./zipEntries\": 33\n      }],\n      12: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"../utils\"),\n            n = t(\"../stream/GenericWorker\");\n\n        function s(t, e) {\n          n.call(this, \"Nodejs stream input adapter for \" + t), this._upstreamEnded = !1, this._bindStream(e);\n        }\n\n        i.inherits(s, n), s.prototype._bindStream = function (t) {\n          var e = this;\n          (this._stream = t).pause(), t.on(\"data\", function (t) {\n            e.push({\n              data: t,\n              meta: {\n                percent: 0\n              }\n            });\n          }).on(\"error\", function (t) {\n            e.isPaused ? this.generatedError = t : e.error(t);\n          }).on(\"end\", function () {\n            e.isPaused ? e._upstreamEnded = !0 : e.end();\n          });\n        }, s.prototype.pause = function () {\n          return !!n.prototype.pause.call(this) && (this._stream.pause(), !0);\n        }, s.prototype.resume = function () {\n          return !!n.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);\n        }, e.exports = s;\n      }, {\n        \"../stream/GenericWorker\": 28,\n        \"../utils\": 32\n      }],\n      13: [function (t, e, r) {\n        \"use strict\";\n\n        var n = t(\"readable-stream\").Readable;\n\n        function i(t, e, r) {\n          n.call(this, e), this._helper = t;\n          var i = this;\n          t.on(\"data\", function (t, e) {\n            i.push(t) || i._helper.pause(), r && r(e);\n          }).on(\"error\", function (t) {\n            i.emit(\"error\", t);\n          }).on(\"end\", function () {\n            i.push(null);\n          });\n        }\n\n        t(\"../utils\").inherits(i, n), i.prototype._read = function () {\n          this._helper.resume();\n        }, e.exports = i;\n      }, {\n        \"../utils\": 32,\n        \"readable-stream\": 16\n      }],\n      14: [function (t, e, r) {\n        \"use strict\";\n\n        e.exports = {\n          isNode: \"undefined\" != typeof Buffer,\n          newBufferFrom: function (t, e) {\n            if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(t, e);\n            if (\"number\" == typeof t) throw new Error('The \"data\" argument must not be a number');\n            return new Buffer(t, e);\n          },\n          allocBuffer: function (t) {\n            if (Buffer.alloc) return Buffer.alloc(t);\n            var e = new Buffer(t);\n            return e.fill(0), e;\n          },\n          isBuffer: function (t) {\n            return Buffer.isBuffer(t);\n          },\n          isStream: function (t) {\n            return t && \"function\" == typeof t.on && \"function\" == typeof t.pause && \"function\" == typeof t.resume;\n          }\n        };\n      }, {}],\n      15: [function (t, e, r) {\n        \"use strict\";\n\n        function s(t, e, r) {\n          var i,\n              n = u.getTypeOf(e),\n              s = u.extend(r || {}, f);\n          s.date = s.date || new Date(), null !== s.compression && (s.compression = s.compression.toUpperCase()), \"string\" == typeof s.unixPermissions && (s.unixPermissions = parseInt(s.unixPermissions, 8)), s.unixPermissions && 16384 & s.unixPermissions && (s.dir = !0), s.dosPermissions && 16 & s.dosPermissions && (s.dir = !0), s.dir && (t = g(t)), s.createFolders && (i = _(t)) && b.call(this, i, !0);\n          var a = \"string\" === n && !1 === s.binary && !1 === s.base64;\n          r && void 0 !== r.binary || (s.binary = !a), (e instanceof d && 0 === e.uncompressedSize || s.dir || !e || 0 === e.length) && (s.base64 = !1, s.binary = !0, e = \"\", s.compression = \"STORE\", n = \"string\");\n          var o = null;\n          o = e instanceof d || e instanceof l ? e : p.isNode && p.isStream(e) ? new m(t, e) : u.prepareContent(t, e, s.binary, s.optimizedBinaryString, s.base64);\n          var h = new c(t, o, s);\n          this.files[t] = h;\n        }\n\n        var n = t(\"./utf8\"),\n            u = t(\"./utils\"),\n            l = t(\"./stream/GenericWorker\"),\n            a = t(\"./stream/StreamHelper\"),\n            f = t(\"./defaults\"),\n            d = t(\"./compressedObject\"),\n            c = t(\"./zipObject\"),\n            o = t(\"./generate\"),\n            p = t(\"./nodejsUtils\"),\n            m = t(\"./nodejs/NodejsStreamInputAdapter\"),\n            _ = function (t) {\n          \"/\" === t.slice(-1) && (t = t.substring(0, t.length - 1));\n          var e = t.lastIndexOf(\"/\");\n          return 0 < e ? t.substring(0, e) : \"\";\n        },\n            g = function (t) {\n          return \"/\" !== t.slice(-1) && (t += \"/\"), t;\n        },\n            b = function (t, e) {\n          return e = void 0 !== e ? e : f.createFolders, t = g(t), this.files[t] || s.call(this, t, null, {\n            dir: !0,\n            createFolders: e\n          }), this.files[t];\n        };\n\n        function h(t) {\n          return \"[object RegExp]\" === Object.prototype.toString.call(t);\n        }\n\n        var i = {\n          load: function () {\n            throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n          },\n          forEach: function (t) {\n            var e, r, i;\n\n            for (e in this.files) i = this.files[e], (r = e.slice(this.root.length, e.length)) && e.slice(0, this.root.length) === this.root && t(r, i);\n          },\n          filter: function (r) {\n            var i = [];\n            return this.forEach(function (t, e) {\n              r(t, e) && i.push(e);\n            }), i;\n          },\n          file: function (t, e, r) {\n            if (1 !== arguments.length) return t = this.root + t, s.call(this, t, e, r), this;\n\n            if (h(t)) {\n              var i = t;\n              return this.filter(function (t, e) {\n                return !e.dir && i.test(t);\n              });\n            }\n\n            var n = this.files[this.root + t];\n            return n && !n.dir ? n : null;\n          },\n          folder: function (r) {\n            if (!r) return this;\n            if (h(r)) return this.filter(function (t, e) {\n              return e.dir && r.test(t);\n            });\n            var t = this.root + r,\n                e = b.call(this, t),\n                i = this.clone();\n            return i.root = e.name, i;\n          },\n          remove: function (r) {\n            r = this.root + r;\n            var t = this.files[r];\n            if (t || (\"/\" !== r.slice(-1) && (r += \"/\"), t = this.files[r]), t && !t.dir) delete this.files[r];else for (var e = this.filter(function (t, e) {\n              return e.name.slice(0, r.length) === r;\n            }), i = 0; i < e.length; i++) delete this.files[e[i].name];\n            return this;\n          },\n          generate: function (t) {\n            throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n          },\n          generateInternalStream: function (t) {\n            var e,\n                r = {};\n\n            try {\n              if ((r = u.extend(t || {}, {\n                streamFiles: !1,\n                compression: \"STORE\",\n                compressionOptions: null,\n                type: \"\",\n                platform: \"DOS\",\n                comment: null,\n                mimeType: \"application/zip\",\n                encodeFileName: n.utf8encode\n              })).type = r.type.toLowerCase(), r.compression = r.compression.toUpperCase(), \"binarystring\" === r.type && (r.type = \"string\"), !r.type) throw new Error(\"No output type specified.\");\n              u.checkSupport(r.type), \"darwin\" !== r.platform && \"freebsd\" !== r.platform && \"linux\" !== r.platform && \"sunos\" !== r.platform || (r.platform = \"UNIX\"), \"win32\" === r.platform && (r.platform = \"DOS\");\n              var i = r.comment || this.comment || \"\";\n              e = o.generateWorker(this, r, i);\n            } catch (t) {\n              (e = new l(\"error\")).error(t);\n            }\n\n            return new a(e, r.type || \"string\", r.mimeType);\n          },\n          generateAsync: function (t, e) {\n            return this.generateInternalStream(t).accumulate(e);\n          },\n          generateNodeStream: function (t, e) {\n            return (t = t || {}).type || (t.type = \"nodebuffer\"), this.generateInternalStream(t).toNodejsStream(e);\n          }\n        };\n        e.exports = i;\n      }, {\n        \"./compressedObject\": 2,\n        \"./defaults\": 5,\n        \"./generate\": 9,\n        \"./nodejs/NodejsStreamInputAdapter\": 12,\n        \"./nodejsUtils\": 14,\n        \"./stream/GenericWorker\": 28,\n        \"./stream/StreamHelper\": 29,\n        \"./utf8\": 31,\n        \"./utils\": 32,\n        \"./zipObject\": 35\n      }],\n      16: [function (t, e, r) {\n        e.exports = t(\"stream\");\n      }, {\n        stream: void 0\n      }],\n      17: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"./DataReader\");\n\n        function n(t) {\n          i.call(this, t);\n\n          for (var e = 0; e < this.data.length; e++) t[e] = 255 & t[e];\n        }\n\n        t(\"../utils\").inherits(n, i), n.prototype.byteAt = function (t) {\n          return this.data[this.zero + t];\n        }, n.prototype.lastIndexOfSignature = function (t) {\n          for (var e = t.charCodeAt(0), r = t.charCodeAt(1), i = t.charCodeAt(2), n = t.charCodeAt(3), s = this.length - 4; 0 <= s; --s) if (this.data[s] === e && this.data[s + 1] === r && this.data[s + 2] === i && this.data[s + 3] === n) return s - this.zero;\n\n          return -1;\n        }, n.prototype.readAndCheckSignature = function (t) {\n          var e = t.charCodeAt(0),\n              r = t.charCodeAt(1),\n              i = t.charCodeAt(2),\n              n = t.charCodeAt(3),\n              s = this.readData(4);\n          return e === s[0] && r === s[1] && i === s[2] && n === s[3];\n        }, n.prototype.readData = function (t) {\n          if (this.checkOffset(t), 0 === t) return [];\n          var e = this.data.slice(this.zero + this.index, this.zero + this.index + t);\n          return this.index += t, e;\n        }, e.exports = n;\n      }, {\n        \"../utils\": 32,\n        \"./DataReader\": 18\n      }],\n      18: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"../utils\");\n\n        function n(t) {\n          this.data = t, this.length = t.length, this.index = 0, this.zero = 0;\n        }\n\n        n.prototype = {\n          checkOffset: function (t) {\n            this.checkIndex(this.index + t);\n          },\n          checkIndex: function (t) {\n            if (this.length < this.zero + t || t < 0) throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + t + \"). Corrupted zip ?\");\n          },\n          setIndex: function (t) {\n            this.checkIndex(t), this.index = t;\n          },\n          skip: function (t) {\n            this.setIndex(this.index + t);\n          },\n          byteAt: function (t) {},\n          readInt: function (t) {\n            var e,\n                r = 0;\n\n            for (this.checkOffset(t), e = this.index + t - 1; e >= this.index; e--) r = (r << 8) + this.byteAt(e);\n\n            return this.index += t, r;\n          },\n          readString: function (t) {\n            return i.transformTo(\"string\", this.readData(t));\n          },\n          readData: function (t) {},\n          lastIndexOfSignature: function (t) {},\n          readAndCheckSignature: function (t) {},\n          readDate: function () {\n            var t = this.readInt(4);\n            return new Date(Date.UTC(1980 + (t >> 25 & 127), (t >> 21 & 15) - 1, t >> 16 & 31, t >> 11 & 31, t >> 5 & 63, (31 & t) << 1));\n          }\n        }, e.exports = n;\n      }, {\n        \"../utils\": 32\n      }],\n      19: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"./Uint8ArrayReader\");\n\n        function n(t) {\n          i.call(this, t);\n        }\n\n        t(\"../utils\").inherits(n, i), n.prototype.readData = function (t) {\n          this.checkOffset(t);\n          var e = this.data.slice(this.zero + this.index, this.zero + this.index + t);\n          return this.index += t, e;\n        }, e.exports = n;\n      }, {\n        \"../utils\": 32,\n        \"./Uint8ArrayReader\": 21\n      }],\n      20: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"./DataReader\");\n\n        function n(t) {\n          i.call(this, t);\n        }\n\n        t(\"../utils\").inherits(n, i), n.prototype.byteAt = function (t) {\n          return this.data.charCodeAt(this.zero + t);\n        }, n.prototype.lastIndexOfSignature = function (t) {\n          return this.data.lastIndexOf(t) - this.zero;\n        }, n.prototype.readAndCheckSignature = function (t) {\n          return t === this.readData(4);\n        }, n.prototype.readData = function (t) {\n          this.checkOffset(t);\n          var e = this.data.slice(this.zero + this.index, this.zero + this.index + t);\n          return this.index += t, e;\n        }, e.exports = n;\n      }, {\n        \"../utils\": 32,\n        \"./DataReader\": 18\n      }],\n      21: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"./ArrayReader\");\n\n        function n(t) {\n          i.call(this, t);\n        }\n\n        t(\"../utils\").inherits(n, i), n.prototype.readData = function (t) {\n          if (this.checkOffset(t), 0 === t) return new Uint8Array(0);\n          var e = this.data.subarray(this.zero + this.index, this.zero + this.index + t);\n          return this.index += t, e;\n        }, e.exports = n;\n      }, {\n        \"../utils\": 32,\n        \"./ArrayReader\": 17\n      }],\n      22: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"../utils\"),\n            n = t(\"../support\"),\n            s = t(\"./ArrayReader\"),\n            a = t(\"./StringReader\"),\n            o = t(\"./NodeBufferReader\"),\n            h = t(\"./Uint8ArrayReader\");\n\n        e.exports = function (t) {\n          var e = i.getTypeOf(t);\n          return i.checkSupport(e), \"string\" !== e || n.uint8array ? \"nodebuffer\" === e ? new o(t) : n.uint8array ? new h(i.transformTo(\"uint8array\", t)) : new s(i.transformTo(\"array\", t)) : new a(t);\n        };\n      }, {\n        \"../support\": 30,\n        \"../utils\": 32,\n        \"./ArrayReader\": 17,\n        \"./NodeBufferReader\": 19,\n        \"./StringReader\": 20,\n        \"./Uint8ArrayReader\": 21\n      }],\n      23: [function (t, e, r) {\n        \"use strict\";\n\n        r.LOCAL_FILE_HEADER = \"PK\u0003\u0004\", r.CENTRAL_FILE_HEADER = \"PK\u0001\u0002\", r.CENTRAL_DIRECTORY_END = \"PK\u0005\u0006\", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = \"PK\u0006\u0007\", r.ZIP64_CENTRAL_DIRECTORY_END = \"PK\u0006\u0006\", r.DATA_DESCRIPTOR = \"PK\u0007\\b\";\n      }, {}],\n      24: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"./GenericWorker\"),\n            n = t(\"../utils\");\n\n        function s(t) {\n          i.call(this, \"ConvertWorker to \" + t), this.destType = t;\n        }\n\n        n.inherits(s, i), s.prototype.processChunk = function (t) {\n          this.push({\n            data: n.transformTo(this.destType, t.data),\n            meta: t.meta\n          });\n        }, e.exports = s;\n      }, {\n        \"../utils\": 32,\n        \"./GenericWorker\": 28\n      }],\n      25: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"./GenericWorker\"),\n            n = t(\"../crc32\");\n\n        function s() {\n          i.call(this, \"Crc32Probe\"), this.withStreamInfo(\"crc32\", 0);\n        }\n\n        t(\"../utils\").inherits(s, i), s.prototype.processChunk = function (t) {\n          this.streamInfo.crc32 = n(t.data, this.streamInfo.crc32 || 0), this.push(t);\n        }, e.exports = s;\n      }, {\n        \"../crc32\": 4,\n        \"../utils\": 32,\n        \"./GenericWorker\": 28\n      }],\n      26: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"../utils\"),\n            n = t(\"./GenericWorker\");\n\n        function s(t) {\n          n.call(this, \"DataLengthProbe for \" + t), this.propName = t, this.withStreamInfo(t, 0);\n        }\n\n        i.inherits(s, n), s.prototype.processChunk = function (t) {\n          if (t) {\n            var e = this.streamInfo[this.propName] || 0;\n            this.streamInfo[this.propName] = e + t.data.length;\n          }\n\n          n.prototype.processChunk.call(this, t);\n        }, e.exports = s;\n      }, {\n        \"../utils\": 32,\n        \"./GenericWorker\": 28\n      }],\n      27: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"../utils\"),\n            n = t(\"./GenericWorker\");\n\n        function s(t) {\n          n.call(this, \"DataWorker\");\n          var e = this;\n          this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = \"\", this._tickScheduled = !1, t.then(function (t) {\n            e.dataIsReady = !0, e.data = t, e.max = t && t.length || 0, e.type = i.getTypeOf(t), e.isPaused || e._tickAndRepeat();\n          }, function (t) {\n            e.error(t);\n          });\n        }\n\n        i.inherits(s, n), s.prototype.cleanUp = function () {\n          n.prototype.cleanUp.call(this), this.data = null;\n        }, s.prototype.resume = function () {\n          return !!n.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, i.delay(this._tickAndRepeat, [], this)), !0);\n        }, s.prototype._tickAndRepeat = function () {\n          this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (i.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));\n        }, s.prototype._tick = function () {\n          if (this.isPaused || this.isFinished) return !1;\n          var t = null,\n              e = Math.min(this.max, this.index + 16384);\n          if (this.index >= this.max) return this.end();\n\n          switch (this.type) {\n            case \"string\":\n              t = this.data.substring(this.index, e);\n              break;\n\n            case \"uint8array\":\n              t = this.data.subarray(this.index, e);\n              break;\n\n            case \"array\":\n            case \"nodebuffer\":\n              t = this.data.slice(this.index, e);\n          }\n\n          return this.index = e, this.push({\n            data: t,\n            meta: {\n              percent: this.max ? this.index / this.max * 100 : 0\n            }\n          });\n        }, e.exports = s;\n      }, {\n        \"../utils\": 32,\n        \"./GenericWorker\": 28\n      }],\n      28: [function (t, e, r) {\n        \"use strict\";\n\n        function i(t) {\n          this.name = t || \"default\", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = {\n            data: [],\n            end: [],\n            error: []\n          }, this.previous = null;\n        }\n\n        i.prototype = {\n          push: function (t) {\n            this.emit(\"data\", t);\n          },\n          end: function () {\n            if (this.isFinished) return !1;\n            this.flush();\n\n            try {\n              this.emit(\"end\"), this.cleanUp(), this.isFinished = !0;\n            } catch (t) {\n              this.emit(\"error\", t);\n            }\n\n            return !0;\n          },\n          error: function (t) {\n            return !this.isFinished && (this.isPaused ? this.generatedError = t : (this.isFinished = !0, this.emit(\"error\", t), this.previous && this.previous.error(t), this.cleanUp()), !0);\n          },\n          on: function (t, e) {\n            return this._listeners[t].push(e), this;\n          },\n          cleanUp: function () {\n            this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];\n          },\n          emit: function (t, e) {\n            if (this._listeners[t]) for (var r = 0; r < this._listeners[t].length; r++) this._listeners[t][r].call(this, e);\n          },\n          pipe: function (t) {\n            return t.registerPrevious(this);\n          },\n          registerPrevious: function (t) {\n            if (this.isLocked) throw new Error(\"The stream '\" + this + \"' has already been used.\");\n            this.streamInfo = t.streamInfo, this.mergeStreamInfo(), this.previous = t;\n            var e = this;\n            return t.on(\"data\", function (t) {\n              e.processChunk(t);\n            }), t.on(\"end\", function () {\n              e.end();\n            }), t.on(\"error\", function (t) {\n              e.error(t);\n            }), this;\n          },\n          pause: function () {\n            return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);\n          },\n          resume: function () {\n            if (!this.isPaused || this.isFinished) return !1;\n            var t = this.isPaused = !1;\n            return this.generatedError && (this.error(this.generatedError), t = !0), this.previous && this.previous.resume(), !t;\n          },\n          flush: function () {},\n          processChunk: function (t) {\n            this.push(t);\n          },\n          withStreamInfo: function (t, e) {\n            return this.extraStreamInfo[t] = e, this.mergeStreamInfo(), this;\n          },\n          mergeStreamInfo: function () {\n            for (var t in this.extraStreamInfo) this.extraStreamInfo.hasOwnProperty(t) && (this.streamInfo[t] = this.extraStreamInfo[t]);\n          },\n          lock: function () {\n            if (this.isLocked) throw new Error(\"The stream '\" + this + \"' has already been used.\");\n            this.isLocked = !0, this.previous && this.previous.lock();\n          },\n          toString: function () {\n            var t = \"Worker \" + this.name;\n            return this.previous ? this.previous + \" -> \" + t : t;\n          }\n        }, e.exports = i;\n      }, {}],\n      29: [function (t, e, r) {\n        \"use strict\";\n\n        var h = t(\"../utils\"),\n            n = t(\"./ConvertWorker\"),\n            s = t(\"./GenericWorker\"),\n            u = t(\"../base64\"),\n            i = t(\"../support\"),\n            a = t(\"../external\"),\n            o = null;\n        if (i.nodestream) try {\n          o = t(\"../nodejs/NodejsStreamOutputAdapter\");\n        } catch (t) {}\n\n        function l(t, o) {\n          return new a.Promise(function (e, r) {\n            var i = [],\n                n = t._internalType,\n                s = t._outputType,\n                a = t._mimeType;\n            t.on(\"data\", function (t, e) {\n              i.push(t), o && o(e);\n            }).on(\"error\", function (t) {\n              i = [], r(t);\n            }).on(\"end\", function () {\n              try {\n                var t = function (t, e, r) {\n                  switch (t) {\n                    case \"blob\":\n                      return h.newBlob(h.transformTo(\"arraybuffer\", e), r);\n\n                    case \"base64\":\n                      return u.encode(e);\n\n                    default:\n                      return h.transformTo(t, e);\n                  }\n                }(s, function (t, e) {\n                  var r,\n                      i = 0,\n                      n = null,\n                      s = 0;\n\n                  for (r = 0; r < e.length; r++) s += e[r].length;\n\n                  switch (t) {\n                    case \"string\":\n                      return e.join(\"\");\n\n                    case \"array\":\n                      return Array.prototype.concat.apply([], e);\n\n                    case \"uint8array\":\n                      for (n = new Uint8Array(s), r = 0; r < e.length; r++) n.set(e[r], i), i += e[r].length;\n\n                      return n;\n\n                    case \"nodebuffer\":\n                      return Buffer.concat(e);\n\n                    default:\n                      throw new Error(\"concat : unsupported type '\" + t + \"'\");\n                  }\n                }(n, i), a);\n\n                e(t);\n              } catch (t) {\n                r(t);\n              }\n\n              i = [];\n            }).resume();\n          });\n        }\n\n        function f(t, e, r) {\n          var i = e;\n\n          switch (e) {\n            case \"blob\":\n            case \"arraybuffer\":\n              i = \"uint8array\";\n              break;\n\n            case \"base64\":\n              i = \"string\";\n          }\n\n          try {\n            this._internalType = i, this._outputType = e, this._mimeType = r, h.checkSupport(i), this._worker = t.pipe(new n(i)), t.lock();\n          } catch (t) {\n            this._worker = new s(\"error\"), this._worker.error(t);\n          }\n        }\n\n        f.prototype = {\n          accumulate: function (t) {\n            return l(this, t);\n          },\n          on: function (t, e) {\n            var r = this;\n            return \"data\" === t ? this._worker.on(t, function (t) {\n              e.call(r, t.data, t.meta);\n            }) : this._worker.on(t, function () {\n              h.delay(e, arguments, r);\n            }), this;\n          },\n          resume: function () {\n            return h.delay(this._worker.resume, [], this._worker), this;\n          },\n          pause: function () {\n            return this._worker.pause(), this;\n          },\n          toNodejsStream: function (t) {\n            if (h.checkSupport(\"nodestream\"), \"nodebuffer\" !== this._outputType) throw new Error(this._outputType + \" is not supported by this method\");\n            return new o(this, {\n              objectMode: \"nodebuffer\" !== this._outputType\n            }, t);\n          }\n        }, e.exports = f;\n      }, {\n        \"../base64\": 1,\n        \"../external\": 6,\n        \"../nodejs/NodejsStreamOutputAdapter\": 13,\n        \"../support\": 30,\n        \"../utils\": 32,\n        \"./ConvertWorker\": 24,\n        \"./GenericWorker\": 28\n      }],\n      30: [function (t, e, r) {\n        \"use strict\";\n\n        if (r.base64 = !0, r.array = !0, r.string = !0, r.arraybuffer = \"undefined\" != typeof ArrayBuffer && \"undefined\" != typeof Uint8Array, r.nodebuffer = \"undefined\" != typeof Buffer, r.uint8array = \"undefined\" != typeof Uint8Array, \"undefined\" == typeof ArrayBuffer) r.blob = !1;else {\n          var i = new ArrayBuffer(0);\n\n          try {\n            r.blob = 0 === new Blob([i], {\n              type: \"application/zip\"\n            }).size;\n          } catch (t) {\n            try {\n              var n = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();\n              n.append(i), r.blob = 0 === n.getBlob(\"application/zip\").size;\n            } catch (t) {\n              r.blob = !1;\n            }\n          }\n        }\n\n        try {\n          r.nodestream = !!t(\"readable-stream\").Readable;\n        } catch (t) {\n          r.nodestream = !1;\n        }\n      }, {\n        \"readable-stream\": 16\n      }],\n      31: [function (t, e, s) {\n        \"use strict\";\n\n        for (var o = t(\"./utils\"), h = t(\"./support\"), r = t(\"./nodejsUtils\"), i = t(\"./stream/GenericWorker\"), u = new Array(256), n = 0; n < 256; n++) u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;\n\n        u[254] = u[254] = 1;\n\n        function a() {\n          i.call(this, \"utf-8 decode\"), this.leftOver = null;\n        }\n\n        function l() {\n          i.call(this, \"utf-8 encode\");\n        }\n\n        s.utf8encode = function (t) {\n          return h.nodebuffer ? r.newBufferFrom(t, \"utf-8\") : function (t) {\n            var e,\n                r,\n                i,\n                n,\n                s,\n                a = t.length,\n                o = 0;\n\n            for (n = 0; n < a; n++) 55296 == (64512 & (r = t.charCodeAt(n))) && n + 1 < a && 56320 == (64512 & (i = t.charCodeAt(n + 1))) && (r = 65536 + (r - 55296 << 10) + (i - 56320), n++), o += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;\n\n            for (e = h.uint8array ? new Uint8Array(o) : new Array(o), n = s = 0; s < o; n++) 55296 == (64512 & (r = t.charCodeAt(n))) && n + 1 < a && 56320 == (64512 & (i = t.charCodeAt(n + 1))) && (r = 65536 + (r - 55296 << 10) + (i - 56320), n++), r < 128 ? e[s++] = r : (r < 2048 ? e[s++] = 192 | r >>> 6 : (r < 65536 ? e[s++] = 224 | r >>> 12 : (e[s++] = 240 | r >>> 18, e[s++] = 128 | r >>> 12 & 63), e[s++] = 128 | r >>> 6 & 63), e[s++] = 128 | 63 & r);\n\n            return e;\n          }(t);\n        }, s.utf8decode = function (t) {\n          return h.nodebuffer ? o.transformTo(\"nodebuffer\", t).toString(\"utf-8\") : function (t) {\n            var e,\n                r,\n                i,\n                n,\n                s = t.length,\n                a = new Array(2 * s);\n\n            for (e = r = 0; e < s;) if ((i = t[e++]) < 128) a[r++] = i;else if (4 < (n = u[i])) a[r++] = 65533, e += n - 1;else {\n              for (i &= 2 === n ? 31 : 3 === n ? 15 : 7; 1 < n && e < s;) i = i << 6 | 63 & t[e++], n--;\n\n              1 < n ? a[r++] = 65533 : i < 65536 ? a[r++] = i : (i -= 65536, a[r++] = 55296 | i >> 10 & 1023, a[r++] = 56320 | 1023 & i);\n            }\n\n            return a.length !== r && (a.subarray ? a = a.subarray(0, r) : a.length = r), o.applyFromCharCode(a);\n          }(t = o.transformTo(h.uint8array ? \"uint8array\" : \"array\", t));\n        }, o.inherits(a, i), a.prototype.processChunk = function (t) {\n          var e = o.transformTo(h.uint8array ? \"uint8array\" : \"array\", t.data);\n\n          if (this.leftOver && this.leftOver.length) {\n            if (h.uint8array) {\n              var r = e;\n              (e = new Uint8Array(r.length + this.leftOver.length)).set(this.leftOver, 0), e.set(r, this.leftOver.length);\n            } else e = this.leftOver.concat(e);\n\n            this.leftOver = null;\n          }\n\n          var i = function (t, e) {\n            var r;\n\n            for ((e = e || t.length) > t.length && (e = t.length), r = e - 1; 0 <= r && 128 == (192 & t[r]);) r--;\n\n            return r < 0 ? e : 0 === r ? e : r + u[t[r]] > e ? r : e;\n          }(e),\n              n = e;\n\n          i !== e.length && (h.uint8array ? (n = e.subarray(0, i), this.leftOver = e.subarray(i, e.length)) : (n = e.slice(0, i), this.leftOver = e.slice(i, e.length))), this.push({\n            data: s.utf8decode(n),\n            meta: t.meta\n          });\n        }, a.prototype.flush = function () {\n          this.leftOver && this.leftOver.length && (this.push({\n            data: s.utf8decode(this.leftOver),\n            meta: {}\n          }), this.leftOver = null);\n        }, s.Utf8DecodeWorker = a, o.inherits(l, i), l.prototype.processChunk = function (t) {\n          this.push({\n            data: s.utf8encode(t.data),\n            meta: t.meta\n          });\n        }, s.Utf8EncodeWorker = l;\n      }, {\n        \"./nodejsUtils\": 14,\n        \"./stream/GenericWorker\": 28,\n        \"./support\": 30,\n        \"./utils\": 32\n      }],\n      32: [function (t, e, a) {\n        \"use strict\";\n\n        var o = t(\"./support\"),\n            h = t(\"./base64\"),\n            r = t(\"./nodejsUtils\"),\n            i = t(\"set-immediate-shim\"),\n            u = t(\"./external\");\n\n        function n(t) {\n          return t;\n        }\n\n        function l(t, e) {\n          for (var r = 0; r < t.length; ++r) e[r] = 255 & t.charCodeAt(r);\n\n          return e;\n        }\n\n        a.newBlob = function (e, r) {\n          a.checkSupport(\"blob\");\n\n          try {\n            return new Blob([e], {\n              type: r\n            });\n          } catch (t) {\n            try {\n              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();\n              return i.append(e), i.getBlob(r);\n            } catch (t) {\n              throw new Error(\"Bug : can't construct the Blob.\");\n            }\n          }\n        };\n\n        var s = {\n          stringifyByChunk: function (t, e, r) {\n            var i = [],\n                n = 0,\n                s = t.length;\n            if (s <= r) return String.fromCharCode.apply(null, t);\n\n            for (; n < s;) \"array\" === e || \"nodebuffer\" === e ? i.push(String.fromCharCode.apply(null, t.slice(n, Math.min(n + r, s)))) : i.push(String.fromCharCode.apply(null, t.subarray(n, Math.min(n + r, s)))), n += r;\n\n            return i.join(\"\");\n          },\n          stringifyByChar: function (t) {\n            for (var e = \"\", r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);\n\n            return e;\n          },\n          applyCanBeUsed: {\n            uint8array: function () {\n              try {\n                return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;\n              } catch (t) {\n                return !1;\n              }\n            }(),\n            nodebuffer: function () {\n              try {\n                return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;\n              } catch (t) {\n                return !1;\n              }\n            }()\n          }\n        };\n\n        function f(t) {\n          var e = 65536,\n              r = a.getTypeOf(t),\n              i = !0;\n          if (\"uint8array\" === r ? i = s.applyCanBeUsed.uint8array : \"nodebuffer\" === r && (i = s.applyCanBeUsed.nodebuffer), i) for (; 1 < e;) try {\n            return s.stringifyByChunk(t, r, e);\n          } catch (t) {\n            e = Math.floor(e / 2);\n          }\n          return s.stringifyByChar(t);\n        }\n\n        function d(t, e) {\n          for (var r = 0; r < t.length; r++) e[r] = t[r];\n\n          return e;\n        }\n\n        a.applyFromCharCode = f;\n        var c = {};\n        c.string = {\n          string: n,\n          array: function (t) {\n            return l(t, new Array(t.length));\n          },\n          arraybuffer: function (t) {\n            return c.string.uint8array(t).buffer;\n          },\n          uint8array: function (t) {\n            return l(t, new Uint8Array(t.length));\n          },\n          nodebuffer: function (t) {\n            return l(t, r.allocBuffer(t.length));\n          }\n        }, c.array = {\n          string: f,\n          array: n,\n          arraybuffer: function (t) {\n            return new Uint8Array(t).buffer;\n          },\n          uint8array: function (t) {\n            return new Uint8Array(t);\n          },\n          nodebuffer: function (t) {\n            return r.newBufferFrom(t);\n          }\n        }, c.arraybuffer = {\n          string: function (t) {\n            return f(new Uint8Array(t));\n          },\n          array: function (t) {\n            return d(new Uint8Array(t), new Array(t.byteLength));\n          },\n          arraybuffer: n,\n          uint8array: function (t) {\n            return new Uint8Array(t);\n          },\n          nodebuffer: function (t) {\n            return r.newBufferFrom(new Uint8Array(t));\n          }\n        }, c.uint8array = {\n          string: f,\n          array: function (t) {\n            return d(t, new Array(t.length));\n          },\n          arraybuffer: function (t) {\n            return t.buffer;\n          },\n          uint8array: n,\n          nodebuffer: function (t) {\n            return r.newBufferFrom(t);\n          }\n        }, c.nodebuffer = {\n          string: f,\n          array: function (t) {\n            return d(t, new Array(t.length));\n          },\n          arraybuffer: function (t) {\n            return c.nodebuffer.uint8array(t).buffer;\n          },\n          uint8array: function (t) {\n            return d(t, new Uint8Array(t.length));\n          },\n          nodebuffer: n\n        }, a.transformTo = function (t, e) {\n          if (e = e || \"\", !t) return e;\n          a.checkSupport(t);\n          var r = a.getTypeOf(e);\n          return c[r][t](e);\n        }, a.getTypeOf = function (t) {\n          return \"string\" == typeof t ? \"string\" : \"[object Array]\" === Object.prototype.toString.call(t) ? \"array\" : o.nodebuffer && r.isBuffer(t) ? \"nodebuffer\" : o.uint8array && t instanceof Uint8Array ? \"uint8array\" : o.arraybuffer && t instanceof ArrayBuffer ? \"arraybuffer\" : void 0;\n        }, a.checkSupport = function (t) {\n          if (!o[t.toLowerCase()]) throw new Error(t + \" is not supported by this platform\");\n        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function (t) {\n          var e,\n              r,\n              i = \"\";\n\n          for (r = 0; r < (t || \"\").length; r++) i += \"\\\\x\" + ((e = t.charCodeAt(r)) < 16 ? \"0\" : \"\") + e.toString(16).toUpperCase();\n\n          return i;\n        }, a.delay = function (t, e, r) {\n          i(function () {\n            t.apply(r || null, e || []);\n          });\n        }, a.inherits = function (t, e) {\n          function r() {}\n\n          r.prototype = e.prototype, t.prototype = new r();\n        }, a.extend = function () {\n          var t,\n              e,\n              r = {};\n\n          for (t = 0; t < arguments.length; t++) for (e in arguments[t]) arguments[t].hasOwnProperty(e) && void 0 === r[e] && (r[e] = arguments[t][e]);\n\n          return r;\n        }, a.prepareContent = function (r, t, i, n, s) {\n          return u.Promise.resolve(t).then(function (i) {\n            return o.blob && (i instanceof Blob || -1 !== [\"[object File]\", \"[object Blob]\"].indexOf(Object.prototype.toString.call(i))) && \"undefined\" != typeof FileReader ? new u.Promise(function (e, r) {\n              var t = new FileReader();\n              t.onload = function (t) {\n                e(t.target.result);\n              }, t.onerror = function (t) {\n                r(t.target.error);\n              }, t.readAsArrayBuffer(i);\n            }) : i;\n          }).then(function (t) {\n            var e = a.getTypeOf(t);\n            return e ? (\"arraybuffer\" === e ? t = a.transformTo(\"uint8array\", t) : \"string\" === e && (s ? t = h.decode(t) : i && !0 !== n && (t = function (t) {\n              return l(t, o.uint8array ? new Uint8Array(t.length) : new Array(t.length));\n            }(t))), t) : u.Promise.reject(new Error(\"Can't read the data of '\" + r + \"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\"));\n          });\n        };\n      }, {\n        \"./base64\": 1,\n        \"./external\": 6,\n        \"./nodejsUtils\": 14,\n        \"./support\": 30,\n        \"set-immediate-shim\": 54\n      }],\n      33: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"./reader/readerFor\"),\n            n = t(\"./utils\"),\n            s = t(\"./signature\"),\n            a = t(\"./zipEntry\"),\n            o = (t(\"./utf8\"), t(\"./support\"));\n\n        function h(t) {\n          this.files = [], this.loadOptions = t;\n        }\n\n        h.prototype = {\n          checkSignature: function (t) {\n            if (!this.reader.readAndCheckSignature(t)) {\n              this.reader.index -= 4;\n              var e = this.reader.readString(4);\n              throw new Error(\"Corrupted zip or bug: unexpected signature (\" + n.pretty(e) + \", expected \" + n.pretty(t) + \")\");\n            }\n          },\n          isSignature: function (t, e) {\n            var r = this.reader.index;\n            this.reader.setIndex(t);\n            var i = this.reader.readString(4) === e;\n            return this.reader.setIndex(r), i;\n          },\n          readBlockEndOfCentral: function () {\n            this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);\n            var t = this.reader.readData(this.zipCommentLength),\n                e = o.uint8array ? \"uint8array\" : \"array\",\n                r = n.transformTo(e, t);\n            this.zipComment = this.loadOptions.decodeFileName(r);\n          },\n          readBlockZip64EndOfCentral: function () {\n            this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};\n\n            for (var t, e, r, i = this.zip64EndOfCentralSize - 44; 0 < i;) t = this.reader.readInt(2), e = this.reader.readInt(4), r = this.reader.readData(e), this.zip64ExtensibleData[t] = {\n              id: t,\n              length: e,\n              value: r\n            };\n          },\n          readBlockZip64EndOfCentralLocator: function () {\n            if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error(\"Multi-volumes zip are not supported\");\n          },\n          readLocalFiles: function () {\n            var t, e;\n\n            for (t = 0; t < this.files.length; t++) e = this.files[t], this.reader.setIndex(e.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), e.readLocalPart(this.reader), e.handleUTF8(), e.processAttributes();\n          },\n          readCentralDir: function () {\n            var t;\n\n            for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);) (t = new a({\n              zip64: this.zip64\n            }, this.loadOptions)).readCentralPart(this.reader), this.files.push(t);\n\n            if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error(\"Corrupted zip or bug: expected \" + this.centralDirRecords + \" records in central dir, got \" + this.files.length);\n          },\n          readEndOfCentral: function () {\n            var t = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);\n            if (t < 0) throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error(\"Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html\") : new Error(\"Corrupted zip: can't find end of central directory\");\n            this.reader.setIndex(t);\n            var e = t;\n\n            if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === n.MAX_VALUE_16BITS || this.diskWithCentralDirStart === n.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === n.MAX_VALUE_16BITS || this.centralDirRecords === n.MAX_VALUE_16BITS || this.centralDirSize === n.MAX_VALUE_32BITS || this.centralDirOffset === n.MAX_VALUE_32BITS) {\n              if (this.zip64 = !0, (t = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");\n              if (this.reader.setIndex(t), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");\n              this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();\n            }\n\n            var r = this.centralDirOffset + this.centralDirSize;\n            this.zip64 && (r += 20, r += 12 + this.zip64EndOfCentralSize);\n            var i = e - r;\n            if (0 < i) this.isSignature(e, s.CENTRAL_FILE_HEADER) || (this.reader.zero = i);else if (i < 0) throw new Error(\"Corrupted zip: missing \" + Math.abs(i) + \" bytes.\");\n          },\n          prepareReader: function (t) {\n            this.reader = i(t);\n          },\n          load: function (t) {\n            this.prepareReader(t), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();\n          }\n        }, e.exports = h;\n      }, {\n        \"./reader/readerFor\": 22,\n        \"./signature\": 23,\n        \"./support\": 30,\n        \"./utf8\": 31,\n        \"./utils\": 32,\n        \"./zipEntry\": 34\n      }],\n      34: [function (t, e, r) {\n        \"use strict\";\n\n        var i = t(\"./reader/readerFor\"),\n            s = t(\"./utils\"),\n            n = t(\"./compressedObject\"),\n            a = t(\"./crc32\"),\n            o = t(\"./utf8\"),\n            h = t(\"./compressions\"),\n            u = t(\"./support\");\n\n        function l(t, e) {\n          this.options = t, this.loadOptions = e;\n        }\n\n        l.prototype = {\n          isEncrypted: function () {\n            return 1 == (1 & this.bitFlag);\n          },\n          useUTF8: function () {\n            return 2048 == (2048 & this.bitFlag);\n          },\n          readLocalPart: function (t) {\n            var e, r;\n            if (t.skip(22), this.fileNameLength = t.readInt(2), r = t.readInt(2), this.fileName = t.readData(this.fileNameLength), t.skip(r), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error(\"Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)\");\n            if (null === (e = function (t) {\n              for (var e in h) if (h.hasOwnProperty(e) && h[e].magic === t) return h[e];\n\n              return null;\n            }(this.compressionMethod))) throw new Error(\"Corrupted zip : compression \" + s.pretty(this.compressionMethod) + \" unknown (inner file : \" + s.transformTo(\"string\", this.fileName) + \")\");\n            this.decompressed = new n(this.compressedSize, this.uncompressedSize, this.crc32, e, t.readData(this.compressedSize));\n          },\n          readCentralPart: function (t) {\n            this.versionMadeBy = t.readInt(2), t.skip(2), this.bitFlag = t.readInt(2), this.compressionMethod = t.readString(2), this.date = t.readDate(), this.crc32 = t.readInt(4), this.compressedSize = t.readInt(4), this.uncompressedSize = t.readInt(4);\n            var e = t.readInt(2);\n            if (this.extraFieldsLength = t.readInt(2), this.fileCommentLength = t.readInt(2), this.diskNumberStart = t.readInt(2), this.internalFileAttributes = t.readInt(2), this.externalFileAttributes = t.readInt(4), this.localHeaderOffset = t.readInt(4), this.isEncrypted()) throw new Error(\"Encrypted zip are not supported\");\n            t.skip(e), this.readExtraFields(t), this.parseZIP64ExtraField(t), this.fileComment = t.readData(this.fileCommentLength);\n          },\n          processAttributes: function () {\n            this.unixPermissions = null, this.dosPermissions = null;\n            var t = this.versionMadeBy >> 8;\n            this.dir = !!(16 & this.externalFileAttributes), 0 == t && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == t && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || \"/\" !== this.fileNameStr.slice(-1) || (this.dir = !0);\n          },\n          parseZIP64ExtraField: function (t) {\n            if (this.extraFields[1]) {\n              var e = i(this.extraFields[1].value);\n              this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e.readInt(4));\n            }\n          },\n          readExtraFields: function (t) {\n            var e,\n                r,\n                i,\n                n = t.index + this.extraFieldsLength;\n\n            for (this.extraFields || (this.extraFields = {}); t.index + 4 < n;) e = t.readInt(2), r = t.readInt(2), i = t.readData(r), this.extraFields[e] = {\n              id: e,\n              length: r,\n              value: i\n            };\n\n            t.setIndex(n);\n          },\n          handleUTF8: function () {\n            var t = u.uint8array ? \"uint8array\" : \"array\";\n            if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);else {\n              var e = this.findExtraFieldUnicodePath();\n              if (null !== e) this.fileNameStr = e;else {\n                var r = s.transformTo(t, this.fileName);\n                this.fileNameStr = this.loadOptions.decodeFileName(r);\n              }\n              var i = this.findExtraFieldUnicodeComment();\n              if (null !== i) this.fileCommentStr = i;else {\n                var n = s.transformTo(t, this.fileComment);\n                this.fileCommentStr = this.loadOptions.decodeFileName(n);\n              }\n            }\n          },\n          findExtraFieldUnicodePath: function () {\n            var t = this.extraFields[28789];\n\n            if (t) {\n              var e = i(t.value);\n              return 1 !== e.readInt(1) ? null : a(this.fileName) !== e.readInt(4) ? null : o.utf8decode(e.readData(t.length - 5));\n            }\n\n            return null;\n          },\n          findExtraFieldUnicodeComment: function () {\n            var t = this.extraFields[25461];\n\n            if (t) {\n              var e = i(t.value);\n              return 1 !== e.readInt(1) ? null : a(this.fileComment) !== e.readInt(4) ? null : o.utf8decode(e.readData(t.length - 5));\n            }\n\n            return null;\n          }\n        }, e.exports = l;\n      }, {\n        \"./compressedObject\": 2,\n        \"./compressions\": 3,\n        \"./crc32\": 4,\n        \"./reader/readerFor\": 22,\n        \"./support\": 30,\n        \"./utf8\": 31,\n        \"./utils\": 32\n      }],\n      35: [function (t, e, r) {\n        \"use strict\";\n\n        function i(t, e, r) {\n          this.name = t, this.dir = r.dir, this.date = r.date, this.comment = r.comment, this.unixPermissions = r.unixPermissions, this.dosPermissions = r.dosPermissions, this._data = e, this._dataBinary = r.binary, this.options = {\n            compression: r.compression,\n            compressionOptions: r.compressionOptions\n          };\n        }\n\n        var s = t(\"./stream/StreamHelper\"),\n            n = t(\"./stream/DataWorker\"),\n            a = t(\"./utf8\"),\n            o = t(\"./compressedObject\"),\n            h = t(\"./stream/GenericWorker\");\n        i.prototype = {\n          internalStream: function (t) {\n            var e = null,\n                r = \"string\";\n\n            try {\n              if (!t) throw new Error(\"No output type specified.\");\n              var i = \"string\" === (r = t.toLowerCase()) || \"text\" === r;\n              \"binarystring\" !== r && \"text\" !== r || (r = \"string\"), e = this._decompressWorker();\n              var n = !this._dataBinary;\n              n && !i && (e = e.pipe(new a.Utf8EncodeWorker())), !n && i && (e = e.pipe(new a.Utf8DecodeWorker()));\n            } catch (t) {\n              (e = new h(\"error\")).error(t);\n            }\n\n            return new s(e, r, \"\");\n          },\n          async: function (t, e) {\n            return this.internalStream(t).accumulate(e);\n          },\n          nodeStream: function (t, e) {\n            return this.internalStream(t || \"nodebuffer\").toNodejsStream(e);\n          },\n          _compressWorker: function (t, e) {\n            if (this._data instanceof o && this._data.compression.magic === t.magic) return this._data.getCompressedWorker();\n\n            var r = this._decompressWorker();\n\n            return this._dataBinary || (r = r.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r, t, e);\n          },\n          _decompressWorker: function () {\n            return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new n(this._data);\n          }\n        };\n\n        for (var u = [\"asText\", \"asBinary\", \"asNodeBuffer\", \"asUint8Array\", \"asArrayBuffer\"], l = function () {\n          throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n        }, f = 0; f < u.length; f++) i.prototype[u[f]] = l;\n\n        e.exports = i;\n      }, {\n        \"./compressedObject\": 2,\n        \"./stream/DataWorker\": 27,\n        \"./stream/GenericWorker\": 28,\n        \"./stream/StreamHelper\": 29,\n        \"./utf8\": 31\n      }],\n      36: [function (t, l, e) {\n        (function (e) {\n          \"use strict\";\n\n          var r,\n              i,\n              t = e.MutationObserver || e.WebKitMutationObserver;\n\n          if (t) {\n            var n = 0,\n                s = new t(u),\n                a = e.document.createTextNode(\"\");\n            s.observe(a, {\n              characterData: !0\n            }), r = function () {\n              a.data = n = ++n % 2;\n            };\n          } else if (e.setImmediate || void 0 === e.MessageChannel) r = \"document\" in e && \"onreadystatechange\" in e.document.createElement(\"script\") ? function () {\n            var t = e.document.createElement(\"script\");\n            t.onreadystatechange = function () {\n              u(), t.onreadystatechange = null, t.parentNode.removeChild(t), t = null;\n            }, e.document.documentElement.appendChild(t);\n          } : function () {\n            setTimeout(u, 0);\n          };else {\n            var o = new e.MessageChannel();\n            o.port1.onmessage = u, r = function () {\n              o.port2.postMessage(0);\n            };\n          }\n\n          var h = [];\n\n          function u() {\n            var t, e;\n            i = !0;\n\n            for (var r = h.length; r;) {\n              for (e = h, h = [], t = -1; ++t < r;) e[t]();\n\n              r = h.length;\n            }\n\n            i = !1;\n          }\n\n          l.exports = function (t) {\n            1 !== h.push(t) || i || r();\n          };\n        }).call(this, \"undefined\" != typeof commonjsGlobal ? commonjsGlobal : \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : {});\n      }, {}],\n      37: [function (t, e, r) {\n        \"use strict\";\n\n        var n = t(\"immediate\");\n\n        function u() {}\n\n        var l = {},\n            s = [\"REJECTED\"],\n            a = [\"FULFILLED\"],\n            i = [\"PENDING\"];\n\n        function o(t) {\n          if (\"function\" != typeof t) throw new TypeError(\"resolver must be a function\");\n          this.state = i, this.queue = [], this.outcome = void 0, t !== u && c(this, t);\n        }\n\n        function h(t, e, r) {\n          this.promise = t, \"function\" == typeof e && (this.onFulfilled = e, this.callFulfilled = this.otherCallFulfilled), \"function\" == typeof r && (this.onRejected = r, this.callRejected = this.otherCallRejected);\n        }\n\n        function f(e, r, i) {\n          n(function () {\n            var t;\n\n            try {\n              t = r(i);\n            } catch (t) {\n              return l.reject(e, t);\n            }\n\n            t === e ? l.reject(e, new TypeError(\"Cannot resolve promise with itself\")) : l.resolve(e, t);\n          });\n        }\n\n        function d(t) {\n          var e = t && t.then;\n          if (t && (\"object\" == typeof t || \"function\" == typeof t) && \"function\" == typeof e) return function () {\n            e.apply(t, arguments);\n          };\n        }\n\n        function c(e, t) {\n          var r = !1;\n\n          function i(t) {\n            r || (r = !0, l.reject(e, t));\n          }\n\n          function n(t) {\n            r || (r = !0, l.resolve(e, t));\n          }\n\n          var s = p(function () {\n            t(n, i);\n          });\n          \"error\" === s.status && i(s.value);\n        }\n\n        function p(t, e) {\n          var r = {};\n\n          try {\n            r.value = t(e), r.status = \"success\";\n          } catch (t) {\n            r.status = \"error\", r.value = t;\n          }\n\n          return r;\n        }\n\n        (e.exports = o).prototype.finally = function (e) {\n          if (\"function\" != typeof e) return this;\n          var r = this.constructor;\n          return this.then(function (t) {\n            return r.resolve(e()).then(function () {\n              return t;\n            });\n          }, function (t) {\n            return r.resolve(e()).then(function () {\n              throw t;\n            });\n          });\n        }, o.prototype.catch = function (t) {\n          return this.then(null, t);\n        }, o.prototype.then = function (t, e) {\n          if (\"function\" != typeof t && this.state === a || \"function\" != typeof e && this.state === s) return this;\n          var r = new this.constructor(u);\n          this.state !== i ? f(r, this.state === a ? t : e, this.outcome) : this.queue.push(new h(r, t, e));\n          return r;\n        }, h.prototype.callFulfilled = function (t) {\n          l.resolve(this.promise, t);\n        }, h.prototype.otherCallFulfilled = function (t) {\n          f(this.promise, this.onFulfilled, t);\n        }, h.prototype.callRejected = function (t) {\n          l.reject(this.promise, t);\n        }, h.prototype.otherCallRejected = function (t) {\n          f(this.promise, this.onRejected, t);\n        }, l.resolve = function (t, e) {\n          var r = p(d, e);\n          if (\"error\" === r.status) return l.reject(t, r.value);\n          var i = r.value;\n          if (i) c(t, i);else {\n            t.state = a, t.outcome = e;\n\n            for (var n = -1, s = t.queue.length; ++n < s;) t.queue[n].callFulfilled(e);\n          }\n          return t;\n        }, l.reject = function (t, e) {\n          t.state = s, t.outcome = e;\n\n          for (var r = -1, i = t.queue.length; ++r < i;) t.queue[r].callRejected(e);\n\n          return t;\n        }, o.resolve = function (t) {\n          if (t instanceof this) return t;\n          return l.resolve(new this(u), t);\n        }, o.reject = function (t) {\n          var e = new this(u);\n          return l.reject(e, t);\n        }, o.all = function (t) {\n          var r = this;\n          if (\"[object Array]\" !== Object.prototype.toString.call(t)) return this.reject(new TypeError(\"must be an array\"));\n          var i = t.length,\n              n = !1;\n          if (!i) return this.resolve([]);\n          var s = new Array(i),\n              a = 0,\n              e = -1,\n              o = new this(u);\n\n          for (; ++e < i;) h(t[e], e);\n\n          return o;\n\n          function h(t, e) {\n            r.resolve(t).then(function (t) {\n              s[e] = t, ++a !== i || n || (n = !0, l.resolve(o, s));\n            }, function (t) {\n              n || (n = !0, l.reject(o, t));\n            });\n          }\n        }, o.race = function (t) {\n          var e = this;\n          if (\"[object Array]\" !== Object.prototype.toString.call(t)) return this.reject(new TypeError(\"must be an array\"));\n          var r = t.length,\n              i = !1;\n          if (!r) return this.resolve([]);\n          var n = -1,\n              s = new this(u);\n\n          for (; ++n < r;) a = t[n], e.resolve(a).then(function (t) {\n            i || (i = !0, l.resolve(s, t));\n          }, function (t) {\n            i || (i = !0, l.reject(s, t));\n          });\n\n          var a;\n          return s;\n        };\n      }, {\n        immediate: 36\n      }],\n      38: [function (t, e, r) {\n        \"use strict\";\n\n        var i = {};\n        (0, t(\"./lib/utils/common\").assign)(i, t(\"./lib/deflate\"), t(\"./lib/inflate\"), t(\"./lib/zlib/constants\")), e.exports = i;\n      }, {\n        \"./lib/deflate\": 39,\n        \"./lib/inflate\": 40,\n        \"./lib/utils/common\": 41,\n        \"./lib/zlib/constants\": 44\n      }],\n      39: [function (t, e, r) {\n        \"use strict\";\n\n        var a = t(\"./zlib/deflate\"),\n            o = t(\"./utils/common\"),\n            h = t(\"./utils/strings\"),\n            n = t(\"./zlib/messages\"),\n            s = t(\"./zlib/zstream\"),\n            u = Object.prototype.toString,\n            l = 0,\n            f = -1,\n            d = 0,\n            c = 8;\n\n        function p(t) {\n          if (!(this instanceof p)) return new p(t);\n          this.options = o.assign({\n            level: f,\n            method: c,\n            chunkSize: 16384,\n            windowBits: 15,\n            memLevel: 8,\n            strategy: d,\n            to: \"\"\n          }, t || {});\n          var e = this.options;\n          e.raw && 0 < e.windowBits ? e.windowBits = -e.windowBits : e.gzip && 0 < e.windowBits && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = \"\", this.ended = !1, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;\n          var r = a.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);\n          if (r !== l) throw new Error(n[r]);\n\n          if (e.header && a.deflateSetHeader(this.strm, e.header), e.dictionary) {\n            var i;\n            if (i = \"string\" == typeof e.dictionary ? h.string2buf(e.dictionary) : \"[object ArrayBuffer]\" === u.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary, (r = a.deflateSetDictionary(this.strm, i)) !== l) throw new Error(n[r]);\n            this._dict_set = !0;\n          }\n        }\n\n        function i(t, e) {\n          var r = new p(e);\n          if (r.push(t, !0), r.err) throw r.msg || n[r.err];\n          return r.result;\n        }\n\n        p.prototype.push = function (t, e) {\n          var r,\n              i,\n              n = this.strm,\n              s = this.options.chunkSize;\n          if (this.ended) return !1;\n          i = e === ~~e ? e : !0 === e ? 4 : 0, \"string\" == typeof t ? n.input = h.string2buf(t) : \"[object ArrayBuffer]\" === u.call(t) ? n.input = new Uint8Array(t) : n.input = t, n.next_in = 0, n.avail_in = n.input.length;\n\n          do {\n            if (0 === n.avail_out && (n.output = new o.Buf8(s), n.next_out = 0, n.avail_out = s), 1 !== (r = a.deflate(n, i)) && r !== l) return this.onEnd(r), !(this.ended = !0);\n            0 !== n.avail_out && (0 !== n.avail_in || 4 !== i && 2 !== i) || (\"string\" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(n.output, n.next_out))) : this.onData(o.shrinkBuf(n.output, n.next_out)));\n          } while ((0 < n.avail_in || 0 === n.avail_out) && 1 !== r);\n\n          return 4 === i ? (r = a.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === l) : 2 !== i || (this.onEnd(l), !(n.avail_out = 0));\n        }, p.prototype.onData = function (t) {\n          this.chunks.push(t);\n        }, p.prototype.onEnd = function (t) {\n          t === l && (\"string\" === this.options.to ? this.result = this.chunks.join(\"\") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;\n        }, r.Deflate = p, r.deflate = i, r.deflateRaw = function (t, e) {\n          return (e = e || {}).raw = !0, i(t, e);\n        }, r.gzip = function (t, e) {\n          return (e = e || {}).gzip = !0, i(t, e);\n        };\n      }, {\n        \"./utils/common\": 41,\n        \"./utils/strings\": 42,\n        \"./zlib/deflate\": 46,\n        \"./zlib/messages\": 51,\n        \"./zlib/zstream\": 53\n      }],\n      40: [function (t, e, r) {\n        \"use strict\";\n\n        var d = t(\"./zlib/inflate\"),\n            c = t(\"./utils/common\"),\n            p = t(\"./utils/strings\"),\n            m = t(\"./zlib/constants\"),\n            i = t(\"./zlib/messages\"),\n            n = t(\"./zlib/zstream\"),\n            s = t(\"./zlib/gzheader\"),\n            _ = Object.prototype.toString;\n\n        function a(t) {\n          if (!(this instanceof a)) return new a(t);\n          this.options = c.assign({\n            chunkSize: 16384,\n            windowBits: 0,\n            to: \"\"\n          }, t || {});\n          var e = this.options;\n          e.raw && 0 <= e.windowBits && e.windowBits < 16 && (e.windowBits = -e.windowBits, 0 === e.windowBits && (e.windowBits = -15)), !(0 <= e.windowBits && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32), 15 < e.windowBits && e.windowBits < 48 && 0 == (15 & e.windowBits) && (e.windowBits |= 15), this.err = 0, this.msg = \"\", this.ended = !1, this.chunks = [], this.strm = new n(), this.strm.avail_out = 0;\n          var r = d.inflateInit2(this.strm, e.windowBits);\n          if (r !== m.Z_OK) throw new Error(i[r]);\n          this.header = new s(), d.inflateGetHeader(this.strm, this.header);\n        }\n\n        function o(t, e) {\n          var r = new a(e);\n          if (r.push(t, !0), r.err) throw r.msg || i[r.err];\n          return r.result;\n        }\n\n        a.prototype.push = function (t, e) {\n          var r,\n              i,\n              n,\n              s,\n              a,\n              o,\n              h = this.strm,\n              u = this.options.chunkSize,\n              l = this.options.dictionary,\n              f = !1;\n          if (this.ended) return !1;\n          i = e === ~~e ? e : !0 === e ? m.Z_FINISH : m.Z_NO_FLUSH, \"string\" == typeof t ? h.input = p.binstring2buf(t) : \"[object ArrayBuffer]\" === _.call(t) ? h.input = new Uint8Array(t) : h.input = t, h.next_in = 0, h.avail_in = h.input.length;\n\n          do {\n            if (0 === h.avail_out && (h.output = new c.Buf8(u), h.next_out = 0, h.avail_out = u), (r = d.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o = \"string\" == typeof l ? p.string2buf(l) : \"[object ArrayBuffer]\" === _.call(l) ? new Uint8Array(l) : l, r = d.inflateSetDictionary(this.strm, o)), r === m.Z_BUF_ERROR && !0 === f && (r = m.Z_OK, f = !1), r !== m.Z_STREAM_END && r !== m.Z_OK) return this.onEnd(r), !(this.ended = !0);\n            h.next_out && (0 !== h.avail_out && r !== m.Z_STREAM_END && (0 !== h.avail_in || i !== m.Z_FINISH && i !== m.Z_SYNC_FLUSH) || (\"string\" === this.options.to ? (n = p.utf8border(h.output, h.next_out), s = h.next_out - n, a = p.buf2string(h.output, n), h.next_out = s, h.avail_out = u - s, s && c.arraySet(h.output, h.output, n, s, 0), this.onData(a)) : this.onData(c.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = !0);\n          } while ((0 < h.avail_in || 0 === h.avail_out) && r !== m.Z_STREAM_END);\n\n          return r === m.Z_STREAM_END && (i = m.Z_FINISH), i === m.Z_FINISH ? (r = d.inflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === m.Z_OK) : i !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));\n        }, a.prototype.onData = function (t) {\n          this.chunks.push(t);\n        }, a.prototype.onEnd = function (t) {\n          t === m.Z_OK && (\"string\" === this.options.to ? this.result = this.chunks.join(\"\") : this.result = c.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;\n        }, r.Inflate = a, r.inflate = o, r.inflateRaw = function (t, e) {\n          return (e = e || {}).raw = !0, o(t, e);\n        }, r.ungzip = o;\n      }, {\n        \"./utils/common\": 41,\n        \"./utils/strings\": 42,\n        \"./zlib/constants\": 44,\n        \"./zlib/gzheader\": 47,\n        \"./zlib/inflate\": 49,\n        \"./zlib/messages\": 51,\n        \"./zlib/zstream\": 53\n      }],\n      41: [function (t, e, r) {\n        \"use strict\";\n\n        var i = \"undefined\" != typeof Uint8Array && \"undefined\" != typeof Uint16Array && \"undefined\" != typeof Int32Array;\n        r.assign = function (t) {\n          for (var e = Array.prototype.slice.call(arguments, 1); e.length;) {\n            var r = e.shift();\n\n            if (r) {\n              if (\"object\" != typeof r) throw new TypeError(r + \"must be non-object\");\n\n              for (var i in r) r.hasOwnProperty(i) && (t[i] = r[i]);\n            }\n          }\n\n          return t;\n        }, r.shrinkBuf = function (t, e) {\n          return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t);\n        };\n        var n = {\n          arraySet: function (t, e, r, i, n) {\n            if (e.subarray && t.subarray) t.set(e.subarray(r, r + i), n);else for (var s = 0; s < i; s++) t[n + s] = e[r + s];\n          },\n          flattenChunks: function (t) {\n            var e, r, i, n, s, a;\n\n            for (e = i = 0, r = t.length; e < r; e++) i += t[e].length;\n\n            for (a = new Uint8Array(i), e = n = 0, r = t.length; e < r; e++) s = t[e], a.set(s, n), n += s.length;\n\n            return a;\n          }\n        },\n            s = {\n          arraySet: function (t, e, r, i, n) {\n            for (var s = 0; s < i; s++) t[n + s] = e[r + s];\n          },\n          flattenChunks: function (t) {\n            return [].concat.apply([], t);\n          }\n        };\n        r.setTyped = function (t) {\n          t ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, n)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));\n        }, r.setTyped(i);\n      }, {}],\n      42: [function (t, e, r) {\n        \"use strict\";\n\n        var h = t(\"./common\"),\n            n = !0,\n            s = !0;\n\n        try {\n          String.fromCharCode.apply(null, [0]);\n        } catch (t) {\n          n = !1;\n        }\n\n        try {\n          String.fromCharCode.apply(null, new Uint8Array(1));\n        } catch (t) {\n          s = !1;\n        }\n\n        for (var u = new h.Buf8(256), i = 0; i < 256; i++) u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;\n\n        function l(t, e) {\n          if (e < 65537 && (t.subarray && s || !t.subarray && n)) return String.fromCharCode.apply(null, h.shrinkBuf(t, e));\n\n          for (var r = \"\", i = 0; i < e; i++) r += String.fromCharCode(t[i]);\n\n          return r;\n        }\n\n        u[254] = u[254] = 1, r.string2buf = function (t) {\n          var e,\n              r,\n              i,\n              n,\n              s,\n              a = t.length,\n              o = 0;\n\n          for (n = 0; n < a; n++) 55296 == (64512 & (r = t.charCodeAt(n))) && n + 1 < a && 56320 == (64512 & (i = t.charCodeAt(n + 1))) && (r = 65536 + (r - 55296 << 10) + (i - 56320), n++), o += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;\n\n          for (e = new h.Buf8(o), n = s = 0; s < o; n++) 55296 == (64512 & (r = t.charCodeAt(n))) && n + 1 < a && 56320 == (64512 & (i = t.charCodeAt(n + 1))) && (r = 65536 + (r - 55296 << 10) + (i - 56320), n++), r < 128 ? e[s++] = r : (r < 2048 ? e[s++] = 192 | r >>> 6 : (r < 65536 ? e[s++] = 224 | r >>> 12 : (e[s++] = 240 | r >>> 18, e[s++] = 128 | r >>> 12 & 63), e[s++] = 128 | r >>> 6 & 63), e[s++] = 128 | 63 & r);\n\n          return e;\n        }, r.buf2binstring = function (t) {\n          return l(t, t.length);\n        }, r.binstring2buf = function (t) {\n          for (var e = new h.Buf8(t.length), r = 0, i = e.length; r < i; r++) e[r] = t.charCodeAt(r);\n\n          return e;\n        }, r.buf2string = function (t, e) {\n          var r,\n              i,\n              n,\n              s,\n              a = e || t.length,\n              o = new Array(2 * a);\n\n          for (r = i = 0; r < a;) if ((n = t[r++]) < 128) o[i++] = n;else if (4 < (s = u[n])) o[i++] = 65533, r += s - 1;else {\n            for (n &= 2 === s ? 31 : 3 === s ? 15 : 7; 1 < s && r < a;) n = n << 6 | 63 & t[r++], s--;\n\n            1 < s ? o[i++] = 65533 : n < 65536 ? o[i++] = n : (n -= 65536, o[i++] = 55296 | n >> 10 & 1023, o[i++] = 56320 | 1023 & n);\n          }\n\n          return l(o, i);\n        }, r.utf8border = function (t, e) {\n          var r;\n\n          for ((e = e || t.length) > t.length && (e = t.length), r = e - 1; 0 <= r && 128 == (192 & t[r]);) r--;\n\n          return r < 0 ? e : 0 === r ? e : r + u[t[r]] > e ? r : e;\n        };\n      }, {\n        \"./common\": 41\n      }],\n      43: [function (t, e, r) {\n        \"use strict\";\n\n        e.exports = function (t, e, r, i) {\n          for (var n = 65535 & t | 0, s = t >>> 16 & 65535 | 0, a = 0; 0 !== r;) {\n            for (r -= a = 2e3 < r ? 2e3 : r; s = s + (n = n + e[i++] | 0) | 0, --a;);\n\n            n %= 65521, s %= 65521;\n          }\n\n          return n | s << 16 | 0;\n        };\n      }, {}],\n      44: [function (t, e, r) {\n        \"use strict\";\n\n        e.exports = {\n          Z_NO_FLUSH: 0,\n          Z_PARTIAL_FLUSH: 1,\n          Z_SYNC_FLUSH: 2,\n          Z_FULL_FLUSH: 3,\n          Z_FINISH: 4,\n          Z_BLOCK: 5,\n          Z_TREES: 6,\n          Z_OK: 0,\n          Z_STREAM_END: 1,\n          Z_NEED_DICT: 2,\n          Z_ERRNO: -1,\n          Z_STREAM_ERROR: -2,\n          Z_DATA_ERROR: -3,\n          Z_BUF_ERROR: -5,\n          Z_NO_COMPRESSION: 0,\n          Z_BEST_SPEED: 1,\n          Z_BEST_COMPRESSION: 9,\n          Z_DEFAULT_COMPRESSION: -1,\n          Z_FILTERED: 1,\n          Z_HUFFMAN_ONLY: 2,\n          Z_RLE: 3,\n          Z_FIXED: 4,\n          Z_DEFAULT_STRATEGY: 0,\n          Z_BINARY: 0,\n          Z_TEXT: 1,\n          Z_UNKNOWN: 2,\n          Z_DEFLATED: 8\n        };\n      }, {}],\n      45: [function (t, e, r) {\n        \"use strict\";\n\n        var o = function () {\n          for (var t, e = [], r = 0; r < 256; r++) {\n            t = r;\n\n            for (var i = 0; i < 8; i++) t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;\n\n            e[r] = t;\n          }\n\n          return e;\n        }();\n\n        e.exports = function (t, e, r, i) {\n          var n = o,\n              s = i + r;\n          t ^= -1;\n\n          for (var a = i; a < s; a++) t = t >>> 8 ^ n[255 & (t ^ e[a])];\n\n          return -1 ^ t;\n        };\n      }, {}],\n      46: [function (t, e, r) {\n        \"use strict\";\n\n        var h,\n            d = t(\"../utils/common\"),\n            u = t(\"./trees\"),\n            c = t(\"./adler32\"),\n            p = t(\"./crc32\"),\n            i = t(\"./messages\"),\n            l = 0,\n            f = 4,\n            m = 0,\n            _ = -2,\n            g = -1,\n            b = 4,\n            n = 2,\n            v = 8,\n            y = 9,\n            s = 286,\n            a = 30,\n            o = 19,\n            w = 2 * s + 1,\n            k = 15,\n            x = 3,\n            S = 258,\n            z = S + x + 1,\n            C = 42,\n            E = 113,\n            A = 1,\n            I = 2,\n            O = 3,\n            B = 4;\n\n        function R(t, e) {\n          return t.msg = i[e], e;\n        }\n\n        function T(t) {\n          return (t << 1) - (4 < t ? 9 : 0);\n        }\n\n        function D(t) {\n          for (var e = t.length; 0 <= --e;) t[e] = 0;\n        }\n\n        function F(t) {\n          var e = t.state,\n              r = e.pending;\n          r > t.avail_out && (r = t.avail_out), 0 !== r && (d.arraySet(t.output, e.pending_buf, e.pending_out, r, t.next_out), t.next_out += r, e.pending_out += r, t.total_out += r, t.avail_out -= r, e.pending -= r, 0 === e.pending && (e.pending_out = 0));\n        }\n\n        function N(t, e) {\n          u._tr_flush_block(t, 0 <= t.block_start ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, F(t.strm);\n        }\n\n        function U(t, e) {\n          t.pending_buf[t.pending++] = e;\n        }\n\n        function P(t, e) {\n          t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e;\n        }\n\n        function L(t, e) {\n          var r,\n              i,\n              n = t.max_chain_length,\n              s = t.strstart,\n              a = t.prev_length,\n              o = t.nice_match,\n              h = t.strstart > t.w_size - z ? t.strstart - (t.w_size - z) : 0,\n              u = t.window,\n              l = t.w_mask,\n              f = t.prev,\n              d = t.strstart + S,\n              c = u[s + a - 1],\n              p = u[s + a];\n          t.prev_length >= t.good_match && (n >>= 2), o > t.lookahead && (o = t.lookahead);\n\n          do {\n            if (u[(r = e) + a] === p && u[r + a - 1] === c && u[r] === u[s] && u[++r] === u[s + 1]) {\n              s += 2, r++;\n\n              do {} while (u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && s < d);\n\n              if (i = S - (d - s), s = d - S, a < i) {\n                if (t.match_start = e, o <= (a = i)) break;\n                c = u[s + a - 1], p = u[s + a];\n              }\n            }\n          } while ((e = f[e & l]) > h && 0 != --n);\n\n          return a <= t.lookahead ? a : t.lookahead;\n        }\n\n        function j(t) {\n          var e,\n              r,\n              i,\n              n,\n              s,\n              a,\n              o,\n              h,\n              u,\n              l,\n              f = t.w_size;\n\n          do {\n            if (n = t.window_size - t.lookahead - t.strstart, t.strstart >= f + (f - z)) {\n              for (d.arraySet(t.window, t.window, f, f, 0), t.match_start -= f, t.strstart -= f, t.block_start -= f, e = r = t.hash_size; i = t.head[--e], t.head[e] = f <= i ? i - f : 0, --r;);\n\n              for (e = r = f; i = t.prev[--e], t.prev[e] = f <= i ? i - f : 0, --r;);\n\n              n += f;\n            }\n\n            if (0 === t.strm.avail_in) break;\n            if (a = t.strm, o = t.window, h = t.strstart + t.lookahead, u = n, l = void 0, l = a.avail_in, u < l && (l = u), r = 0 === l ? 0 : (a.avail_in -= l, d.arraySet(o, a.input, a.next_in, l, h), 1 === a.state.wrap ? a.adler = c(a.adler, o, l, h) : 2 === a.state.wrap && (a.adler = p(a.adler, o, l, h)), a.next_in += l, a.total_in += l, l), t.lookahead += r, t.lookahead + t.insert >= x) for (s = t.strstart - t.insert, t.ins_h = t.window[s], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[s + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[s + x - 1]) & t.hash_mask, t.prev[s & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = s, s++, t.insert--, !(t.lookahead + t.insert < x)););\n          } while (t.lookahead < z && 0 !== t.strm.avail_in);\n        }\n\n        function Z(t, e) {\n          for (var r, i;;) {\n            if (t.lookahead < z) {\n              if (j(t), t.lookahead < z && e === l) return A;\n              if (0 === t.lookahead) break;\n            }\n\n            if (r = 0, t.lookahead >= x && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + x - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== r && t.strstart - r <= t.w_size - z && (t.match_length = L(t, r)), t.match_length >= x) {\n              if (i = u._tr_tally(t, t.strstart - t.match_start, t.match_length - x), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= x) {\n                for (t.match_length--; t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + x - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart, 0 != --t.match_length;);\n\n                t.strstart++;\n              } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask;\n            } else i = u._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;\n            if (i && (N(t, !1), 0 === t.strm.avail_out)) return A;\n          }\n\n          return t.insert = t.strstart < x - 1 ? t.strstart : x - 1, e === f ? (N(t, !0), 0 === t.strm.avail_out ? O : B) : t.last_lit && (N(t, !1), 0 === t.strm.avail_out) ? A : I;\n        }\n\n        function W(t, e) {\n          for (var r, i, n;;) {\n            if (t.lookahead < z) {\n              if (j(t), t.lookahead < z && e === l) return A;\n              if (0 === t.lookahead) break;\n            }\n\n            if (r = 0, t.lookahead >= x && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + x - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = x - 1, 0 !== r && t.prev_length < t.max_lazy_match && t.strstart - r <= t.w_size - z && (t.match_length = L(t, r), t.match_length <= 5 && (1 === t.strategy || t.match_length === x && 4096 < t.strstart - t.match_start) && (t.match_length = x - 1)), t.prev_length >= x && t.match_length <= t.prev_length) {\n              for (n = t.strstart + t.lookahead - x, i = u._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - x), t.lookahead -= t.prev_length - 1, t.prev_length -= 2; ++t.strstart <= n && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + x - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 != --t.prev_length;);\n\n              if (t.match_available = 0, t.match_length = x - 1, t.strstart++, i && (N(t, !1), 0 === t.strm.avail_out)) return A;\n            } else if (t.match_available) {\n              if ((i = u._tr_tally(t, 0, t.window[t.strstart - 1])) && N(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return A;\n            } else t.match_available = 1, t.strstart++, t.lookahead--;\n          }\n\n          return t.match_available && (i = u._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < x - 1 ? t.strstart : x - 1, e === f ? (N(t, !0), 0 === t.strm.avail_out ? O : B) : t.last_lit && (N(t, !1), 0 === t.strm.avail_out) ? A : I;\n        }\n\n        function M(t, e, r, i, n) {\n          this.good_length = t, this.max_lazy = e, this.nice_length = r, this.max_chain = i, this.func = n;\n        }\n\n        function H() {\n          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new d.Buf16(2 * w), this.dyn_dtree = new d.Buf16(2 * (2 * a + 1)), this.bl_tree = new d.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new d.Buf16(k + 1), this.heap = new d.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new d.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;\n        }\n\n        function G(t) {\n          var e;\n          return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = n, (e = t.state).pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? C : E, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = l, u._tr_init(e), m) : R(t, _);\n        }\n\n        function K(t) {\n          var e = G(t);\n          return e === m && function (t) {\n            t.window_size = 2 * t.w_size, D(t.head), t.max_lazy_match = h[t.level].max_lazy, t.good_match = h[t.level].good_length, t.nice_match = h[t.level].nice_length, t.max_chain_length = h[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = x - 1, t.match_available = 0, t.ins_h = 0;\n          }(t.state), e;\n        }\n\n        function Y(t, e, r, i, n, s) {\n          if (!t) return _;\n          var a = 1;\n          if (e === g && (e = 6), i < 0 ? (a = 0, i = -i) : 15 < i && (a = 2, i -= 16), n < 1 || y < n || r !== v || i < 8 || 15 < i || e < 0 || 9 < e || s < 0 || b < s) return R(t, _);\n          8 === i && (i = 9);\n          var o = new H();\n          return (t.state = o).strm = t, o.wrap = a, o.gzhead = null, o.w_bits = i, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = n + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + x - 1) / x), o.window = new d.Buf8(2 * o.w_size), o.head = new d.Buf16(o.hash_size), o.prev = new d.Buf16(o.w_size), o.lit_bufsize = 1 << n + 6, o.pending_buf_size = 4 * o.lit_bufsize, o.pending_buf = new d.Buf8(o.pending_buf_size), o.d_buf = 1 * o.lit_bufsize, o.l_buf = 3 * o.lit_bufsize, o.level = e, o.strategy = s, o.method = r, K(t);\n        }\n\n        h = [new M(0, 0, 0, 0, function (t, e) {\n          var r = 65535;\n\n          for (r > t.pending_buf_size - 5 && (r = t.pending_buf_size - 5);;) {\n            if (t.lookahead <= 1) {\n              if (j(t), 0 === t.lookahead && e === l) return A;\n              if (0 === t.lookahead) break;\n            }\n\n            t.strstart += t.lookahead, t.lookahead = 0;\n            var i = t.block_start + r;\n            if ((0 === t.strstart || t.strstart >= i) && (t.lookahead = t.strstart - i, t.strstart = i, N(t, !1), 0 === t.strm.avail_out)) return A;\n            if (t.strstart - t.block_start >= t.w_size - z && (N(t, !1), 0 === t.strm.avail_out)) return A;\n          }\n\n          return t.insert = 0, e === f ? (N(t, !0), 0 === t.strm.avail_out ? O : B) : (t.strstart > t.block_start && (N(t, !1), t.strm.avail_out), A);\n        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function (t, e) {\n          return Y(t, e, v, 15, 8, 0);\n        }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function (t, e) {\n          return t && t.state ? 2 !== t.state.wrap ? _ : (t.state.gzhead = e, m) : _;\n        }, r.deflate = function (t, e) {\n          var r, i, n, s;\n          if (!t || !t.state || 5 < e || e < 0) return t ? R(t, _) : _;\n          if (i = t.state, !t.output || !t.input && 0 !== t.avail_in || 666 === i.status && e !== f) return R(t, 0 === t.avail_out ? -5 : _);\n          if (i.strm = t, r = i.last_flush, i.last_flush = e, i.status === C) if (2 === i.wrap) t.adler = 0, U(i, 31), U(i, 139), U(i, 8), i.gzhead ? (U(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)), U(i, 255 & i.gzhead.time), U(i, i.gzhead.time >> 8 & 255), U(i, i.gzhead.time >> 16 & 255), U(i, i.gzhead.time >> 24 & 255), U(i, 9 === i.level ? 2 : 2 <= i.strategy || i.level < 2 ? 4 : 0), U(i, 255 & i.gzhead.os), i.gzhead.extra && i.gzhead.extra.length && (U(i, 255 & i.gzhead.extra.length), U(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (t.adler = p(t.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = 69) : (U(i, 0), U(i, 0), U(i, 0), U(i, 0), U(i, 0), U(i, 9 === i.level ? 2 : 2 <= i.strategy || i.level < 2 ? 4 : 0), U(i, 3), i.status = E);else {\n            var a = v + (i.w_bits - 8 << 4) << 8;\n            a |= (2 <= i.strategy || i.level < 2 ? 0 : i.level < 6 ? 1 : 6 === i.level ? 2 : 3) << 6, 0 !== i.strstart && (a |= 32), a += 31 - a % 31, i.status = E, P(i, a), 0 !== i.strstart && (P(i, t.adler >>> 16), P(i, 65535 & t.adler)), t.adler = 1;\n          }\n          if (69 === i.status) if (i.gzhead.extra) {\n            for (n = i.pending; i.gzindex < (65535 & i.gzhead.extra.length) && (i.pending !== i.pending_buf_size || (i.gzhead.hcrc && i.pending > n && (t.adler = p(t.adler, i.pending_buf, i.pending - n, n)), F(t), n = i.pending, i.pending !== i.pending_buf_size));) U(i, 255 & i.gzhead.extra[i.gzindex]), i.gzindex++;\n\n            i.gzhead.hcrc && i.pending > n && (t.adler = p(t.adler, i.pending_buf, i.pending - n, n)), i.gzindex === i.gzhead.extra.length && (i.gzindex = 0, i.status = 73);\n          } else i.status = 73;\n          if (73 === i.status) if (i.gzhead.name) {\n            n = i.pending;\n\n            do {\n              if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > n && (t.adler = p(t.adler, i.pending_buf, i.pending - n, n)), F(t), n = i.pending, i.pending === i.pending_buf_size)) {\n                s = 1;\n                break;\n              }\n\n              s = i.gzindex < i.gzhead.name.length ? 255 & i.gzhead.name.charCodeAt(i.gzindex++) : 0, U(i, s);\n            } while (0 !== s);\n\n            i.gzhead.hcrc && i.pending > n && (t.adler = p(t.adler, i.pending_buf, i.pending - n, n)), 0 === s && (i.gzindex = 0, i.status = 91);\n          } else i.status = 91;\n          if (91 === i.status) if (i.gzhead.comment) {\n            n = i.pending;\n\n            do {\n              if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > n && (t.adler = p(t.adler, i.pending_buf, i.pending - n, n)), F(t), n = i.pending, i.pending === i.pending_buf_size)) {\n                s = 1;\n                break;\n              }\n\n              s = i.gzindex < i.gzhead.comment.length ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++) : 0, U(i, s);\n            } while (0 !== s);\n\n            i.gzhead.hcrc && i.pending > n && (t.adler = p(t.adler, i.pending_buf, i.pending - n, n)), 0 === s && (i.status = 103);\n          } else i.status = 103;\n\n          if (103 === i.status && (i.gzhead.hcrc ? (i.pending + 2 > i.pending_buf_size && F(t), i.pending + 2 <= i.pending_buf_size && (U(i, 255 & t.adler), U(i, t.adler >> 8 & 255), t.adler = 0, i.status = E)) : i.status = E), 0 !== i.pending) {\n            if (F(t), 0 === t.avail_out) return i.last_flush = -1, m;\n          } else if (0 === t.avail_in && T(e) <= T(r) && e !== f) return R(t, -5);\n\n          if (666 === i.status && 0 !== t.avail_in) return R(t, -5);\n\n          if (0 !== t.avail_in || 0 !== i.lookahead || e !== l && 666 !== i.status) {\n            var o = 2 === i.strategy ? function (t, e) {\n              for (var r;;) {\n                if (0 === t.lookahead && (j(t), 0 === t.lookahead)) {\n                  if (e === l) return A;\n                  break;\n                }\n\n                if (t.match_length = 0, r = u._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, r && (N(t, !1), 0 === t.strm.avail_out)) return A;\n              }\n\n              return t.insert = 0, e === f ? (N(t, !0), 0 === t.strm.avail_out ? O : B) : t.last_lit && (N(t, !1), 0 === t.strm.avail_out) ? A : I;\n            }(i, e) : 3 === i.strategy ? function (t, e) {\n              for (var r, i, n, s, a = t.window;;) {\n                if (t.lookahead <= S) {\n                  if (j(t), t.lookahead <= S && e === l) return A;\n                  if (0 === t.lookahead) break;\n                }\n\n                if (t.match_length = 0, t.lookahead >= x && 0 < t.strstart && (i = a[n = t.strstart - 1]) === a[++n] && i === a[++n] && i === a[++n]) {\n                  s = t.strstart + S;\n\n                  do {} while (i === a[++n] && i === a[++n] && i === a[++n] && i === a[++n] && i === a[++n] && i === a[++n] && i === a[++n] && i === a[++n] && n < s);\n\n                  t.match_length = S - (s - n), t.match_length > t.lookahead && (t.match_length = t.lookahead);\n                }\n\n                if (t.match_length >= x ? (r = u._tr_tally(t, 1, t.match_length - x), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (r = u._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), r && (N(t, !1), 0 === t.strm.avail_out)) return A;\n              }\n\n              return t.insert = 0, e === f ? (N(t, !0), 0 === t.strm.avail_out ? O : B) : t.last_lit && (N(t, !1), 0 === t.strm.avail_out) ? A : I;\n            }(i, e) : h[i.level].func(i, e);\n            if (o !== O && o !== B || (i.status = 666), o === A || o === O) return 0 === t.avail_out && (i.last_flush = -1), m;\n            if (o === I && (1 === e ? u._tr_align(i) : 5 !== e && (u._tr_stored_block(i, 0, 0, !1), 3 === e && (D(i.head), 0 === i.lookahead && (i.strstart = 0, i.block_start = 0, i.insert = 0))), F(t), 0 === t.avail_out)) return i.last_flush = -1, m;\n          }\n\n          return e !== f ? m : i.wrap <= 0 ? 1 : (2 === i.wrap ? (U(i, 255 & t.adler), U(i, t.adler >> 8 & 255), U(i, t.adler >> 16 & 255), U(i, t.adler >> 24 & 255), U(i, 255 & t.total_in), U(i, t.total_in >> 8 & 255), U(i, t.total_in >> 16 & 255), U(i, t.total_in >> 24 & 255)) : (P(i, t.adler >>> 16), P(i, 65535 & t.adler)), F(t), 0 < i.wrap && (i.wrap = -i.wrap), 0 !== i.pending ? m : 1);\n        }, r.deflateEnd = function (t) {\n          var e;\n          return t && t.state ? (e = t.state.status) !== C && 69 !== e && 73 !== e && 91 !== e && 103 !== e && e !== E && 666 !== e ? R(t, _) : (t.state = null, e === E ? R(t, -3) : m) : _;\n        }, r.deflateSetDictionary = function (t, e) {\n          var r,\n              i,\n              n,\n              s,\n              a,\n              o,\n              h,\n              u,\n              l = e.length;\n          if (!t || !t.state) return _;\n          if (2 === (s = (r = t.state).wrap) || 1 === s && r.status !== C || r.lookahead) return _;\n\n          for (1 === s && (t.adler = c(t.adler, e, l, 0)), r.wrap = 0, l >= r.w_size && (0 === s && (D(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0), u = new d.Buf8(r.w_size), d.arraySet(u, e, l - r.w_size, r.w_size, 0), e = u, l = r.w_size), a = t.avail_in, o = t.next_in, h = t.input, t.avail_in = l, t.next_in = 0, t.input = e, j(r); r.lookahead >= x;) {\n            for (i = r.strstart, n = r.lookahead - (x - 1); r.ins_h = (r.ins_h << r.hash_shift ^ r.window[i + x - 1]) & r.hash_mask, r.prev[i & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = i, i++, --n;);\n\n            r.strstart = i, r.lookahead = x - 1, j(r);\n          }\n\n          return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = x - 1, r.match_available = 0, t.next_in = o, t.input = h, t.avail_in = a, r.wrap = s, m;\n        }, r.deflateInfo = \"pako deflate (from Nodeca project)\";\n      }, {\n        \"../utils/common\": 41,\n        \"./adler32\": 43,\n        \"./crc32\": 45,\n        \"./messages\": 51,\n        \"./trees\": 52\n      }],\n      47: [function (t, e, r) {\n        \"use strict\";\n\n        e.exports = function () {\n          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = \"\", this.comment = \"\", this.hcrc = 0, this.done = !1;\n        };\n      }, {}],\n      48: [function (t, e, r) {\n        \"use strict\";\n\n        e.exports = function (t, e) {\n          var r, i, n, s, a, o, h, u, l, f, d, c, p, m, _, g, b, v, y, w, k, x, S, z, C;\n\n          r = t.state, i = t.next_in, z = t.input, n = i + (t.avail_in - 5), s = t.next_out, C = t.output, a = s - (e - t.avail_out), o = s + (t.avail_out - 257), h = r.dmax, u = r.wsize, l = r.whave, f = r.wnext, d = r.window, c = r.hold, p = r.bits, m = r.lencode, _ = r.distcode, g = (1 << r.lenbits) - 1, b = (1 << r.distbits) - 1;\n\n          t: do {\n            p < 15 && (c += z[i++] << p, p += 8, c += z[i++] << p, p += 8), v = m[c & g];\n\n            e: for (;;) {\n              if (c >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255)) C[s++] = 65535 & v;else {\n                if (!(16 & y)) {\n                  if (0 == (64 & y)) {\n                    v = m[(65535 & v) + (c & (1 << y) - 1)];\n                    continue e;\n                  }\n\n                  if (32 & y) {\n                    r.mode = 12;\n                    break t;\n                  }\n\n                  t.msg = \"invalid literal/length code\", r.mode = 30;\n                  break t;\n                }\n\n                w = 65535 & v, (y &= 15) && (p < y && (c += z[i++] << p, p += 8), w += c & (1 << y) - 1, c >>>= y, p -= y), p < 15 && (c += z[i++] << p, p += 8, c += z[i++] << p, p += 8), v = _[c & b];\n\n                r: for (;;) {\n                  if (c >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {\n                    if (0 == (64 & y)) {\n                      v = _[(65535 & v) + (c & (1 << y) - 1)];\n                      continue r;\n                    }\n\n                    t.msg = \"invalid distance code\", r.mode = 30;\n                    break t;\n                  }\n\n                  if (k = 65535 & v, p < (y &= 15) && (c += z[i++] << p, (p += 8) < y && (c += z[i++] << p, p += 8)), h < (k += c & (1 << y) - 1)) {\n                    t.msg = \"invalid distance too far back\", r.mode = 30;\n                    break t;\n                  }\n\n                  if (c >>>= y, p -= y, (y = s - a) < k) {\n                    if (l < (y = k - y) && r.sane) {\n                      t.msg = \"invalid distance too far back\", r.mode = 30;\n                      break t;\n                    }\n\n                    if (S = d, (x = 0) === f) {\n                      if (x += u - y, y < w) {\n                        for (w -= y; C[s++] = d[x++], --y;);\n\n                        x = s - k, S = C;\n                      }\n                    } else if (f < y) {\n                      if (x += u + f - y, (y -= f) < w) {\n                        for (w -= y; C[s++] = d[x++], --y;);\n\n                        if (x = 0, f < w) {\n                          for (w -= y = f; C[s++] = d[x++], --y;);\n\n                          x = s - k, S = C;\n                        }\n                      }\n                    } else if (x += f - y, y < w) {\n                      for (w -= y; C[s++] = d[x++], --y;);\n\n                      x = s - k, S = C;\n                    }\n\n                    for (; 2 < w;) C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;\n\n                    w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));\n                  } else {\n                    for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3););\n\n                    w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));\n                  }\n\n                  break;\n                }\n              }\n              break;\n            }\n          } while (i < n && s < o);\n\n          i -= w = p >> 3, c &= (1 << (p -= w << 3)) - 1, t.next_in = i, t.next_out = s, t.avail_in = i < n ? n - i + 5 : 5 - (i - n), t.avail_out = s < o ? o - s + 257 : 257 - (s - o), r.hold = c, r.bits = p;\n        };\n      }, {}],\n      49: [function (t, e, r) {\n        \"use strict\";\n\n        var I = t(\"../utils/common\"),\n            O = t(\"./adler32\"),\n            B = t(\"./crc32\"),\n            R = t(\"./inffast\"),\n            T = t(\"./inftrees\"),\n            D = 1,\n            F = 2,\n            N = 0,\n            U = -2,\n            P = 1,\n            i = 852,\n            n = 592;\n\n        function L(t) {\n          return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24);\n        }\n\n        function s() {\n          this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;\n        }\n\n        function a(t) {\n          var e;\n          return t && t.state ? (e = t.state, t.total_in = t.total_out = e.total = 0, t.msg = \"\", e.wrap && (t.adler = 1 & e.wrap), e.mode = P, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new I.Buf32(i), e.distcode = e.distdyn = new I.Buf32(n), e.sane = 1, e.back = -1, N) : U;\n        }\n\n        function o(t) {\n          var e;\n          return t && t.state ? ((e = t.state).wsize = 0, e.whave = 0, e.wnext = 0, a(t)) : U;\n        }\n\n        function h(t, e) {\n          var r, i;\n          return t && t.state ? (i = t.state, e < 0 ? (r = 0, e = -e) : (r = 1 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || 15 < e) ? U : (null !== i.window && i.wbits !== e && (i.window = null), i.wrap = r, i.wbits = e, o(t))) : U;\n        }\n\n        function u(t, e) {\n          var r, i;\n          return t ? (i = new s(), (t.state = i).window = null, (r = h(t, e)) !== N && (t.state = null), r) : U;\n        }\n\n        var l,\n            f,\n            d = !0;\n\n        function j(t) {\n          if (d) {\n            var e;\n\n            for (l = new I.Buf32(512), f = new I.Buf32(32), e = 0; e < 144;) t.lens[e++] = 8;\n\n            for (; e < 256;) t.lens[e++] = 9;\n\n            for (; e < 280;) t.lens[e++] = 7;\n\n            for (; e < 288;) t.lens[e++] = 8;\n\n            for (T(D, t.lens, 0, 288, l, 0, t.work, {\n              bits: 9\n            }), e = 0; e < 32;) t.lens[e++] = 5;\n\n            T(F, t.lens, 0, 32, f, 0, t.work, {\n              bits: 5\n            }), d = !1;\n          }\n\n          t.lencode = l, t.lenbits = 9, t.distcode = f, t.distbits = 5;\n        }\n\n        function Z(t, e, r, i) {\n          var n,\n              s = t.state;\n          return null === s.window && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new I.Buf8(s.wsize)), i >= s.wsize ? (I.arraySet(s.window, e, r - s.wsize, s.wsize, 0), s.wnext = 0, s.whave = s.wsize) : (i < (n = s.wsize - s.wnext) && (n = i), I.arraySet(s.window, e, r - i, n, s.wnext), (i -= n) ? (I.arraySet(s.window, e, r - i, i, 0), s.wnext = i, s.whave = s.wsize) : (s.wnext += n, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += n))), 0;\n        }\n\n        r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function (t) {\n          return u(t, 15);\n        }, r.inflateInit2 = u, r.inflate = function (t, e) {\n          var r,\n              i,\n              n,\n              s,\n              a,\n              o,\n              h,\n              u,\n              l,\n              f,\n              d,\n              c,\n              p,\n              m,\n              _,\n              g,\n              b,\n              v,\n              y,\n              w,\n              k,\n              x,\n              S,\n              z,\n              C = 0,\n              E = new I.Buf8(4),\n              A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\n          if (!t || !t.state || !t.output || !t.input && 0 !== t.avail_in) return U;\n          12 === (r = t.state).mode && (r.mode = 13), a = t.next_out, n = t.output, h = t.avail_out, s = t.next_in, i = t.input, o = t.avail_in, u = r.hold, l = r.bits, f = o, d = h, x = N;\n\n          t: for (;;) switch (r.mode) {\n            case P:\n              if (0 === r.wrap) {\n                r.mode = 13;\n                break;\n              }\n\n              for (; l < 16;) {\n                if (0 === o) break t;\n                o--, u += i[s++] << l, l += 8;\n              }\n\n              if (2 & r.wrap && 35615 === u) {\n                E[r.check = 0] = 255 & u, E[1] = u >>> 8 & 255, r.check = B(r.check, E, 2, 0), l = u = 0, r.mode = 2;\n                break;\n              }\n\n              if (r.flags = 0, r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & u) << 8) + (u >> 8)) % 31) {\n                t.msg = \"incorrect header check\", r.mode = 30;\n                break;\n              }\n\n              if (8 != (15 & u)) {\n                t.msg = \"unknown compression method\", r.mode = 30;\n                break;\n              }\n\n              if (l -= 4, k = 8 + (15 & (u >>>= 4)), 0 === r.wbits) r.wbits = k;else if (k > r.wbits) {\n                t.msg = \"invalid window size\", r.mode = 30;\n                break;\n              }\n              r.dmax = 1 << k, t.adler = r.check = 1, r.mode = 512 & u ? 10 : 12, l = u = 0;\n              break;\n\n            case 2:\n              for (; l < 16;) {\n                if (0 === o) break t;\n                o--, u += i[s++] << l, l += 8;\n              }\n\n              if (r.flags = u, 8 != (255 & r.flags)) {\n                t.msg = \"unknown compression method\", r.mode = 30;\n                break;\n              }\n\n              if (57344 & r.flags) {\n                t.msg = \"unknown header flags set\", r.mode = 30;\n                break;\n              }\n\n              r.head && (r.head.text = u >> 8 & 1), 512 & r.flags && (E[0] = 255 & u, E[1] = u >>> 8 & 255, r.check = B(r.check, E, 2, 0)), l = u = 0, r.mode = 3;\n\n            case 3:\n              for (; l < 32;) {\n                if (0 === o) break t;\n                o--, u += i[s++] << l, l += 8;\n              }\n\n              r.head && (r.head.time = u), 512 & r.flags && (E[0] = 255 & u, E[1] = u >>> 8 & 255, E[2] = u >>> 16 & 255, E[3] = u >>> 24 & 255, r.check = B(r.check, E, 4, 0)), l = u = 0, r.mode = 4;\n\n            case 4:\n              for (; l < 16;) {\n                if (0 === o) break t;\n                o--, u += i[s++] << l, l += 8;\n              }\n\n              r.head && (r.head.xflags = 255 & u, r.head.os = u >> 8), 512 & r.flags && (E[0] = 255 & u, E[1] = u >>> 8 & 255, r.check = B(r.check, E, 2, 0)), l = u = 0, r.mode = 5;\n\n            case 5:\n              if (1024 & r.flags) {\n                for (; l < 16;) {\n                  if (0 === o) break t;\n                  o--, u += i[s++] << l, l += 8;\n                }\n\n                r.length = u, r.head && (r.head.extra_len = u), 512 & r.flags && (E[0] = 255 & u, E[1] = u >>> 8 & 255, r.check = B(r.check, E, 2, 0)), l = u = 0;\n              } else r.head && (r.head.extra = null);\n\n              r.mode = 6;\n\n            case 6:\n              if (1024 & r.flags && (o < (c = r.length) && (c = o), c && (r.head && (k = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Array(r.head.extra_len)), I.arraySet(r.head.extra, i, s, c, k)), 512 & r.flags && (r.check = B(r.check, i, c, s)), o -= c, s += c, r.length -= c), r.length)) break t;\n              r.length = 0, r.mode = 7;\n\n            case 7:\n              if (2048 & r.flags) {\n                if (0 === o) break t;\n\n                for (c = 0; k = i[s + c++], r.head && k && r.length < 65536 && (r.head.name += String.fromCharCode(k)), k && c < o;);\n\n                if (512 & r.flags && (r.check = B(r.check, i, c, s)), o -= c, s += c, k) break t;\n              } else r.head && (r.head.name = null);\n\n              r.length = 0, r.mode = 8;\n\n            case 8:\n              if (4096 & r.flags) {\n                if (0 === o) break t;\n\n                for (c = 0; k = i[s + c++], r.head && k && r.length < 65536 && (r.head.comment += String.fromCharCode(k)), k && c < o;);\n\n                if (512 & r.flags && (r.check = B(r.check, i, c, s)), o -= c, s += c, k) break t;\n              } else r.head && (r.head.comment = null);\n\n              r.mode = 9;\n\n            case 9:\n              if (512 & r.flags) {\n                for (; l < 16;) {\n                  if (0 === o) break t;\n                  o--, u += i[s++] << l, l += 8;\n                }\n\n                if (u !== (65535 & r.check)) {\n                  t.msg = \"header crc mismatch\", r.mode = 30;\n                  break;\n                }\n\n                l = u = 0;\n              }\n\n              r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), t.adler = r.check = 0, r.mode = 12;\n              break;\n\n            case 10:\n              for (; l < 32;) {\n                if (0 === o) break t;\n                o--, u += i[s++] << l, l += 8;\n              }\n\n              t.adler = r.check = L(u), l = u = 0, r.mode = 11;\n\n            case 11:\n              if (0 === r.havedict) return t.next_out = a, t.avail_out = h, t.next_in = s, t.avail_in = o, r.hold = u, r.bits = l, 2;\n              t.adler = r.check = 1, r.mode = 12;\n\n            case 12:\n              if (5 === e || 6 === e) break t;\n\n            case 13:\n              if (r.last) {\n                u >>>= 7 & l, l -= 7 & l, r.mode = 27;\n                break;\n              }\n\n              for (; l < 3;) {\n                if (0 === o) break t;\n                o--, u += i[s++] << l, l += 8;\n              }\n\n              switch (r.last = 1 & u, l -= 1, 3 & (u >>>= 1)) {\n                case 0:\n                  r.mode = 14;\n                  break;\n\n                case 1:\n                  if (j(r), r.mode = 20, 6 !== e) break;\n                  u >>>= 2, l -= 2;\n                  break t;\n\n                case 2:\n                  r.mode = 17;\n                  break;\n\n                case 3:\n                  t.msg = \"invalid block type\", r.mode = 30;\n              }\n\n              u >>>= 2, l -= 2;\n              break;\n\n            case 14:\n              for (u >>>= 7 & l, l -= 7 & l; l < 32;) {\n                if (0 === o) break t;\n                o--, u += i[s++] << l, l += 8;\n              }\n\n              if ((65535 & u) != (u >>> 16 ^ 65535)) {\n                t.msg = \"invalid stored block lengths\", r.mode = 30;\n                break;\n              }\n\n              if (r.length = 65535 & u, l = u = 0, r.mode = 15, 6 === e) break t;\n\n            case 15:\n              r.mode = 16;\n\n            case 16:\n              if (c = r.length) {\n                if (o < c && (c = o), h < c && (c = h), 0 === c) break t;\n                I.arraySet(n, i, s, c, a), o -= c, s += c, h -= c, a += c, r.length -= c;\n                break;\n              }\n\n              r.mode = 12;\n              break;\n\n            case 17:\n              for (; l < 14;) {\n                if (0 === o) break t;\n                o--, u += i[s++] << l, l += 8;\n              }\n\n              if (r.nlen = 257 + (31 & u), u >>>= 5, l -= 5, r.ndist = 1 + (31 & u), u >>>= 5, l -= 5, r.ncode = 4 + (15 & u), u >>>= 4, l -= 4, 286 < r.nlen || 30 < r.ndist) {\n                t.msg = \"too many length or distance symbols\", r.mode = 30;\n                break;\n              }\n\n              r.have = 0, r.mode = 18;\n\n            case 18:\n              for (; r.have < r.ncode;) {\n                for (; l < 3;) {\n                  if (0 === o) break t;\n                  o--, u += i[s++] << l, l += 8;\n                }\n\n                r.lens[A[r.have++]] = 7 & u, u >>>= 3, l -= 3;\n              }\n\n              for (; r.have < 19;) r.lens[A[r.have++]] = 0;\n\n              if (r.lencode = r.lendyn, r.lenbits = 7, S = {\n                bits: r.lenbits\n              }, x = T(0, r.lens, 0, 19, r.lencode, 0, r.work, S), r.lenbits = S.bits, x) {\n                t.msg = \"invalid code lengths set\", r.mode = 30;\n                break;\n              }\n\n              r.have = 0, r.mode = 19;\n\n            case 19:\n              for (; r.have < r.nlen + r.ndist;) {\n                for (; g = (C = r.lencode[u & (1 << r.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l);) {\n                  if (0 === o) break t;\n                  o--, u += i[s++] << l, l += 8;\n                }\n\n                if (b < 16) u >>>= _, l -= _, r.lens[r.have++] = b;else {\n                  if (16 === b) {\n                    for (z = _ + 2; l < z;) {\n                      if (0 === o) break t;\n                      o--, u += i[s++] << l, l += 8;\n                    }\n\n                    if (u >>>= _, l -= _, 0 === r.have) {\n                      t.msg = \"invalid bit length repeat\", r.mode = 30;\n                      break;\n                    }\n\n                    k = r.lens[r.have - 1], c = 3 + (3 & u), u >>>= 2, l -= 2;\n                  } else if (17 === b) {\n                    for (z = _ + 3; l < z;) {\n                      if (0 === o) break t;\n                      o--, u += i[s++] << l, l += 8;\n                    }\n\n                    l -= _, k = 0, c = 3 + (7 & (u >>>= _)), u >>>= 3, l -= 3;\n                  } else {\n                    for (z = _ + 7; l < z;) {\n                      if (0 === o) break t;\n                      o--, u += i[s++] << l, l += 8;\n                    }\n\n                    l -= _, k = 0, c = 11 + (127 & (u >>>= _)), u >>>= 7, l -= 7;\n                  }\n\n                  if (r.have + c > r.nlen + r.ndist) {\n                    t.msg = \"invalid bit length repeat\", r.mode = 30;\n                    break;\n                  }\n\n                  for (; c--;) r.lens[r.have++] = k;\n                }\n              }\n\n              if (30 === r.mode) break;\n\n              if (0 === r.lens[256]) {\n                t.msg = \"invalid code -- missing end-of-block\", r.mode = 30;\n                break;\n              }\n\n              if (r.lenbits = 9, S = {\n                bits: r.lenbits\n              }, x = T(D, r.lens, 0, r.nlen, r.lencode, 0, r.work, S), r.lenbits = S.bits, x) {\n                t.msg = \"invalid literal/lengths set\", r.mode = 30;\n                break;\n              }\n\n              if (r.distbits = 6, r.distcode = r.distdyn, S = {\n                bits: r.distbits\n              }, x = T(F, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, S), r.distbits = S.bits, x) {\n                t.msg = \"invalid distances set\", r.mode = 30;\n                break;\n              }\n\n              if (r.mode = 20, 6 === e) break t;\n\n            case 20:\n              r.mode = 21;\n\n            case 21:\n              if (6 <= o && 258 <= h) {\n                t.next_out = a, t.avail_out = h, t.next_in = s, t.avail_in = o, r.hold = u, r.bits = l, R(t, d), a = t.next_out, n = t.output, h = t.avail_out, s = t.next_in, i = t.input, o = t.avail_in, u = r.hold, l = r.bits, 12 === r.mode && (r.back = -1);\n                break;\n              }\n\n              for (r.back = 0; g = (C = r.lencode[u & (1 << r.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l);) {\n                if (0 === o) break t;\n                o--, u += i[s++] << l, l += 8;\n              }\n\n              if (g && 0 == (240 & g)) {\n                for (v = _, y = g, w = b; g = (C = r.lencode[w + ((u & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l);) {\n                  if (0 === o) break t;\n                  o--, u += i[s++] << l, l += 8;\n                }\n\n                u >>>= v, l -= v, r.back += v;\n              }\n\n              if (u >>>= _, l -= _, r.back += _, r.length = b, 0 === g) {\n                r.mode = 26;\n                break;\n              }\n\n              if (32 & g) {\n                r.back = -1, r.mode = 12;\n                break;\n              }\n\n              if (64 & g) {\n                t.msg = \"invalid literal/length code\", r.mode = 30;\n                break;\n              }\n\n              r.extra = 15 & g, r.mode = 22;\n\n            case 22:\n              if (r.extra) {\n                for (z = r.extra; l < z;) {\n                  if (0 === o) break t;\n                  o--, u += i[s++] << l, l += 8;\n                }\n\n                r.length += u & (1 << r.extra) - 1, u >>>= r.extra, l -= r.extra, r.back += r.extra;\n              }\n\n              r.was = r.length, r.mode = 23;\n\n            case 23:\n              for (; g = (C = r.distcode[u & (1 << r.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l);) {\n                if (0 === o) break t;\n                o--, u += i[s++] << l, l += 8;\n              }\n\n              if (0 == (240 & g)) {\n                for (v = _, y = g, w = b; g = (C = r.distcode[w + ((u & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l);) {\n                  if (0 === o) break t;\n                  o--, u += i[s++] << l, l += 8;\n                }\n\n                u >>>= v, l -= v, r.back += v;\n              }\n\n              if (u >>>= _, l -= _, r.back += _, 64 & g) {\n                t.msg = \"invalid distance code\", r.mode = 30;\n                break;\n              }\n\n              r.offset = b, r.extra = 15 & g, r.mode = 24;\n\n            case 24:\n              if (r.extra) {\n                for (z = r.extra; l < z;) {\n                  if (0 === o) break t;\n                  o--, u += i[s++] << l, l += 8;\n                }\n\n                r.offset += u & (1 << r.extra) - 1, u >>>= r.extra, l -= r.extra, r.back += r.extra;\n              }\n\n              if (r.offset > r.dmax) {\n                t.msg = \"invalid distance too far back\", r.mode = 30;\n                break;\n              }\n\n              r.mode = 25;\n\n            case 25:\n              if (0 === h) break t;\n\n              if (c = d - h, r.offset > c) {\n                if ((c = r.offset - c) > r.whave && r.sane) {\n                  t.msg = \"invalid distance too far back\", r.mode = 30;\n                  break;\n                }\n\n                p = c > r.wnext ? (c -= r.wnext, r.wsize - c) : r.wnext - c, c > r.length && (c = r.length), m = r.window;\n              } else m = n, p = a - r.offset, c = r.length;\n\n              for (h < c && (c = h), h -= c, r.length -= c; n[a++] = m[p++], --c;);\n\n              0 === r.length && (r.mode = 21);\n              break;\n\n            case 26:\n              if (0 === h) break t;\n              n[a++] = r.length, h--, r.mode = 21;\n              break;\n\n            case 27:\n              if (r.wrap) {\n                for (; l < 32;) {\n                  if (0 === o) break t;\n                  o--, u |= i[s++] << l, l += 8;\n                }\n\n                if (d -= h, t.total_out += d, r.total += d, d && (t.adler = r.check = r.flags ? B(r.check, n, d, a - d) : O(r.check, n, d, a - d)), d = h, (r.flags ? u : L(u)) !== r.check) {\n                  t.msg = \"incorrect data check\", r.mode = 30;\n                  break;\n                }\n\n                l = u = 0;\n              }\n\n              r.mode = 28;\n\n            case 28:\n              if (r.wrap && r.flags) {\n                for (; l < 32;) {\n                  if (0 === o) break t;\n                  o--, u += i[s++] << l, l += 8;\n                }\n\n                if (u !== (4294967295 & r.total)) {\n                  t.msg = \"incorrect length check\", r.mode = 30;\n                  break;\n                }\n\n                l = u = 0;\n              }\n\n              r.mode = 29;\n\n            case 29:\n              x = 1;\n              break t;\n\n            case 30:\n              x = -3;\n              break t;\n\n            case 31:\n              return -4;\n\n            case 32:\n            default:\n              return U;\n          }\n\n          return t.next_out = a, t.avail_out = h, t.next_in = s, t.avail_in = o, r.hold = u, r.bits = l, (r.wsize || d !== t.avail_out && r.mode < 30 && (r.mode < 27 || 4 !== e)) && Z(t, t.output, t.next_out, d - t.avail_out) ? (r.mode = 31, -4) : (f -= t.avail_in, d -= t.avail_out, t.total_in += f, t.total_out += d, r.total += d, r.wrap && d && (t.adler = r.check = r.flags ? B(r.check, n, d, t.next_out - d) : O(r.check, n, d, t.next_out - d)), t.data_type = r.bits + (r.last ? 64 : 0) + (12 === r.mode ? 128 : 0) + (20 === r.mode || 15 === r.mode ? 256 : 0), (0 == f && 0 === d || 4 === e) && x === N && (x = -5), x);\n        }, r.inflateEnd = function (t) {\n          if (!t || !t.state) return U;\n          var e = t.state;\n          return e.window && (e.window = null), t.state = null, N;\n        }, r.inflateGetHeader = function (t, e) {\n          var r;\n          return t && t.state ? 0 == (2 & (r = t.state).wrap) ? U : ((r.head = e).done = !1, N) : U;\n        }, r.inflateSetDictionary = function (t, e) {\n          var r,\n              i = e.length;\n          return t && t.state ? 0 !== (r = t.state).wrap && 11 !== r.mode ? U : 11 === r.mode && O(1, e, i, 0) !== r.check ? -3 : Z(t, e, i, i) ? (r.mode = 31, -4) : (r.havedict = 1, N) : U;\n        }, r.inflateInfo = \"pako inflate (from Nodeca project)\";\n      }, {\n        \"../utils/common\": 41,\n        \"./adler32\": 43,\n        \"./crc32\": 45,\n        \"./inffast\": 48,\n        \"./inftrees\": 50\n      }],\n      50: [function (t, e, r) {\n        \"use strict\";\n\n        var D = t(\"../utils/common\"),\n            F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],\n            N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78],\n            U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0],\n            P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];\n\n        e.exports = function (t, e, r, i, n, s, a, o) {\n          var h,\n              u,\n              l,\n              f,\n              d,\n              c,\n              p,\n              m,\n              _,\n              g = o.bits,\n              b = 0,\n              v = 0,\n              y = 0,\n              w = 0,\n              k = 0,\n              x = 0,\n              S = 0,\n              z = 0,\n              C = 0,\n              E = 0,\n              A = null,\n              I = 0,\n              O = new D.Buf16(16),\n              B = new D.Buf16(16),\n              R = null,\n              T = 0;\n\n          for (b = 0; b <= 15; b++) O[b] = 0;\n\n          for (v = 0; v < i; v++) O[e[r + v]]++;\n\n          for (k = g, w = 15; 1 <= w && 0 === O[w]; w--);\n\n          if (w < k && (k = w), 0 === w) return n[s++] = 20971520, n[s++] = 20971520, o.bits = 1, 0;\n\n          for (y = 1; y < w && 0 === O[y]; y++);\n\n          for (k < y && (k = y), b = z = 1; b <= 15; b++) if (z <<= 1, (z -= O[b]) < 0) return -1;\n\n          if (0 < z && (0 === t || 1 !== w)) return -1;\n\n          for (B[1] = 0, b = 1; b < 15; b++) B[b + 1] = B[b] + O[b];\n\n          for (v = 0; v < i; v++) 0 !== e[r + v] && (a[B[e[r + v]]++] = v);\n\n          if (c = 0 === t ? (A = R = a, 19) : 1 === t ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, d = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === t && 852 < C || 2 === t && 592 < C) return 1;\n\n          for (;;) {\n            for (p = b - S, _ = a[v] < c ? (m = 0, a[v]) : a[v] > c ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; n[d + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u;);\n\n            for (h = 1 << b - 1; E & h;) h >>= 1;\n\n            if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {\n              if (b === w) break;\n              b = e[r + a[v]];\n            }\n\n            if (k < b && (E & f) !== l) {\n              for (0 === S && (S = k), d += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0);) x++, z <<= 1;\n\n              if (C += 1 << x, 1 === t && 852 < C || 2 === t && 592 < C) return 1;\n              n[l = E & f] = k << 24 | x << 16 | d - s | 0;\n            }\n          }\n\n          return 0 !== E && (n[d + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;\n        };\n      }, {\n        \"../utils/common\": 41\n      }],\n      51: [function (t, e, r) {\n        \"use strict\";\n\n        e.exports = {\n          2: \"need dictionary\",\n          1: \"stream end\",\n          0: \"\",\n          \"-1\": \"file error\",\n          \"-2\": \"stream error\",\n          \"-3\": \"data error\",\n          \"-4\": \"insufficient memory\",\n          \"-5\": \"buffer error\",\n          \"-6\": \"incompatible version\"\n        };\n      }, {}],\n      52: [function (t, e, r) {\n        \"use strict\";\n\n        var n = t(\"../utils/common\"),\n            o = 0,\n            h = 1;\n\n        function i(t) {\n          for (var e = t.length; 0 <= --e;) t[e] = 0;\n        }\n\n        var s = 0,\n            a = 29,\n            u = 256,\n            l = u + 1 + a,\n            f = 30,\n            d = 19,\n            _ = 2 * l + 1,\n            g = 15,\n            c = 16,\n            p = 7,\n            m = 256,\n            b = 16,\n            v = 17,\n            y = 18,\n            w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],\n            k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],\n            x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],\n            S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n            z = new Array(2 * (l + 2));\n\n        i(z);\n        var C = new Array(2 * f);\n        i(C);\n        var E = new Array(512);\n        i(E);\n        var A = new Array(256);\n        i(A);\n        var I = new Array(a);\n        i(I);\n        var O,\n            B,\n            R,\n            T = new Array(f);\n\n        function D(t, e, r, i, n) {\n          this.static_tree = t, this.extra_bits = e, this.extra_base = r, this.elems = i, this.max_length = n, this.has_stree = t && t.length;\n        }\n\n        function F(t, e) {\n          this.dyn_tree = t, this.max_code = 0, this.stat_desc = e;\n        }\n\n        function N(t) {\n          return t < 256 ? E[t] : E[256 + (t >>> 7)];\n        }\n\n        function U(t, e) {\n          t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255;\n        }\n\n        function P(t, e, r) {\n          t.bi_valid > c - r ? (t.bi_buf |= e << t.bi_valid & 65535, U(t, t.bi_buf), t.bi_buf = e >> c - t.bi_valid, t.bi_valid += r - c) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += r);\n        }\n\n        function L(t, e, r) {\n          P(t, r[2 * e], r[2 * e + 1]);\n        }\n\n        function j(t, e) {\n          for (var r = 0; r |= 1 & t, t >>>= 1, r <<= 1, 0 < --e;);\n\n          return r >>> 1;\n        }\n\n        function Z(t, e, r) {\n          var i,\n              n,\n              s = new Array(g + 1),\n              a = 0;\n\n          for (i = 1; i <= g; i++) s[i] = a = a + r[i - 1] << 1;\n\n          for (n = 0; n <= e; n++) {\n            var o = t[2 * n + 1];\n            0 !== o && (t[2 * n] = j(s[o]++, o));\n          }\n        }\n\n        function W(t) {\n          var e;\n\n          for (e = 0; e < l; e++) t.dyn_ltree[2 * e] = 0;\n\n          for (e = 0; e < f; e++) t.dyn_dtree[2 * e] = 0;\n\n          for (e = 0; e < d; e++) t.bl_tree[2 * e] = 0;\n\n          t.dyn_ltree[2 * m] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0;\n        }\n\n        function M(t) {\n          8 < t.bi_valid ? U(t, t.bi_buf) : 0 < t.bi_valid && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0;\n        }\n\n        function H(t, e, r, i) {\n          var n = 2 * e,\n              s = 2 * r;\n          return t[n] < t[s] || t[n] === t[s] && i[e] <= i[r];\n        }\n\n        function G(t, e, r) {\n          for (var i = t.heap[r], n = r << 1; n <= t.heap_len && (n < t.heap_len && H(e, t.heap[n + 1], t.heap[n], t.depth) && n++, !H(e, i, t.heap[n], t.depth));) t.heap[r] = t.heap[n], r = n, n <<= 1;\n\n          t.heap[r] = i;\n        }\n\n        function K(t, e, r) {\n          var i,\n              n,\n              s,\n              a,\n              o = 0;\n          if (0 !== t.last_lit) for (; i = t.pending_buf[t.d_buf + 2 * o] << 8 | t.pending_buf[t.d_buf + 2 * o + 1], n = t.pending_buf[t.l_buf + o], o++, 0 === i ? L(t, n, e) : (L(t, (s = A[n]) + u + 1, e), 0 !== (a = w[s]) && P(t, n -= I[s], a), L(t, s = N(--i), r), 0 !== (a = k[s]) && P(t, i -= T[s], a)), o < t.last_lit;);\n          L(t, m, e);\n        }\n\n        function Y(t, e) {\n          var r,\n              i,\n              n,\n              s = e.dyn_tree,\n              a = e.stat_desc.static_tree,\n              o = e.stat_desc.has_stree,\n              h = e.stat_desc.elems,\n              u = -1;\n\n          for (t.heap_len = 0, t.heap_max = _, r = 0; r < h; r++) 0 !== s[2 * r] ? (t.heap[++t.heap_len] = u = r, t.depth[r] = 0) : s[2 * r + 1] = 0;\n\n          for (; t.heap_len < 2;) s[2 * (n = t.heap[++t.heap_len] = u < 2 ? ++u : 0)] = 1, t.depth[n] = 0, t.opt_len--, o && (t.static_len -= a[2 * n + 1]);\n\n          for (e.max_code = u, r = t.heap_len >> 1; 1 <= r; r--) G(t, s, r);\n\n          for (n = h; r = t.heap[1], t.heap[1] = t.heap[t.heap_len--], G(t, s, 1), i = t.heap[1], t.heap[--t.heap_max] = r, t.heap[--t.heap_max] = i, s[2 * n] = s[2 * r] + s[2 * i], t.depth[n] = (t.depth[r] >= t.depth[i] ? t.depth[r] : t.depth[i]) + 1, s[2 * r + 1] = s[2 * i + 1] = n, t.heap[1] = n++, G(t, s, 1), 2 <= t.heap_len;);\n\n          t.heap[--t.heap_max] = t.heap[1], function (t, e) {\n            var r,\n                i,\n                n,\n                s,\n                a,\n                o,\n                h = e.dyn_tree,\n                u = e.max_code,\n                l = e.stat_desc.static_tree,\n                f = e.stat_desc.has_stree,\n                d = e.stat_desc.extra_bits,\n                c = e.stat_desc.extra_base,\n                p = e.stat_desc.max_length,\n                m = 0;\n\n            for (s = 0; s <= g; s++) t.bl_count[s] = 0;\n\n            for (h[2 * t.heap[t.heap_max] + 1] = 0, r = t.heap_max + 1; r < _; r++) p < (s = h[2 * h[2 * (i = t.heap[r]) + 1] + 1] + 1) && (s = p, m++), h[2 * i + 1] = s, u < i || (t.bl_count[s]++, a = 0, c <= i && (a = d[i - c]), o = h[2 * i], t.opt_len += o * (s + a), f && (t.static_len += o * (l[2 * i + 1] + a)));\n\n            if (0 !== m) {\n              do {\n                for (s = p - 1; 0 === t.bl_count[s];) s--;\n\n                t.bl_count[s]--, t.bl_count[s + 1] += 2, t.bl_count[p]--, m -= 2;\n              } while (0 < m);\n\n              for (s = p; 0 !== s; s--) for (i = t.bl_count[s]; 0 !== i;) u < (n = t.heap[--r]) || (h[2 * n + 1] !== s && (t.opt_len += (s - h[2 * n + 1]) * h[2 * n], h[2 * n + 1] = s), i--);\n            }\n          }(t, e), Z(s, u, t.bl_count);\n        }\n\n        function X(t, e, r) {\n          var i,\n              n,\n              s = -1,\n              a = e[1],\n              o = 0,\n              h = 7,\n              u = 4;\n\n          for (0 === a && (h = 138, u = 3), e[2 * (r + 1) + 1] = 65535, i = 0; i <= r; i++) n = a, a = e[2 * (i + 1) + 1], ++o < h && n === a || (o < u ? t.bl_tree[2 * n] += o : 0 !== n ? (n !== s && t.bl_tree[2 * n]++, t.bl_tree[2 * b]++) : o <= 10 ? t.bl_tree[2 * v]++ : t.bl_tree[2 * y]++, s = n, u = (o = 0) === a ? (h = 138, 3) : n === a ? (h = 6, 3) : (h = 7, 4));\n        }\n\n        function V(t, e, r) {\n          var i,\n              n,\n              s = -1,\n              a = e[1],\n              o = 0,\n              h = 7,\n              u = 4;\n\n          for (0 === a && (h = 138, u = 3), i = 0; i <= r; i++) if (n = a, a = e[2 * (i + 1) + 1], !(++o < h && n === a)) {\n            if (o < u) for (; L(t, n, t.bl_tree), 0 != --o;);else 0 !== n ? (n !== s && (L(t, n, t.bl_tree), o--), L(t, b, t.bl_tree), P(t, o - 3, 2)) : o <= 10 ? (L(t, v, t.bl_tree), P(t, o - 3, 3)) : (L(t, y, t.bl_tree), P(t, o - 11, 7));\n            s = n, u = (o = 0) === a ? (h = 138, 3) : n === a ? (h = 6, 3) : (h = 7, 4);\n          }\n        }\n\n        i(T);\n        var q = !1;\n\n        function J(t, e, r, i) {\n          P(t, (s << 1) + (i ? 1 : 0), 3), function (t, e, r, i) {\n            M(t), i && (U(t, r), U(t, ~r)), n.arraySet(t.pending_buf, t.window, e, r, t.pending), t.pending += r;\n          }(t, e, r, !0);\n        }\n\n        r._tr_init = function (t) {\n          q || (function () {\n            var t,\n                e,\n                r,\n                i,\n                n,\n                s = new Array(g + 1);\n\n            for (i = r = 0; i < a - 1; i++) for (I[i] = r, t = 0; t < 1 << w[i]; t++) A[r++] = i;\n\n            for (A[r - 1] = i, i = n = 0; i < 16; i++) for (T[i] = n, t = 0; t < 1 << k[i]; t++) E[n++] = i;\n\n            for (n >>= 7; i < f; i++) for (T[i] = n << 7, t = 0; t < 1 << k[i] - 7; t++) E[256 + n++] = i;\n\n            for (e = 0; e <= g; e++) s[e] = 0;\n\n            for (t = 0; t <= 143;) z[2 * t + 1] = 8, t++, s[8]++;\n\n            for (; t <= 255;) z[2 * t + 1] = 9, t++, s[9]++;\n\n            for (; t <= 279;) z[2 * t + 1] = 7, t++, s[7]++;\n\n            for (; t <= 287;) z[2 * t + 1] = 8, t++, s[8]++;\n\n            for (Z(z, l + 1, s), t = 0; t < f; t++) C[2 * t + 1] = 5, C[2 * t] = j(t, 5);\n\n            O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, d, p);\n          }(), q = !0), t.l_desc = new F(t.dyn_ltree, O), t.d_desc = new F(t.dyn_dtree, B), t.bl_desc = new F(t.bl_tree, R), t.bi_buf = 0, t.bi_valid = 0, W(t);\n        }, r._tr_stored_block = J, r._tr_flush_block = function (t, e, r, i) {\n          var n,\n              s,\n              a = 0;\n          0 < t.level ? (2 === t.strm.data_type && (t.strm.data_type = function (t) {\n            var e,\n                r = 4093624447;\n\n            for (e = 0; e <= 31; e++, r >>>= 1) if (1 & r && 0 !== t.dyn_ltree[2 * e]) return o;\n\n            if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return h;\n\n            for (e = 32; e < u; e++) if (0 !== t.dyn_ltree[2 * e]) return h;\n\n            return o;\n          }(t)), Y(t, t.l_desc), Y(t, t.d_desc), a = function (t) {\n            var e;\n\n            for (X(t, t.dyn_ltree, t.l_desc.max_code), X(t, t.dyn_dtree, t.d_desc.max_code), Y(t, t.bl_desc), e = d - 1; 3 <= e && 0 === t.bl_tree[2 * S[e] + 1]; e--);\n\n            return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e;\n          }(t), n = t.opt_len + 3 + 7 >>> 3, (s = t.static_len + 3 + 7 >>> 3) <= n && (n = s)) : n = s = r + 5, r + 4 <= n && -1 !== e ? J(t, e, r, i) : 4 === t.strategy || s === n ? (P(t, 2 + (i ? 1 : 0), 3), K(t, z, C)) : (P(t, 4 + (i ? 1 : 0), 3), function (t, e, r, i) {\n            var n;\n\n            for (P(t, e - 257, 5), P(t, r - 1, 5), P(t, i - 4, 4), n = 0; n < i; n++) P(t, t.bl_tree[2 * S[n] + 1], 3);\n\n            V(t, t.dyn_ltree, e - 1), V(t, t.dyn_dtree, r - 1);\n          }(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, a + 1), K(t, t.dyn_ltree, t.dyn_dtree)), W(t), i && M(t);\n        }, r._tr_tally = function (t, e, r) {\n          return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & r, t.last_lit++, 0 === e ? t.dyn_ltree[2 * r]++ : (t.matches++, e--, t.dyn_ltree[2 * (A[r] + u + 1)]++, t.dyn_dtree[2 * N(e)]++), t.last_lit === t.lit_bufsize - 1;\n        }, r._tr_align = function (t) {\n          P(t, 2, 3), L(t, m, z), function (t) {\n            16 === t.bi_valid ? (U(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : 8 <= t.bi_valid && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8);\n          }(t);\n        };\n      }, {\n        \"../utils/common\": 41\n      }],\n      53: [function (t, e, r) {\n        \"use strict\";\n\n        e.exports = function () {\n          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = \"\", this.state = null, this.data_type = 2, this.adler = 0;\n        };\n      }, {}],\n      54: [function (t, e, r) {\n        \"use strict\";\n\n        e.exports = \"function\" == typeof setImmediate ? setImmediate : function () {\n          var t = [].slice.apply(arguments);\n          t.splice(1, 0, 0), setTimeout.apply(null, t);\n        };\n      }, {}]\n    }, {}, [10])(10);\n  });\n});\nconst jeepSqliteCss = \":host{display:block}#fileElem{display:none}\";\nlet JeepSqlite = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.importProgress = createEvent(this, \"jeepSqliteImportProgress\", 7);\n    this.exportProgress = createEvent(this, \"jeepSqliteExportProgress\", 7);\n    this.isStore = false;\n    this._dbDict = {};\n    this.databaseList = {};\n    this._versionUpgrades = {};\n  } //**********************\n  //* Method Definitions *\n  //**********************\n\n\n  echo(options) {\n    return _asyncToGenerator(function* () {\n      return options;\n    })();\n  }\n\n  createConnection(options) {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this17.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this17.storeName} is not opened`);\n      }\n\n      const keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      const dbName = options.database;\n      const version = options.version ? options.version : 1;\n\n      try {\n        yield _this17._createConnection(dbName, version);\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  closeConnection(options) {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this18.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this18.storeName} is not opened`);\n      }\n\n      const keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      const dbName = options.database;\n\n      try {\n        yield _this18._closeConnection(dbName);\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  open(options) {\n    var _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this19.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this19.storeName} is not opened`);\n      }\n\n      const keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      const dbName = options.database;\n\n      try {\n        yield _this19._open(dbName);\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  close(options) {\n    var _this20 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this20.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this20.storeName} is not opened`);\n      }\n\n      const keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      const dbName = options.database;\n\n      try {\n        yield _this20._close(dbName);\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  getVersion(options) {\n    var _this21 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this21.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this21.storeName} is not opened`);\n      }\n\n      const keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      const dbName = options.database;\n\n      try {\n        const res = yield _this21._getVersion(dbName);\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  execute(options) {\n    var _this22 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this22.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this22.storeName} is not opened`);\n      }\n\n      let keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      if (!keys.includes('statements') || options.statements.length === 0) {\n        return Promise.reject('Must provide raw SQL statements');\n      }\n\n      const dbName = options.database;\n      const statements = options.statements;\n      let transaction = true;\n      if (keys.includes('transaction')) transaction = options.transaction;\n\n      try {\n        const changes = yield _this22._execute(dbName, statements, transaction);\n        return Promise.resolve(changes);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  executeSet(options) {\n    var _this23 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this23.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this23.storeName} is not opened`);\n      }\n\n      let keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      if (!keys.includes('set') || options.set.length === 0) {\n        return Promise.reject('Must provide a non-empty set of SQL statements');\n      }\n\n      const dbName = options.database;\n      const setOfStatements = options.set;\n      let transaction = true;\n      if (keys.includes('transaction')) transaction = options.transaction;\n\n      try {\n        const changes = yield _this23._executeSet(dbName, setOfStatements, transaction);\n        return Promise.resolve(changes);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  run(options) {\n    var _this24 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this24.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this24.storeName} is not opened`);\n      }\n\n      let keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      if (!keys.includes('statement') || options.statement.length === 0) {\n        return Promise.reject('Must provide a run statement');\n      }\n\n      const dbName = options.database;\n      const statement = options.statement;\n      let values = [];\n\n      if (keys.includes('values')) {\n        values = options.values.length > 0 ? options.values : [];\n      }\n\n      let transaction = true;\n      if (keys.includes('transaction')) transaction = options.transaction;\n\n      try {\n        const retChanges = yield _this24._run(dbName, statement, values, transaction);\n        return Promise.resolve(retChanges);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  query(options) {\n    var _this25 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this25.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this25.storeName} is not opened`);\n      }\n\n      let keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      if (!keys.includes('statement') || options.statement.length === 0) {\n        return Promise.reject('Must provide a query statement');\n      }\n\n      let values = [];\n\n      if (keys.includes('values')) {\n        values = options.values.length > 0 ? options.values : [];\n      }\n\n      const dbName = options.database;\n      const statement = options.statement;\n\n      try {\n        const retValues = yield _this25._query(dbName, statement, values);\n        return Promise.resolve(retValues);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  isDBExists(options) {\n    var _this26 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this26.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this26.storeName} is not opened`);\n      }\n\n      const keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      const dbName = options.database;\n\n      try {\n        const ret = yield _this26._isDBExists(dbName);\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  isDBOpen(options) {\n    var _this27 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this27.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this27.storeName} is not opened`);\n      }\n\n      const keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      const dbName = options.database;\n\n      try {\n        const ret = yield _this27._isDBOpen(dbName);\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  deleteDatabase(options) {\n    var _this28 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this28.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this28.storeName} is not opened`);\n      }\n\n      const keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      const dbName = options.database;\n\n      try {\n        return yield _this28._deleteDatabase(dbName);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  isStoreOpen() {\n    var _this29 = this;\n\n    return _asyncToGenerator(function* () {\n      return Promise.resolve(_this29.isStore);\n    })();\n  }\n\n  copyFromAssets(options) {\n    var _this30 = this;\n\n    return _asyncToGenerator(function* () {\n      let overwrite;\n\n      if (options != null) {\n        const keys = Object.keys(options);\n        overwrite = keys.includes('overwrite') ? options.overwrite : true;\n      } else {\n        overwrite = true;\n      }\n\n      if (!_this30.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this30.storeName} is not opened`);\n      }\n\n      try {\n        yield _this30._copyFromAssets(overwrite);\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  isTableExists(options) {\n    var _this31 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this31.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this31.storeName} is not opened`);\n      }\n\n      const keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      const dbName = options.database;\n\n      if (!keys.includes('table')) {\n        return Promise.reject('Must provide a table name');\n      }\n\n      const tableName = options.table;\n\n      try {\n        const ret = yield _this31._isTableExists(dbName, tableName);\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  createSyncTable(options) {\n    var _this32 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this32.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this32.storeName} is not opened`);\n      }\n\n      let keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      const dbName = options.database;\n\n      try {\n        const ret = yield _this32._createSyncTable(dbName);\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  getSyncDate(options) {\n    var _this33 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this33.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this33.storeName} is not opened`);\n      }\n\n      let keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      const dbName = options.database;\n\n      try {\n        const ret = yield _this33._getSyncDate(dbName);\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  setSyncDate(options) {\n    var _this34 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this34.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this34.storeName} is not opened`);\n      }\n\n      let keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      if (!keys.includes('syncdate')) {\n        return Promise.reject('Must provide a synchronization date');\n      }\n\n      const dbName = options.database;\n      const syncDate = options.syncdate;\n\n      try {\n        yield _this34._setSyncDate(dbName, syncDate);\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  isJsonValid(options) {\n    var _this35 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(options);\n\n      if (!keys.includes('jsonstring')) {\n        return Promise.reject('Must provide a json object');\n      }\n\n      const jsonStrObj = options.jsonstring;\n\n      try {\n        const ret = yield _this35._isJsonValid(jsonStrObj);\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  importFromJson(options) {\n    var _this36 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this36.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this36.storeName} is not opened`);\n      }\n\n      const keys = Object.keys(options);\n\n      if (!keys.includes('jsonstring')) {\n        return Promise.reject('Must provide a json object');\n      }\n\n      const jsonStrObj = options.jsonstring;\n\n      try {\n        const ret = yield _this36._importFromJson(jsonStrObj);\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  exportToJson(options) {\n    var _this37 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this37.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this37.storeName} is not opened`);\n      }\n\n      const keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      if (!keys.includes('jsonexportmode')) {\n        return Promise.reject('Must provide a json export mode');\n      }\n\n      const dbName = options.database;\n      const exportMode = options.jsonexportmode;\n\n      try {\n        const ret = yield _this37._exportToJson(dbName, exportMode);\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  addUpgradeStatement(options) {\n    var _this38 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this38.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this38.storeName} is not opened`);\n      }\n\n      let keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      if (!keys.includes('upgrade')) {\n        return Promise.reject('Must provide an upgrade statement');\n      }\n\n      const dbName = options.database;\n      const upgrade = options.upgrade[0];\n      keys = Object.keys(upgrade);\n\n      if (!keys.includes('fromVersion') || !keys.includes('toVersion') || !keys.includes('statement')) {\n        return Promise.reject('Must provide an upgrade capSQLiteVersionUpgrade Object');\n      }\n\n      if (typeof upgrade.fromVersion != 'number') {\n        return Promise.reject('ugrade.fromVersion must be a number');\n      }\n\n      const upgVDict = {};\n      upgVDict[upgrade.fromVersion] = upgrade;\n      _this38._versionUpgrades[dbName] = upgVDict;\n      return Promise.resolve();\n    })();\n  }\n\n  isDatabase(options) {\n    var _this39 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this39.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this39.storeName} is not opened`);\n      }\n\n      const keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      const dbName = options.database;\n\n      try {\n        const ret = yield _this39._isDatabase(dbName);\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  getDatabaseList() {\n    var _this40 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this40.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this40.storeName} is not opened`);\n      }\n\n      try {\n        const ret = yield _this40._getDatabaseList();\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  checkConnectionsConsistency(options) {\n    var _this41 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this41.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this41.storeName} is not opened`);\n      }\n\n      const keys = Object.keys(options);\n\n      if (!keys.includes('dbNames')) {\n        return Promise.reject(`Must provide a list of connection's name`);\n      }\n\n      const dbNames = options.dbNames;\n\n      try {\n        const ret = yield _this41._checkConnectionsConsistency(dbNames);\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  saveToStore(options) {\n    var _this42 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this42.isStore) {\n        return Promise.reject(`>>> jeep-sqlite StoreName: ${_this42.storeName} is not opened`);\n      }\n\n      const keys = Object.keys(options);\n\n      if (!keys.includes('database')) {\n        return Promise.reject('Must provide a database name');\n      }\n\n      const dbName = options.database;\n\n      try {\n        yield _this42._saveToStore(dbName);\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  } //*******************************\n  //* Component Lifecycle Methods *\n  //*******************************\n\n\n  componentWillLoad() {\n    var _this43 = this;\n\n    return _asyncToGenerator(function* () {\n      _this43.isStore = yield _this43.openStore(\"jeepSqliteStore\", \"databases\");\n    })();\n  }\n\n  componentDidLoad() {\n    if (this.isStore) {\n      console.log(`>>> jeep-sqlite StoreName: ${this.storeName}`);\n    } else {\n      console.log('>>> jeep-sqlite isStore = false');\n    }\n  } //******************************\n  //* Private Method Definitions *\n  //******************************\n\n\n  _createConnection(database, version) {\n    var _this44 = this;\n\n    return _asyncToGenerator(function* () {\n      let upgDict = {};\n      const vUpgKeys = Object.keys(_this44._versionUpgrades);\n\n      if (vUpgKeys.length !== 0 && vUpgKeys.includes(database)) {\n        upgDict = _this44._versionUpgrades[database];\n      }\n\n      try {\n        const mDB = new Database(database + 'SQLite.db', version, upgDict, _this44.store);\n        _this44._dbDict[database] = mDB;\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err.message);\n      }\n    })();\n  }\n\n  _closeConnection(database) {\n    var _this45 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this45._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject(`CloseConnection: No available connection for ${database}`);\n      }\n\n      const mDB = _this45._dbDict[database];\n\n      try {\n        if (mDB.isDBOpen()) {\n          // close the database\n          try {\n            yield mDB.close();\n          } catch (err) {\n            return Promise.reject(`CloseConnection: close ${database} failed ${err}`);\n          }\n        } // remove the connection from dictionary\n\n\n        delete _this45._dbDict[database];\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(`CloseConnection: ${err.message}`);\n      }\n    })();\n  }\n\n  _open(database) {\n    var _this46 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this46._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject(`Open: No available connection for ${database}`);\n      }\n\n      const mDB = _this46._dbDict[database];\n\n      try {\n        yield mDB.open();\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(`Open: ${err.message}`);\n      }\n    })();\n  }\n\n  _close(database) {\n    var _this47 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this47._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject(`Close: No available connection for ${database}`);\n      }\n\n      const mDB = _this47._dbDict[database];\n\n      try {\n        yield mDB.close();\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(`Close: ${err.message}`);\n      }\n    })();\n  }\n\n  _saveToStore(database) {\n    var _this48 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this48._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject(`SaveToStore: No available connection for ${database}`);\n      }\n\n      const mDB = _this48._dbDict[database];\n\n      try {\n        yield mDB.saveToStore();\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(`SaveToStore: ${err.message}`);\n      }\n    })();\n  }\n\n  _getVersion(database) {\n    var _this49 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this49._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject(`Open: No available connection for ${database}`);\n      }\n\n      const mDB = _this49._dbDict[database];\n\n      try {\n        const version = yield mDB.getVersion();\n        const ret = {};\n        ret.version = version;\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(`Open: ${err.message}`);\n      }\n    })();\n  }\n\n  _execute(database, statements, transaction) {\n    var _this50 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this50._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject(`Execute: No available connection for ${database}`);\n      }\n\n      const mDB = _this50._dbDict[database];\n\n      try {\n        const ret = yield mDB.executeSQL(statements, transaction);\n        const changes = {\n          changes: {\n            changes: ret\n          }\n        };\n        return Promise.resolve(changes);\n      } catch (err) {\n        return Promise.reject(`Execute: ${err.message}`);\n      }\n    })();\n  }\n\n  _executeSet(database, setOfStatements, transaction) {\n    var _this51 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this51._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject(`ExecuteSet: No available connection for ${database}`);\n      }\n\n      const mDB = _this51._dbDict[database];\n\n      for (const sStmt of setOfStatements) {\n        if (!('statement' in sStmt) || !('values' in sStmt)) {\n          return Promise.reject('ExecuteSet: Must provide a set as ' + 'Array of {statement,values}');\n        }\n      }\n\n      try {\n        const ret = yield mDB.execSet(setOfStatements, transaction);\n        const changes = {\n          changes: {\n            changes: ret.changes,\n            lastId: ret.lastId\n          }\n        };\n        return Promise.resolve(changes);\n      } catch (err) {\n        return Promise.reject(`ExecuteSet: ${err.message}`);\n      }\n    })();\n  }\n\n  _run(database, statement, values, transaction) {\n    var _this52 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this52._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject(`Run: No available connection for ${database}`);\n      }\n\n      const mDB = _this52._dbDict[database];\n\n      try {\n        const ret = yield mDB.runSQL(statement, values, transaction);\n        const changes = {\n          changes: {\n            changes: ret.changes,\n            lastId: ret.lastId\n          }\n        };\n        return Promise.resolve(changes);\n      } catch (err) {\n        return Promise.reject(`Run: ${err.message}`);\n      }\n    })();\n  }\n\n  _query(database, statement, values) {\n    var _this53 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this53._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject(`Query: No available connection for ${database}`);\n      }\n\n      const mDB = _this53._dbDict[database];\n      let ret = [];\n\n      try {\n        ret = yield mDB.selectSQL(statement, values);\n        return Promise.resolve({\n          values: ret\n        });\n      } catch (err) {\n        return Promise.reject(`Query failed: ${err.message}`);\n      }\n    })();\n  }\n\n  _isDBExists(database) {\n    var _this54 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this54._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject(`IsDBExists: No available connection for ${database}`);\n      }\n\n      const mDB = _this54._dbDict[database];\n\n      try {\n        const ret = yield mDB.isDBExists(database + 'SQLite.db');\n        const result = {\n          result: ret\n        };\n        return Promise.resolve(result);\n      } catch (err) {\n        return Promise.reject(`IsDBExists: ${err.message}`);\n      }\n    })();\n  }\n\n  _isDBOpen(database) {\n    var _this55 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this55._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject(`IsDBOpen: No available connection for ${database}`);\n      }\n\n      const mDB = _this55._dbDict[database];\n\n      try {\n        const ret = yield mDB.isDBOpen(database + 'SQLite.db');\n        const result = {\n          result: ret\n        };\n        return Promise.resolve(result);\n      } catch (err) {\n        return Promise.reject(`IsDBOpen: ${err.message}`);\n      }\n    })();\n  }\n\n  _deleteDatabase(database) {\n    var _this56 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this56._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject(`DeleteDatabase: No available connection for ${database}`);\n      }\n\n      const mDB = _this56._dbDict[database];\n\n      try {\n        yield mDB.deleteDB(database + 'SQLite.db');\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(`DeleteDatabase: ${err.message}`);\n      }\n    })();\n  }\n\n  _isTableExists(database, table) {\n    var _this57 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this57._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject(`IsTableExists: No available connection for ${database}`);\n      }\n\n      const mDB = _this57._dbDict[database];\n\n      try {\n        const ret = yield mDB.isTable(table);\n        const result = {\n          result: ret\n        };\n        return Promise.resolve(result);\n      } catch (err) {\n        return Promise.reject(`IsTableExists: ${err.message}`);\n      }\n    })();\n  }\n\n  _createSyncTable(database) {\n    var _this58 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this58._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject('CreateSyncTable: No available connection for ' + `${database}`);\n      }\n\n      const mDB = _this58._dbDict[database];\n\n      try {\n        const ret = yield mDB.createSyncTable();\n        return Promise.resolve({\n          changes: {\n            changes: ret\n          }\n        });\n      } catch (err) {\n        return Promise.reject(`CreateSyncTable: ${err.message}`);\n      }\n    })();\n  }\n\n  _getSyncDate(database) {\n    var _this59 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this59._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject('GetSyncDate: No available connection for ' + `${database}`);\n      }\n\n      const mDB = _this59._dbDict[database];\n\n      try {\n        const ret = yield mDB.getSyncDate();\n        return Promise.resolve({\n          syncDate: ret\n        });\n      } catch (err) {\n        return Promise.reject(`GetSyncDate: ${err.message}`);\n      }\n    })();\n  }\n\n  _setSyncDate(database, syncDate) {\n    var _this60 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this60._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject('SetSyncDate: No available connection for ' + `${database}`);\n      }\n\n      const mDB = _this60._dbDict[database];\n\n      try {\n        const ret = yield mDB.setSyncDate(syncDate);\n\n        if (ret.result) {\n          return Promise.resolve();\n        } else {\n          return Promise.reject(`SetSyncDate: ${ret.message}`);\n        }\n      } catch (err) {\n        return Promise.reject(`SetSyncDate: ${err.message}`);\n      }\n    })();\n  }\n\n  _isJsonValid(jsonStrObj) {\n    return _asyncToGenerator(function* () {\n      const jsonObj = JSON.parse(jsonStrObj);\n      const isValid = yield isJsonSQLite(jsonObj);\n\n      if (!isValid) {\n        return Promise.reject('IsJsonValid: Stringify Json Object not Valid');\n      } else {\n        return Promise.resolve({\n          result: true\n        });\n      }\n    })();\n  }\n\n  _importFromJson(jsonStrObj) {\n    var _this61 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const jsonObj = JSON.parse(jsonStrObj);\n      const isValid = yield isJsonSQLite(jsonObj);\n\n      if (!isValid) {\n        return Promise.reject('ImportFromJson: Stringify Json Object not Valid');\n      }\n\n      const vJsonObj = jsonObj;\n      const dbName = `${vJsonObj.database}SQLite.db`;\n      const dbVersion = (_a = vJsonObj.version) !== null && _a !== void 0 ? _a : 1; // Create the database\n\n      const mDb = new Database(dbName, dbVersion, {}, _this61.store);\n\n      try {\n        // Open the database\n        yield mDb.open(); // Import the JsonSQLite Object\n\n        const changes = yield mDb.importJson(vJsonObj, _this61.importProgress); // Close the database\n\n        yield mDb.close();\n        return Promise.resolve({\n          changes: {\n            changes: changes\n          }\n        });\n      } catch (err) {\n        return Promise.reject(`ImportFromJson: ${err.message}`);\n      }\n    })();\n  }\n\n  _exportToJson(database, exportMode) {\n    var _this62 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(_this62._dbDict);\n\n      if (!keys.includes(database)) {\n        return Promise.reject('ExportToJson: No available connection for ' + `${database}`);\n      }\n\n      const mDb = _this62._dbDict[database];\n\n      try {\n        const ret = yield mDb.exportJson(exportMode, _this62.exportProgress);\n        const keys = Object.keys(ret);\n\n        if (keys.includes('message')) {\n          return Promise.reject(`ExportToJson: ${ret.message}`);\n        } else {\n          return Promise.resolve({\n            export: ret\n          });\n        }\n      } catch (err) {\n        return Promise.reject(`ExportToJson: ${err.message}`);\n      }\n    })();\n  }\n\n  _copyFromAssets(overwrite) {\n    var _this63 = this;\n\n    return _asyncToGenerator(function* () {\n      const res = yield _this63.loadJSON('assets/databases/databases.json');\n\n      if (res != null) {\n        _this63.databaseList = JSON.parse(res);\n        const keys = Object.keys(_this63.databaseList);\n\n        if (keys.includes(\"databaseList\")) {\n          try {\n            for (const dbName of _this63.databaseList.databaseList) {\n              if (dbName.substring(dbName.length - 3) === \".db\") {\n                yield _this63.copyDatabase(`assets/databases/${dbName}`, overwrite);\n              }\n\n              if (dbName.substring(dbName.length - 4) === \".zip\") {\n                yield _this63.unzipDatabase(`assets/databases/${dbName}`, overwrite);\n              }\n            }\n\n            return Promise.resolve();\n          } catch (err) {\n            return Promise.reject(`CopyFromAssets: ${err.message}`);\n          }\n        } else {\n          return Promise.reject(`CopyFromAssets: no key databaseList in databases.json`);\n        }\n      } else {\n        return Promise.reject(`CopyFromAssets: no databases.json file in assets/databases folder`);\n      }\n    })();\n  }\n\n  _isDatabase(database) {\n    var _this64 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const ret = yield isDBInStore(database + 'SQLite.db', _this64.store);\n        const result = {\n          result: ret\n        };\n        return Promise.resolve(result);\n      } catch (err) {\n        return Promise.reject(`IsDatabase: ${err.message}`);\n      }\n    })();\n  }\n\n  _getDatabaseList() {\n    var _this65 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const ret = yield getDBListFromStore(_this65.store);\n        const result = {\n          values: ret\n        };\n        return Promise.resolve(result);\n      } catch (err) {\n        return Promise.reject(`GetDatabaseList: ${err.message}`);\n      }\n    })();\n  }\n\n  _checkConnectionsConsistency(dbNames) {\n    var _this66 = this;\n\n    return _asyncToGenerator(function* () {\n      const ret = {};\n      ret.result = false;\n\n      try {\n        let inConnectionsSet = new Set(Object.keys(_this66._dbDict));\n        const outConnectionSet = new Set(dbNames);\n\n        if (outConnectionSet.size === 0) {\n          yield _this66._resetDbDict(Object.keys(_this66._dbDict));\n          return Promise.resolve(ret);\n        }\n\n        if (inConnectionsSet.size < outConnectionSet.size) {\n          yield _this66._resetDbDict(Object.keys(_this66._dbDict));\n          return Promise.resolve(ret);\n        }\n\n        if (inConnectionsSet.size > outConnectionSet.size) {\n          for (const key of inConnectionsSet) {\n            if (!Array.from(outConnectionSet.keys()).includes(key)) {\n              yield _this66._closeConnection(key);\n            }\n          }\n        }\n\n        inConnectionsSet = new Set(Object.keys(_this66._dbDict));\n\n        if (inConnectionsSet.size === outConnectionSet.size) {\n          const symDiffSet = yield _this66.symmetricDifference(inConnectionsSet, outConnectionSet);\n\n          if (symDiffSet.size === 0) {\n            ret.result = true;\n            return Promise.resolve(ret);\n          } else {\n            yield _this66._resetDbDict(Object.keys(_this66._dbDict));\n            return Promise.resolve(ret);\n          }\n        } else {\n          yield _this66._resetDbDict(Object.keys(_this66._dbDict));\n          return Promise.resolve(ret);\n        }\n      } catch (err) {\n        return Promise.reject(`CheckConnectionsConsistency: ${err.message}`);\n      }\n    })();\n  }\n\n  _resetDbDict(keys) {\n    var _this67 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        for (const key of keys) {\n          yield _this67._closeConnection(key);\n        }\n      } catch (err) {\n        return Promise.reject(`ResetDbDict: ${err.message}`);\n      }\n    })();\n  }\n\n  symmetricDifference(setA, setB) {\n    return _asyncToGenerator(function* () {\n      let _difference = new Set(setA);\n\n      for (const elem of setB) {\n        if (_difference.has(elem)) {\n          _difference.delete(elem);\n        } else {\n          _difference.add(elem);\n        }\n      }\n\n      return _difference;\n    })();\n  }\n\n  unzipDatabase(dbZipName, overwrite) {\n    var _this68 = this;\n\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', dbZipName, true);\n        xhr.responseType = 'arraybuffer';\n\n        xhr.onerror = () => {\n          reject(`unzipDatabase: failed`);\n        };\n\n        xhr.onload = () => {\n          try {\n            jszip_min.loadAsync(xhr.response).then(zip => {\n              Object.keys(zip.files).forEach(filename => {\n                zip.files[filename].async('nodebuffer').then( /*#__PURE__*/function () {\n                  var _ref73 = _asyncToGenerator(function* (fileData) {\n                    const uInt8Array = new Uint8Array(fileData);\n\n                    const dbName = _this68.setPathSuffix(filename); // check if dbName exists\n\n\n                    const isExist = yield isDBInStore(dbName, _this68.store);\n\n                    if (!isExist || overwrite) {\n                      if (overwrite && isExist) {\n                        yield removeDBFromStore(dbName, _this68.store);\n                      }\n\n                      yield saveDBToStore(dbName, uInt8Array, _this68.store);\n                    }\n                  });\n\n                  return function (_x138) {\n                    return _ref73.apply(this, arguments);\n                  };\n                }());\n              });\n              resolve();\n            });\n          } catch (err) {\n            reject(`unzipDatabase Error: ${err}`);\n          }\n        };\n\n        xhr.send();\n      });\n    })();\n  }\n\n  copyDatabase(dbAssetName, overwrite) {\n    var _this69 = this;\n\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        var xhr = new XMLHttpRequest();\n        var uInt8Array;\n        xhr.open('GET', dbAssetName, true);\n        xhr.responseType = 'arraybuffer';\n\n        xhr.onerror = () => {\n          reject(`CopyDatabase: failed`);\n        };\n\n        xhr.onload = () => {\n          uInt8Array = new Uint8Array(xhr.response);\n        };\n\n        xhr.onloadend = /*#__PURE__*/_asyncToGenerator(function* () {\n          const dbName = _this69.setPathSuffix(dbAssetName); // check if dbName exists\n\n\n          const isExist = yield isDBInStore(dbName, _this69.store);\n\n          if (!isExist || overwrite) {\n            if (overwrite && isExist) {\n              yield removeDBFromStore(dbName, _this69.store);\n            }\n\n            yield saveDBToStore(dbName, uInt8Array, _this69.store);\n          }\n\n          resolve();\n        });\n        xhr.send();\n      });\n    })();\n  }\n\n  loadJSON(jsonFileName) {\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        var xobj = new XMLHttpRequest();\n        xobj.overrideMimeType(\"application/json\");\n        xobj.open('GET', jsonFileName, true);\n\n        xobj.onerror = () => {\n          reject(`LoadJSON: failed`);\n        };\n\n        xobj.onreadystatechange = function () {\n          if (xobj.status == 404) resolve(null);\n\n          if (xobj.readyState == 4 && xobj.status == 200) {\n            // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode\n            resolve(xobj.responseText);\n          }\n        };\n\n        xobj.send(null);\n      });\n    })();\n  }\n\n  openStore(dbName, tableName) {\n    var _this70 = this;\n\n    return _asyncToGenerator(function* () {\n      let ret = false;\n\n      const config = _this70.setConfig(dbName, tableName);\n\n      _this70.store = localforage.createInstance(config);\n\n      if (_this70.store != null) {\n        _this70.storeName = dbName;\n        ret = true;\n      }\n\n      return ret;\n    })();\n  }\n\n  setConfig(dbName, tableName) {\n    const config = {\n      name: dbName,\n      storeName: tableName,\n      driver: [localforage.INDEXEDDB],\n      version: 1\n    };\n    return config;\n  }\n\n  setPathSuffix(db) {\n    let toDb = db.slice(db.lastIndexOf(\"/\") + 1);\n    const ext = \".db\";\n\n    if (db.substring(db.length - 3) === ext) {\n      if (!db.includes(\"SQLite.db\")) {\n        toDb = db.slice(db.lastIndexOf(\"/\") + 1, -3) + 'SQLite.db';\n      }\n    }\n\n    return toDb;\n  }\n\n  render() {\n    return;\n  }\n\n  static get assetsDirs() {\n    return [\"assets\"];\n  }\n\n};\nJeepSqlite.style = jeepSqliteCss;\nexport { JeepSqlite as jeep_sqlite };","map":null,"metadata":{},"sourceType":"module"}