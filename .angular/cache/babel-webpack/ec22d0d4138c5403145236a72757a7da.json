{"ast":null,"code":"/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nconst transitionEndAsync = (el, expectedDuration = 0) => {\n  return new Promise(resolve => {\n    transitionEnd(el, expectedDuration, resolve);\n  });\n};\n/**\n * Allows developer to wait for a transition\n * to finish and fallback to a timer if the\n * transition is cancelled or otherwise\n * never finishes. Also see transitionEndAsync\n * which is an await-able version of this.\n */\n\n\nconst transitionEnd = (el, expectedDuration = 0, callback) => {\n  let unRegTrans;\n  let animationTimeout;\n  const opts = {\n    passive: true\n  };\n  const ANIMATION_FALLBACK_TIMEOUT = 500;\n\n  const unregister = () => {\n    if (unRegTrans) {\n      unRegTrans();\n    }\n  };\n\n  const onTransitionEnd = ev => {\n    if (ev === undefined || el === ev.target) {\n      unregister();\n      callback(ev);\n    }\n  };\n\n  if (el) {\n    el.addEventListener('webkitTransitionEnd', onTransitionEnd, opts);\n    el.addEventListener('transitionend', onTransitionEnd, opts);\n    animationTimeout = setTimeout(onTransitionEnd, expectedDuration + ANIMATION_FALLBACK_TIMEOUT);\n\n    unRegTrans = () => {\n      if (animationTimeout) {\n        clearTimeout(animationTimeout);\n        animationTimeout = undefined;\n      }\n\n      el.removeEventListener('webkitTransitionEnd', onTransitionEnd, opts);\n      el.removeEventListener('transitionend', onTransitionEnd, opts);\n    };\n  }\n\n  return unregister;\n};\n/**\n * Waits for a component to be ready for\n * both custom element and non-custom element builds.\n * If non-custom element build, el.componentOnReady\n * will be used.\n * For custom element builds, we wait a frame\n * so that the inner contents of the component\n * have a chance to render.\n *\n * Use this utility rather than calling\n * el.componentOnReady yourself.\n */\n\n\nconst componentOnReady = (el, callback) => {\n  if (el.componentOnReady) {\n    el.componentOnReady().then(resolvedEl => callback(resolvedEl));\n  } else {\n    raf(() => callback(el));\n  }\n};\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `ion-input` should inherit\n * the `title` attribute that developers set directly on `ion-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\n\n\nconst inheritAttributes = (el, attributes = []) => {\n  const attributeObject = {};\n  attributes.forEach(attr => {\n    if (el.hasAttribute(attr)) {\n      const value = el.getAttribute(attr);\n\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n\n      el.removeAttribute(attr);\n    }\n  });\n  return attributeObject;\n};\n\nconst addEventListener = (el, eventName, callback, opts) => {\n  if (typeof window !== 'undefined') {\n    const win = window;\n    const config = win && win.Ionic && win.Ionic.config;\n\n    if (config) {\n      const ael = config.get('_ael');\n\n      if (ael) {\n        return ael(el, eventName, callback, opts);\n      } else if (config._ael) {\n        return config._ael(el, eventName, callback, opts);\n      }\n    }\n  }\n\n  return el.addEventListener(eventName, callback, opts);\n};\n\nconst removeEventListener = (el, eventName, callback, opts) => {\n  if (typeof window !== 'undefined') {\n    const win = window;\n    const config = win && win.Ionic && win.Ionic.config;\n\n    if (config) {\n      const rel = config.get('_rel');\n\n      if (rel) {\n        return rel(el, eventName, callback, opts);\n      } else if (config._rel) {\n        return config._rel(el, eventName, callback, opts);\n      }\n    }\n  }\n\n  return el.removeEventListener(eventName, callback, opts);\n};\n/**\n * Gets the root context of a shadow dom element\n * On newer browsers this will be the shadowRoot,\n * but for older browser this may just be the\n * element itself.\n *\n * Useful for whenever you need to explicitly\n * do \"myElement.shadowRoot!.querySelector(...)\".\n */\n\n\nconst getElementRoot = (el, fallback = el) => {\n  return el.shadowRoot || fallback;\n};\n/**\n * Patched version of requestAnimationFrame that avoids ngzone\n * Use only when you know ngzone should not run\n */\n\n\nconst raf = h => {\n  if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n    return __zone_symbol__requestAnimationFrame(h);\n  }\n\n  if (typeof requestAnimationFrame === 'function') {\n    return requestAnimationFrame(h);\n  }\n\n  return setTimeout(h);\n};\n\nconst hasShadowDom = el => {\n  return !!el.shadowRoot && !!el.attachShadow;\n};\n\nconst findItemLabel = componentEl => {\n  const itemEl = componentEl.closest('ion-item');\n\n  if (itemEl) {\n    return itemEl.querySelector('ion-label');\n  }\n\n  return null;\n};\n\nconst focusElement = el => {\n  el.focus();\n  /**\n   * When programmatically focusing an element,\n   * the focus-visible utility will not run because\n   * it is expecting a keyboard event to have triggered this;\n   * however, there are times when we need to manually control\n   * this behavior so we call the `setFocus` method on ion-app\n   * which will let us explicitly set the elements to focus.\n   */\n\n  if (el.classList.contains('ion-focusable')) {\n    const app = el.closest('ion-app');\n\n    if (app) {\n      app.setFocus([el]);\n    }\n  }\n};\n/**\n * This method is used for Ionic's input components that use Shadow DOM. In\n * order to properly label the inputs to work with screen readers, we need\n * to get the text content of the label outside of the shadow root and pass\n * it to the input inside of the shadow root.\n *\n * Referencing label elements by id from outside of the component is\n * impossible due to the shadow boundary, read more here:\n * https://developer.salesforce.com/blogs/2020/01/accessibility-for-web-components.html\n *\n * @param componentEl The shadow element that needs the aria label\n * @param inputId The unique identifier for the input\n */\n\n\nconst getAriaLabel = (componentEl, inputId) => {\n  let labelText; // If the user provides their own label via the aria-labelledby attr\n  // we should use that instead of looking for an ion-label\n\n  const labelledBy = componentEl.getAttribute('aria-labelledby'); // Grab the id off of the component in case they are using\n  // a custom label using the label element\n\n  const componentId = componentEl.id;\n  let labelId = labelledBy !== null && labelledBy.trim() !== '' ? labelledBy : inputId + '-lbl';\n  let label = labelledBy !== null && labelledBy.trim() !== '' ? document.getElementById(labelledBy) : findItemLabel(componentEl);\n\n  if (label) {\n    if (labelledBy === null) {\n      label.id = labelId;\n    }\n\n    labelText = label.textContent;\n    label.setAttribute('aria-hidden', 'true'); // if there is no label, check to see if the user has provided\n    // one by setting an id on the component and using the label element\n  } else if (componentId.trim() !== '') {\n    label = document.querySelector(`label[for=\"${componentId}\"]`);\n\n    if (label) {\n      if (label.id !== '') {\n        labelId = label.id;\n      } else {\n        label.id = labelId = `${componentId}-lbl`;\n      }\n\n      labelText = label.textContent;\n    }\n  }\n\n  return {\n    label,\n    labelId,\n    labelText\n  };\n};\n/**\n * This method is used to add a hidden input to a host element that contains\n * a Shadow DOM. It does not add the input inside of the Shadow root which\n * allows it to be picked up inside of forms. It should contain the same\n * values as the host element.\n *\n * @param always Add a hidden input even if the container does not use Shadow\n * @param container The element where the input will be added\n * @param name The name of the input\n * @param value The value of the input\n * @param disabled If true, the input is disabled\n */\n\n\nconst renderHiddenInput = (always, container, name, value, disabled) => {\n  if (always || hasShadowDom(container)) {\n    let input = container.querySelector('input.aux-input');\n\n    if (!input) {\n      input = container.ownerDocument.createElement('input');\n      input.type = 'hidden';\n      input.classList.add('aux-input');\n      container.appendChild(input);\n    }\n\n    input.disabled = disabled;\n    input.name = name;\n    input.value = value || '';\n  }\n};\n\nconst clamp = (min, n, max) => {\n  return Math.max(min, Math.min(n, max));\n};\n\nconst assert = (actual, reason) => {\n  if (!actual) {\n    const message = 'ASSERT: ' + reason;\n    console.error(message);\n    debugger; // tslint:disable-line\n\n    throw new Error(message);\n  }\n};\n\nconst now = ev => {\n  return ev.timeStamp || Date.now();\n};\n\nconst pointerCoord = ev => {\n  // get X coordinates for either a mouse click\n  // or a touch depending on the given event\n  if (ev) {\n    const changedTouches = ev.changedTouches;\n\n    if (changedTouches && changedTouches.length > 0) {\n      const touch = changedTouches[0];\n      return {\n        x: touch.clientX,\n        y: touch.clientY\n      };\n    }\n\n    if (ev.pageX !== undefined) {\n      return {\n        x: ev.pageX,\n        y: ev.pageY\n      };\n    }\n  }\n\n  return {\n    x: 0,\n    y: 0\n  };\n};\n/**\n * @hidden\n * Given a side, return if it should be on the end\n * based on the value of dir\n * @param side the side\n * @param isRTL whether the application dir is rtl\n */\n\n\nconst isEndSide = side => {\n  const isRTL = document.dir === 'rtl';\n\n  switch (side) {\n    case 'start':\n      return isRTL;\n\n    case 'end':\n      return !isRTL;\n\n    default:\n      throw new Error(`\"${side}\" is not a valid value for [side]. Use \"start\" or \"end\" instead.`);\n  }\n};\n\nconst debounceEvent = (event, wait) => {\n  const original = event._original || event;\n  return {\n    _original: event,\n    emit: debounce(original.emit.bind(original), wait)\n  };\n};\n\nconst debounce = (func, wait = 0) => {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(func, wait, ...args);\n  };\n};\n\nexport { addEventListener as a, removeEventListener as b, componentOnReady as c, clamp as d, getAriaLabel as e, focusElement as f, getElementRoot as g, renderHiddenInput as h, inheritAttributes as i, debounceEvent as j, findItemLabel as k, hasShadowDom as l, assert as m, isEndSide as n, debounce as o, pointerCoord as p, now as q, raf as r, transitionEndAsync as t };","map":null,"metadata":{},"sourceType":"module"}